Library = loadstring(game:HttpGet('https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/refs/heads/main/Library.lua'))()

    Window = Library:CreateWindow({

    Title = 'Vilant Exploit V2   |   discord.gg/VfmXpbgC9E',
    Center = true,
    AutoShow = true,
    TabPadding = 9
    })

    Tabs = {
    Main = Window:AddTab('Main'),
    Visuals = Window:AddTab('Visuals'),
    Misc = Window:AddTab('Misc'),
    Teleport = Window:AddTab('Teleport'),
    }

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Aimbot')

    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Camera = workspace.CurrentCamera
    local Workspace = game:GetService("Workspace")
    
    local LocalPlayer = Players.LocalPlayer
    
    local cursorLocked = false
    local targetHead = nil
    local targetPlayer = nil
    local previewHighlight = nil
    local lockedHighlight = nil
    local predictionLevel = 0 -- Default prediction level, can be changed (higher value = more prediction)
    local currentKeybind = Enum.KeyCode.C
    local previewColor = Color3.fromRGB(0, 0, 255) -- Default preview color
    local lockedHighlightColor = Color3.fromRGB(255, 0, 0) -- Default locked highlight color
    local smoothness = 0 -- Default smoothness value
    local highlightsEnabled = false -- Default value for highlights toggle
    
    local ragelock = false  -- Default value for ragelock
    local orbitActive = false  -- Flag for orbit feature
    local orbitSpeed = 10 -- Orbit speed
    local radius = 8 -- Orbit size
    local rotation = CFrame.Angles(0, 0, 0) -- Rotation angles
    
    if _G.aimlock == nil then
        _G.aimlock = false  -- Default value if not previously set
    end
    
    local function IsPlayerKnockedOrGrabbed(player)
        local character = player.Character
        if character then
            local bodyEffects = character:FindFirstChild("BodyEffects")
            local grabbingConstraint = character:FindFirstChild("GRABBING_CONSTRAINT")
            if bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value or grabbingConstraint then
                return true
            end
        end
        return false
    end
    
    -- Function to calculate the predicted position based on velocity
    local function GetPredictedPosition(player)
        local character = player.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            local head = character:FindFirstChild("Head")
            if humanoid and head then
                local velocity = humanoid.RootPart.AssemblyLinearVelocity
                return head.Position + velocity * predictionLevel
            end
        end
        return nil
    end
    
    local function FindClosestPlayerHead()
        local closestPlayer = nil
        local closestDistance = math.huge
        local mousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
    
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
                local character = player.Character
                local humanoid = character:FindFirstChild("Humanoid")
    
                if humanoid and humanoid.Health > 0 then
                    if IsPlayerKnockedOrGrabbed(player) then continue end  -- Skip locked/knocked/grabbed players
                    local head = character.Head
                    local predictedHeadPosition = GetPredictedPosition(player) or head.Position
                    local screenPoint = Camera:WorldToScreenPoint(predictedHeadPosition)
                    local distance = (mousePosition - Vector2.new(screenPoint.X, screenPoint.Y)).Magnitude
                    local playerDistance = (Camera.CFrame.Position - predictedHeadPosition).Magnitude
    
                    local ray = Ray.new(Camera.CFrame.Position, predictedHeadPosition - Camera.CFrame.Position)
                    local hitPart, hitPosition = Workspace:FindPartOnRay(ray, LocalPlayer.Character)
    
                    if playerDistance <= 100 or (not hitPart or hitPart.Parent == character) then
                        if distance < closestDistance then
                            closestDistance = distance
                            closestPlayer = player
                        end
                    end
                end
            end
        end
    
        if closestPlayer then
            return closestPlayer.Character.Head, closestPlayer
        end
        return nil, nil
    end
    
    local function AddPreviewHighlight(player)
        if not highlightsEnabled then return end -- Skip if highlights are disabled
    
        if previewHighlight and previewHighlight.Parent == player.Character then
            previewHighlight.FillColor = previewColor
            return
        end
    
        if previewHighlight then
            previewHighlight:Destroy()
        end
    
        if player and player.Character then
            previewHighlight = Instance.new("Highlight")
            previewHighlight.Parent = player.Character
            previewHighlight.FillTransparency = 0.5
            previewHighlight.FillColor = previewColor
        end
    end
    
    local function AddLockedHighlight(player)
        if not highlightsEnabled then return end -- Skip if highlights are disabled
    
        if lockedHighlight and lockedHighlight.Parent == player.Character then
            lockedHighlight.FillColor = lockedHighlightColor
            return
        end
    
        if lockedHighlight then
            lockedHighlight:Destroy()
        end
    
        if player and player.Character then
            lockedHighlight = Instance.new("Highlight")
            lockedHighlight.Parent = player.Character
            lockedHighlight.FillTransparency = 0.5
            lockedHighlight.FillColor = lockedHighlightColor
        end
    end
    
    local function LockCursorToHead()
        targetHead, targetPlayer = FindClosestPlayerHead()
        if targetHead then
            AddLockedHighlight(targetPlayer)  -- Add highlight to locked player
            if previewHighlight then previewHighlight:Destroy() end  -- Destroy preview highlight if it exists
            UserInputService.MouseIconEnabled = false
        end
    end
    
    local function UnlockCursor()
        UserInputService.MouseIconEnabled = true
        targetHead = nil
        targetPlayer = nil
        if lockedHighlight then lockedHighlight:Destroy() end
    end
    
    local function ActivateOrbit(player)
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            targetPlayer = player
        end
    end
    
    -- Function to deactivate orbiting
    local function DeactivateOrbit()
        targetPlayer = nil
    end
    
    -- Function to handle automatic targeting for RageLock
    local function HandleRageLock()
        -- Ensure RageLock only locks onto the target if it's valid
        if ragelock then
            -- Check if targetPlayer is invalid or knocked
            if targetPlayer and IsPlayerKnockedOrGrabbed(targetPlayer) then
                -- If the locked target is knocked or grabbed, unlock and search for the next target
                cursorLocked = false
                UnlockCursor()
                DeactivateOrbit()
                print("[RageLock] Target is knocked/grabbed, unlocking and searching for next target.")
                targetHead, targetPlayer = FindClosestPlayerHead()
                if targetPlayer then
                    cursorLocked = true
                    LockCursorToHead()
                    AddLockedHighlight(targetPlayer)  -- Add highlight to new target
                end
                return
            end
    
            -- If no valid target is locked, search for a new one
            if not targetPlayer then
                targetHead, targetPlayer = FindClosestPlayerHead()
                if targetPlayer then
                    cursorLocked = true
                    LockCursorToHead()
                    AddLockedHighlight(targetPlayer)  -- Add highlight to new target
                end
            end
        end
    end
    
    -- Orbit update loop (only runs when orbit toggle is true)
    RunService.Stepped:Connect(function(_, dt)
        if orbitActive then
            -- Only update orbit if the toggle is true and the player is locked onto a valid target
            if cursorLocked and targetPlayer then
                -- Only update orbit if the target is locked (Aimlock or RageLock)
                local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if targetHumanoidRootPart then
                    local rot = tick() * orbitSpeed
                    local lpr = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if lpr then
                        -- Orbit calculation (only orbits if locked onto target)
                        lpr.CFrame = CFrame.new(
                            targetHumanoidRootPart.Position + Vector3.new(math.sin(rot) * radius, 0, math.cos(rot) * radius)
                        )
                    end
                end
            end
        end
    
        -- Update loop to continuously follow the locked target for aimlock
        if cursorLocked and _G.aimlock and targetHead then
    
            -- Check if the locked player is knocked or grabbed and unlock if necessary
            if IsPlayerKnockedOrGrabbed(targetPlayer) then
                cursorLocked = false
                UnlockCursor()
                DeactivateOrbit()
                print("[Auto Unlock] Target player is knocked or grabbed, unlocking cursor.")
            else
                        -- Proceed with the normal aimlock and orbit
        local predictedHeadPosition = GetPredictedPosition(targetPlayer) or targetHead.Position
        -- Smoothly interpolate the camera's CFrame
        local alpha = 1 - smoothness
        alpha = math.max(alpha, 0.01)  -- Ensure alpha is never 0
        Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, predictedHeadPosition), alpha)
            end
        elseif not cursorLocked and _G.aimlock then
            local closestHead, closestPlayer = FindClosestPlayerHead()
            if closestPlayer ~= targetPlayer then
                AddPreviewHighlight(closestPlayer)
            end
        end
    end)
    
    -- Handle key press (C) for locking the cursor
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == currentKeybind then
            if _G.aimlock then
                cursorLocked = not cursorLocked
                if cursorLocked then
                    LockCursorToHead()
                    if orbitActive then
                        ActivateOrbit(targetPlayer)  -- Activate orbit when locking onto a player and orbiting is enabled
                    end
                else
                    UnlockCursor()
                    DeactivateOrbit()  -- Deactivate orbit when unlocking
                end
            end
        end
    end)
    
    -- UI Controls for setting various values like keybinds and highlight colors
    LeftGroupBox:AddToggle('Aimbot', {
        Text = 'Aimbot',
        Default = false,
        Tooltip = 'Locks your aim onto players heads',
        Callback = function(Value)
            _G.aimlock = Value
            print('[cb] Aimbot changed to:', Value)
            if _G.aimlock then
                cursorLocked = false  -- Ensure cursor is not locked when aimlock is turned on
            end
        end
    })
    
    LeftGroupBox:AddToggle('OrbitFeature', {
        Text = 'Target Strafe',
        Default = false,
        Tooltip = 'Toggle to start strafing around the player you lock onto.',
        Callback = function(value)
            orbitActive = value  -- Directly set orbitActive based on toggle state
            if orbitActive and cursorLocked then
                ActivateOrbit(targetPlayer) -- Activate orbit only if locked onto a player
            else
                DeactivateOrbit()  -- Deactivate orbit when the toggle is off
            end
        end
    })
    
    -- Add Toggle for Highlights
    LeftGroupBox:AddToggle('HighlightsToggle', {
        Text = 'Chams',
        Default = highlightsEnabled,
        Tooltip = 'Toggle to enable or disable Chams',
        Callback = function(Value)
            highlightsEnabled = Value
            print('[cb] Chams toggled:', Value)
            if not Value then
                -- Destroy highlights if they exist
                if previewHighlight then
                    previewHighlight:Destroy()
                    previewHighlight = nil
                end
                if lockedHighlight then
                    lockedHighlight:Destroy()
                    lockedHighlight = nil
                end
            end
        end
    })

LeftGroupBox:AddToggle('MyToggle', {
        Text = 'Rapid Fire',
        Default = false, -- Default value (true / false)
        Tooltip = 'Rapid Fire is better for some', -- Information shown when you hover over the toggle
    
        Callback = function(Value)
    
            -- Ensure script state is toggled correctly on each execution
            if _G.gunActivation == nil then
                _G.gunActivation = false  -- Default value if not previously set
            end
    
            -- Toggle script state
            _G.gunActivation = not _G.gunActivation
    
            -- Store frequently used Enum values in variables
            local UserInputType = Enum.UserInputType
            local MouseButton1 = UserInputType.MouseButton1
    
            if _G.gunActivation then
                local player = game.Players.LocalPlayer
                local userInputService = game:GetService("UserInputService")
                local runService = game:GetService("RunService")
                local isActive = false  -- Tracks whether the gun activation is enabled or not
    
                -- Function to continuously activate the held item (gun) at the fastest rate possible
                local function continuouslyActivateHeldItem()
                    while _G.gunActivation and runService.Heartbeat:Wait() do
                        if isActive then
                            local character = player.Character
                            if character then
                                local gunTool = character:FindFirstChildOfClass("Tool")
                                if gunTool then
                                    gunTool:Activate()
                                end
                            end
                        end
                    end
                end
    
                local function onMouseClick(input, gameProcessedEvent)
                    if gameProcessedEvent then return end
    
                    if input.UserInputType == MouseButton1 then
                        isActive = true
                    end
                end
    
                local function onMouseRelease(input, gameProcessedEvent)
                    if gameProcessedEvent then return end
    
                    if input.UserInputType == MouseButton1 then
                        isActive = false
                    end
                end
    
                _G.mouseClickConnection = userInputService.InputBegan:Connect(onMouseClick)
                _G.mouseReleaseConnection = userInputService.InputEnded:Connect(onMouseRelease)
                spawn(continuouslyActivateHeldItem)
            else
                if _G.mouseClickConnection then
                    _G.mouseClickConnection:Disconnect()
                    _G.mouseClickConnection = nil
                end
                if _G.mouseReleaseConnection then
                    _G.mouseReleaseConnection:Disconnect()
                    _G.mouseReleaseConnection = nil
                end
            end
        end
    })   
    
    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
        Default = 'C',
        SyncToggleState = false,
        Mode = 'Toggle',
        Text = 'Aimbot',
        ChangedCallback = function(New)
            print('[cb] Keybind changed!', New)
            currentKeybind = New
        end
    })
    
    LeftGroupBox:AddLabel('Preview Color'):AddColorPicker('PreviewColorPicker', {
        Default = previewColor,
        Title = 'Preview Color',
        Transparency = 0,
        Callback = function(Value)
            print('[cb] Preview Color changed!', Value)
            previewColor = Value
            if previewHighlight then
                previewHighlight.FillColor = Value
            end
        end
    })
    
    LeftGroupBox:AddLabel('Locked Cham Color'):AddColorPicker('LockedColorPicker', {
        Default = lockedHighlightColor,
        Title = 'Locked Cham Color',
        Transparency = 0,
        Callback = function(Value)
            print('[cb] Locked Cham Color changed!', Value)
            lockedHighlightColor = Value
            if lockedHighlight then
                lockedHighlight.FillColor = Value
            end
        end
    }) 
    
    LeftGroupBox:AddSlider('SmoothnessSlider', {
        Text = 'Smoothness',
        Default = smoothness,
        Min = 0,
        Max = 1,
        Rounding = 2,
        Callback = function(Value)
            print('[cb] Smoothness changed!', Value)
            smoothness = Value
        end
    })
    
    LeftGroupBox:AddSlider('Strafe Speed', {
        Text = 'Strafe Speed',
        Default = orbitSpeed,
        Min = 0,
        Max = 100,
        Rounding = 1,
        Callback = function(Value)
            print('[cb] Orbit Speed changed!', Value)
            orbitSpeed = Value
        end
    })
    
    LeftGroupBox:AddSlider('PredictionSlider', {
        Text = 'Prediction',
        Default = predictionLevel,
        Min = 0,
        Max = 1,
        Rounding = 1,
        Callback = function(Value)
            print('[cb] Prediction changed!', Value)
            predictionLevel = Value
        end
    })

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Triggerbot')

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local lp = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer"):Wait() and Players.LocalPlayer
local mouse = lp:GetMouse()

local EnumKeyCode = Enum.KeyCode -- Store Enum values for reuse
local EnumUserInputType = Enum.UserInputType

local Script = {
    Functions = {},
    Table = {
        Start = {
            TriggerBot = {
                Keybind = "Z", -- Default keybind, can be changed via UI
                Delay = 0.1, -- Default delay, can be changed via UI
                Blacklisted = {} -- Add blacklisted tool names here
            }
        }
    },
    Connections = {}
}

-- Use Object Pooling for frequently accessed properties like BodyEffects
Script.Functions.isDead = function(player)
    local character = player.Character
    if not character then return false end

    local bodyEffects = character:FindFirstChild("BodyEffects")
    if not bodyEffects then return false end

    local ko = bodyEffects:FindFirstChild("K.O") or bodyEffects:FindFirstChild("KO")
    return ko and ko.Value or false
end

Script.Functions.getTarget = function(instance)
    if not instance then return false end

    for _, player in next, Players:GetPlayers() do
        if player.Character and (instance == player.Character or instance:IsDescendantOf(player.Character)) then
            if not Script.Functions.isDead(player) then
                return player
            end
        end
    end

    return false
end

Script.Functions.isToolBlacklisted = function(tool)
    for _, toolName in ipairs(Script.Table.Start.TriggerBot.Blacklisted) do
        if tool.Name == toolName then
            return true
        end
    end
    return false
end

-- Flag to toggle triggerbot state
local JAIROUGH = false
local hotkeyEnabled = false -- Flag to control if the hotkey is enabled or not

-- Update delay when slider is changed
Script.Functions.updateDelay = function(Value)
    Script.Table.Start.TriggerBot.Delay = Value
end

-- Toggle triggerbot state on keypress, but only if hotkey is enabled
Script.Functions.onKeyPress = function(input, gameProcessed)
    if gameProcessed then return end

    -- Only allow the hotkey to toggle triggerbot if the hotkey is enabled
    if hotkeyEnabled and input.UserInputType == EnumUserInputType.Keyboard and input.KeyCode == EnumKeyCode[Script.Table.Start.TriggerBot.Keybind] then
        JAIROUGH = not JAIROUGH
    end
end

-- Keybind handler to change keybind via UI
Script.Functions.updateKeybind = function(NewKey)
    Script.Table.Start.TriggerBot.Keybind = NewKey.Name
    print('[cb] Keybind changed!', NewKey.Name)
end

UserInputService.InputBegan:Connect(Script.Functions.onKeyPress)

-- TriggerBot activation logic
Script.Functions.triggerBot = function()
    local con
    con = RunService.Heartbeat:Connect(function()
        if JAIROUGH then
            local target = mouse.Target
            if target and Script.Functions.getTarget(target) then
                if lp.Character then
                    local tool = lp.Character:FindFirstChildWhichIsA('Tool')
                    if tool and not Script.Functions.isToolBlacklisted(tool) then
                        task.wait(Script.Table.Start.TriggerBot.Delay)
                        tool:Activate()
                    end
                end
            end
        end
    end)

    Script.Connections.triggerBot = con
end

Script.Functions.triggerBot()

-- Disable function to disconnect triggerbot and cleanup
getgenv().disable = function()
    getgenv().disable = nil
    if Script.Connections.triggerBot then
        Script.Connections.triggerBot:Disconnect()
    end
end

-- UI Integration
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Enable Hotkey',
    Default = false, -- Default value (true / false)
    Tooltip = 'Enable or Disable the hotkey for TriggerBot', -- Information shown when you hover over the toggle
    Callback = function(Value)
        -- Enable or disable hotkey based on toggle state
        hotkeyEnabled = Value
        
        -- If hotkey is disabled, immediately disable the TriggerBot as well
        if not hotkeyEnabled then
            JAIROUGH = false
        end
    end
})

LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
    Default = Script.Table.Start.TriggerBot.Keybind, -- Default keybind value
    SyncToggleState = false, -- Keybind is independent of toggle state
    Mode = 'Toggle', -- Modes: Always, Toggle, Hold
    Text = 'Triggerbot Keybind', -- Text to display in the keybind menu
    NoUI = false, -- Set to true if you want to hide from the Keybind menu,
    ChangedCallback = function(New)
        Script.Functions.updateKeybind(New)
    end
})

LeftGroupBox:AddSlider('MySlider', {
    Text = 'Delay Slider',
    Default = Script.Table.Start.TriggerBot.Delay, -- Default delay value
    Min = 0,
    Max = 1,
    Rounding = 3,
    Compact = false,
    Callback = function(Value)
        Script.Functions.updateDelay(Value)
    end
})

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Shoot Gun')

getgenv().TracerEnabled = true
getgenv().AutoShootEnabled = true
getgenv().shootCooldown = 0.1
getgenv().ScriptEnabled = false
getgenv().LockKey = Enum.KeyCode.T

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Camera = game.Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local MainEvent = ReplicatedStorage:FindFirstChild("MainEvent")
local selectedPlayer = nil
local lockedPlayer = nil

local tracer = Drawing.new("Line")
tracer.Thickness = 2
tracer.Visible = false
tracer.Color = Color3.fromRGB(128, 0, 128)

if not MainEvent then
    return
end

local function isKnocked(player)
    if player and player.Character then
        local KO = player.Character:FindFirstChild("BodyEffects") and player.Character.BodyEffects:FindFirstChild("K.O")
        return KO and KO.Value == true
    end
    return false
end

local function getClosestPlayerToMouse()
    local closestPlayer = nil
    local shortestDistance = math.huge
    local mousePos = UserInputService:GetMouseLocation()

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") and not isKnocked(player) then
            local head = player.Character.Head
            local headScreenPos, onScreen = Camera:WorldToViewportPoint(head.Position)

            if onScreen then
                local distance = (Vector2.new(headScreenPos.X, headScreenPos.Y) - mousePos).Magnitude
                if distance < shortestDistance then
                    closestPlayer = player
                    shortestDistance = distance
                end
            end
        end
    end

    return closestPlayer
end

local function updateTracer()
    if getgenv().TracerEnabled and getgenv().ScriptEnabled then
        local targetPlayer = lockedPlayer or getClosestPlayerToMouse()

        if targetPlayer then
            local head = targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head")
            if head then
                local headScreenPos, onScreen = Camera:WorldToViewportPoint(head.Position)

                if onScreen then
                    selectedPlayer = targetPlayer
                    tracer.Visible = true
                    tracer.To = Vector2.new(headScreenPos.X, headScreenPos.Y)
                    tracer.From = UserInputService:GetMouseLocation()
                end
            end
        else
            tracer.Visible = false
        end
    end
end

local function shoot()
    if lockedPlayer and lockedPlayer.Character and not isKnocked(lockedPlayer) and getgenv().ScriptEnabled then
        local targetHead = lockedPlayer.Character:FindFirstChild("Head")
        local Tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")

        if Tool and Tool:FindFirstChild("Handle") and targetHead then
            MainEvent:FireServer(
                "ShootGun",
                Tool.Handle,
                Tool.Handle.Position,
                targetHead.Position,
                targetHead,
                Vector3.new(0, 0, 0)
            )
        end
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == getgenv().LockKey and not gameProcessed then
        if getgenv().ScriptEnabled then
            if lockedPlayer then
                lockedPlayer = nil
            else
                lockedPlayer = getClosestPlayerToMouse()
            end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if getgenv().ScriptEnabled then
        updateTracer()

        if lockedPlayer then
            shoot()
        end
    else
        tracer.Visible = false
    end
end)

LeftGroupBox:AddToggle('ScriptToggle', {
    Text = 'Toggle Shoot Gun',
    Default = false,

    Callback = function(Value)
        if Value then
            getgenv().ScriptEnabled = true
        else
            getgenv().ScriptEnabled = false
            tracer.Visible = false
        end
    end
})

LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
    Default = 'T',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Shoot Gun Keybind',
    NoUI = false,

    Callback = function(Value)
    end,

    ChangedCallback = function(New)
        getgenv().LockKey = New
    end
})

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Kill Aura')

LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Toggle Kill Aura',
    Default = false,
    Tooltip = 'Enables The Kill Aura Feature',
    Callback = function(Value)
        if Value then
        player = game:GetService("Players").LocalPlayer
        runService = game:GetService("RunService")
        workspace = game:GetService("Workspace")

        range = 100
        killAuraEnabled = true

        local lastDamagedPlayer = nil

        function isGunEquipped()
            local character = player.Character
            if character then
                local tool = character:FindFirstChildWhichIsA("Tool")
                return tool and tool:FindFirstChild("Handle") ~= nil
            end
            return false
        end

        function isTargetValid(targetCharacter)
            if targetCharacter then
                local bodyEffects = targetCharacter:FindFirstChild("BodyEffects")
                local KOd = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
                local Grabbed = targetCharacter:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
                return not KOd and not Grabbed
            end
            return false
        end

        function getNearestPlayer()
            local character = player.Character
            local rootPart = character and character:FindFirstChild("HumanoidRootPart")
            local nearestPlayer = nil
            local shortestDistance = range

            if rootPart then
                for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
                    if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and isTargetValid(plr.Character) then
                        local targetRootPart = plr.Character:FindFirstChild("HumanoidRootPart")
                        local distance = (targetRootPart.Position - rootPart.Position).Magnitude

                        if distance <= shortestDistance then
                            nearestPlayer = plr
                            shortestDistance = distance
                        end
                    end
                end
            end
            return nearestPlayer
        end

        function shootNearestPlayer()
            if not killAuraEnabled or not isGunEquipped() then
                return
            end

            local character = player.Character
            local rootPart = character and character:FindFirstChild("HumanoidRootPart")
            local tool = character and character:FindFirstChildWhichIsA("Tool") or player.Backpack:FindFirstChildWhichIsA("Tool")
            local targetPlayer = getNearestPlayer()

            if tool and tool:FindFirstChild("Handle") and rootPart and targetPlayer and targetPlayer.Character then
                local targetHead = targetPlayer.Character:FindFirstChild("Head")
                if targetHead then
                    local direction = (targetHead.Position - rootPart.Position).unit
                    game:GetService("ReplicatedStorage"):WaitForChild("MainEvent"):FireServer("ShootGun", tool.Handle, rootPart.Position, targetHead.Position, targetHead, direction)
                end
            end
        end

        runService.Heartbeat:Connect(function()
            if killAuraEnabled then
                shootNearestPlayer()
            end
        end)  
        else
            killAuraEnabled = false
        end
    end
})

local LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('ESP')

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = game:GetService("Workspace").CurrentCamera
local LocalPlayer = Players.LocalPlayer

local ESP = {}
ESP.Boxes = {}
local scaleFactor = 1 -- Default scale factor for box sizes
local espEnabled = false -- Toggle state for ESP
local espColor = Color3.fromRGB(255, 255, 255) -- Default ESP box color (White)

-- Function to add ESP box
function ESP:AddBox(player)
    if player == LocalPlayer then return end
    
    local box = Drawing.new("Square")
    box.Thickness = 1
    box.Color = espColor -- Set default color
    box.Filled = false
    box.Transparency = 1
    box.Visible = false
    
    ESP.Boxes[player] = box
end

-- Remove ESP box when player leaves or dies
Players.PlayerRemoving:Connect(function(player)
    if ESP.Boxes[player] then
        ESP.Boxes[player]:Remove()
        ESP.Boxes[player] = nil
    end
end)

-- Listen for character respawn (death/reset) and cleanup old boxes
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        -- Remove the old box if it exists
        if ESP.Boxes[player] then
            ESP.Boxes[player]:Remove()
        end

        -- Add a new box for the new character
        ESP:AddBox(player)
    end)
end)

-- Toggle to activate/deactivate ESP
LeftGroupBox:AddToggle('ESPEnabled', {
    Text = 'Boxes ESP',
    Default = false, -- Default value is false (disabled)
    Tooltip = 'Enable or disable the ESP boxes',
    
    Callback = function(Value)
        espEnabled = Value
        if not espEnabled then
            -- Hide all ESP boxes when disabled
            for _, box in pairs(ESP.Boxes) do
                box.Visible = false
            end
        end
    end
})

-- Slider to adjust box size
LeftGroupBox:AddSlider('BoxSize', {
    Text = 'Box Size',
    Default = 1,
    Min = 0.5,
    Max = 3,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        scaleFactor = Value
    end
})

-- Color picker for ESP box color
LeftGroupBox:AddLabel('Box Color'):AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 1, 1), -- Default White
    Title = 'Box Color',
    Transparency = 0,
    
    Callback = function(Value)
        espColor = Value
        -- Apply color change to all existing ESP boxes
        for _, box in pairs(ESP.Boxes) do
            box.Color = espColor
        end
    end
})

-- Main loop for rendering ESP boxes
RunService.RenderStepped:Connect(function()
    if not espEnabled then return end -- If ESP is disabled, skip the loop
    
    local cameraPosition = Camera.CFrame.Position
    for _, player in pairs(Players:GetPlayers()) do
        local character = player.Character
        local box = ESP.Boxes[player]

        if character and box then
            local head = character:FindFirstChild("Head")
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            local humanoid = character:FindFirstChild("Humanoid")
            local foot = character:FindFirstChild("LeftFoot") or character:FindFirstChild("RightFoot") or character:FindFirstChild("HumanoidRootPart") -- Use foot for accurate bottom
            
            if rootPart and head and foot and humanoid and humanoid.Health > 0 then
                local headPos, headOnScreen = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0))
                local footPos, footOnScreen = Camera:WorldToViewportPoint(foot.Position - Vector3.new(0, 1, 0))
                
                if headOnScreen and footOnScreen then
                    local height = math.abs(headPos.Y - footPos.Y)
                    local distance = (cameraPosition - rootPart.Position).Magnitude
                    local scale = math.clamp(1 / (distance / 10), 0.6, 1.5) -- Prevents extreme scaling
                    
                    local width = height / 2 -- Adjusted width for better proportion
                    
                    -- Apply both the default scale and the slider-controlled scale
                    box.Size = Vector2.new(width * scale * scaleFactor, height * scale * scaleFactor)
                    box.Position = Vector2.new(headPos.X - (width * scale * scaleFactor) / 2, headPos.Y)
                    box.Color = espColor -- Ensure color stays updated
                    box.Visible = true
                else
                    box.Visible = false
                end
            else
                box.Visible = false
            end
        elseif not box and player ~= LocalPlayer then
            ESP:AddBox(player)
        end
    end
end)

-- Add boxes for existing players
for _, player in pairs(Players:GetPlayers()) do
    ESP:AddBox(player)
end

local ESPSection = Tabs.Visuals:AddLeftGroupbox('Corner Box ESP')

local ESPEnabled = false
local ESPConnections = {}
local ESPObjects = {}
local DisplayOption = "Username"

local function ToggleESP(Value)
    ESPEnabled = Value
    if not Value then
        for _, connection in ipairs(ESPConnections) do
            connection:Disconnect()
        end
        ESPConnections = {}
        for _, obj in pairs(ESPObjects) do
            if obj then
                obj:Destroy()
            end
        end
        ESPObjects = {}
    else
        for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
            if not ESPObjects[player] then
                CreateESP(player)
            end
        end
    end
end

local Settings = {
    Box_Color = Color3.fromRGB(255, 255, 255), -- Set box outline to white
    Box_Thickness = 2,
    Team_Check = false,
    Team_Color = false,
    Autothickness = true,
    ESP_Active = false, -- To control ESP activation
}

ESPSection:AddToggle('ESP_Toggle', {
    Text = 'Corner Boxes',
    Default = false, -- ESP is inactive by default
    Tooltip = 'Toggle the visibility of the corner ESP boxes.',
    Callback = function(Value)
        Settings.ESP_Active = Value -- Set the global setting to the toggle value
    end
})

local Space = game:GetService("Workspace")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Camera = Space.CurrentCamera
local RunService = game:GetService("RunService")

local function NewLine(color, thickness)
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = color
    line.Thickness = thickness
    line.Transparency = 1
    return line
end

local function Vis(lib, state)
    for i, v in pairs(lib) do
        v.Visible = state
    end
end

local function Colorize(lib, color)
    for i, v in pairs(lib) do
        v.Color = color
    end
end

local function Main(plr)
    repeat wait() until plr.Character and plr.Character:FindFirstChild("Humanoid")
    
    local R15 = plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R15
    local Library = {
        TL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness)
    }

    local oripart = Instance.new("Part")
    oripart.Parent = Space
    oripart.Transparency = 1
    oripart.CanCollide = false
    oripart.Size = Vector3.new(1, 1, 1)
    oripart.Position = Vector3.new(0, 0, 0)

        local function Updater()
        local c
        c = RunService.RenderStepped:Connect(function()
            if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") then
                local Hum = plr.Character
                local HumPos, vis = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position)

                if vis then
                    oripart.Size = Vector3.new(Hum.HumanoidRootPart.Size.X, Hum.HumanoidRootPart.Size.Y * 1.5, Hum.HumanoidRootPart.Size.Z)
                    oripart.CFrame = CFrame.new(Hum.HumanoidRootPart.CFrame.Position, Camera.CFrame.Position)
                    local SizeX = oripart.Size.X
                    local SizeY = oripart.Size.Y
                    local TL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(SizeX, SizeY, 0)).p)
                    local TR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-SizeX, SizeY, 0)).p)
                    local BL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(SizeX, -SizeY, 0)).p)
                    local BR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-SizeX, -SizeY, 0)).p)

                    if Settings.Team_Check then
                        if plr.TeamColor == Player.TeamColor then
                            Colorize(Library, Color3.fromRGB(0, 255, 0))
                        else
                            Colorize(Library, Color3.fromRGB(255, 0, 0))
                        end
                    end

                    if Settings.Team_Color then
                        Colorize(Library, plr.TeamColor.Color)
                    end

                    local ratio = (Camera.CFrame.p - Hum.HumanoidRootPart.Position).magnitude
                    local offset = math.clamp(1 / ratio * 750, 2, 300)

                    Library.TL1.From = Vector2.new(TL.X, TL.Y)
                    Library.TL1.To = Vector2.new(TL.X + offset, TL.Y)
                    Library.TL2.From = Vector2.new(TL.X, TL.Y)
                    Library.TL2.To = Vector2.new(TL.X, TL.Y + offset)

                    Library.TR1.From = Vector2.new(TR.X, TR.Y)
                    Library.TR1.To = Vector2.new(TR.X - offset, TR.Y)
                    Library.TR2.From = Vector2.new(TR.X, TR.Y)
                    Library.TR2.To = Vector2.new(TR.X, TR.Y + offset)

                    Library.BL1.From = Vector2.new(BL.X, BL.Y)
                    Library.BL1.To = Vector2.new(BL.X + offset, BL.Y)
                    Library.BL2.From = Vector2.new(BL.X, BL.Y)
                    Library.BL2.To = Vector2.new(BL.X, BL.Y - offset)

                    Library.BR1.From = Vector2.new(BR.X, BR.Y)
                    Library.BR1.To = Vector2.new(BR.X - offset, BR.Y)
                    Library.BR2.From = Vector2.new(BR.X, BR.Y)
                    Library.BR2.To = Vector2.new(BR.X, BR.Y - offset)

                    Vis(Library, Settings.ESP_Active)

                    if Settings.Autothickness then
                        local distance = (Player.Character.HumanoidRootPart.Position - oripart.Position).magnitude
                        local value = math.clamp(1 / distance * 100, 1, 4) --0.1 is min thickness, 6 is max
                        for u, x in pairs(Library) do
                            x.Thickness = value
                        end
                    else
                        for u, x in pairs(Library) do
                            x.Thickness = Settings.Box_Thickness
                        end
                    end
                else
                    Vis(Library, false)
                end
            else
                Vis(Library, false)
                if not Players:FindFirstChild(plr.Name) then
                    for i, v in pairs(Library) do
                        v:Remove()
                    end
                    oripart:Destroy()
                    c:Disconnect()
                end
            end
        end)
    end
    coroutine.wrap(Updater)()
end

for _, v in pairs(Players:GetPlayers()) do
    if v.Name ~= Player.Name then
        coroutine.wrap(Main)(v)
    end
end

Players.PlayerAdded:Connect(function(newplr)
    coroutine.wrap(Main)(newplr)
end)

local LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('Name ESP')

Players = game:GetService("Players")
RunService = game:GetService("RunService")
Debris = game:GetService("Debris")  -- For cleanup
LocalPlayer = Players.LocalPlayer

displayOption = 'Username'  -- Default display option
nameTagESPEnabled = false  -- Default for the name tag ESP toggle

-- Function to create a name tag for a player
function CreateNameTag(player)
    -- Skip the local player
    if player == LocalPlayer then return end

    local character = player.Character or player.CharacterAdded:Wait()
    local head = character:WaitForChild("Head")

    -- Create BillboardGui and TextLabel for the name tag
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Parent = character
    billboardGui.Size = UDim2.new(0, 100, 0, 30)  -- Adjust the size for the name tag
    billboardGui.AlwaysOnTop = true
    billboardGui.Adornee = head
    billboardGui.StudsOffset = Vector3.new(0, 6, 0)  -- Adjust position

    local nameTag = Instance.new("TextLabel")
    nameTag.Parent = billboardGui
    nameTag.Size = UDim2.new(1, 0, 1, 0)  -- Full size of the BillboardGui
    nameTag.BackgroundTransparency = 1
    nameTag.TextColor3 = Color3.new(1, 1, 1)  -- White text color
    nameTag.TextStrokeTransparency = 0.6  -- Adjust outline visibility
    nameTag.TextStrokeColor3 = Color3.new(0, 0, 0)  -- Black stroke for visibility
    nameTag.TextSize = 10  -- Smaller base text size

    -- Set the name text based on the selected option
    if displayOption == "Username" then
        nameTag.Text = player.Name  -- Display the player's username
    else
        nameTag.Text = player.DisplayName  -- Display the player's display name
    end

    -- Cleanup when the player leaves
    Debris:AddItem(billboardGui, 5)  -- Automatically cleanup after 5 seconds
end

-- Function to remove name tags
function RemoveNameTags()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character then
            local character = player.Character
            local billboardGui = character:FindFirstChildOfClass("BillboardGui")
            if billboardGui then
                -- Cleanup with Debris service
                Debris:AddItem(billboardGui, 0)
            end
        end
    end
end

-- Add the toggle to enable or disable the Name Tag ESP
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Name ESP',
    Default = false,  -- Default value (true / false)
    Tooltip = 'Toggles the name tag ESP visibility.',
    Callback = function(Value)
        nameTagESPEnabled = Value
        if nameTagESPEnabled then
            -- Update name tags immediately if ESP is enabled
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    CreateNameTag(player)
                end
            end
        else
            -- If ESP is disabled, remove all name tags
            RemoveNameTags()
        end
    end
})

-- Add the dropdown for selecting between Username or DisplayName
LeftGroupBox:AddDropdown('NameDisplayOption', {
    Values = { 'DisplayName', 'Username' },
    Default = 1,  -- Default to "Username"
    Multi = false, -- Single selection only
    Text = 'Name Display Option',
    Tooltip = 'Choose whether to display the player\'s Username or DisplayName',
    Callback = function(Value)
        displayOption = Value  -- Update the display option based on dropdown selection
        if nameTagESPEnabled then
            -- Reapply name tags immediately when the dropdown value changes
            RemoveNameTags()  -- Remove existing name tags
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    CreateNameTag(player)
                end
            end
        end
    end
})

-- Periodically update name tags every heartbeat (for new players)
RunService.Heartbeat:Connect(function()
    if nameTagESPEnabled then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and not player.Character:FindFirstChildOfClass("BillboardGui") then
                CreateNameTag(player)
            end
        end
    end
end)

local LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('Cham ESP')

Players = game:GetService("Players")
RunService = game:GetService("RunService")
LocalPlayer = Players.LocalPlayer
highlightColor = Color3.fromRGB(255, 255, 255)  -- Default color for chams

-- Function to create a cham (highlight) effect for a player
function CreateCham(player)
    local character = player.Character or player.CharacterAdded:Wait()
    if not character:FindFirstChild("HumanoidRootPart") then return end

    -- Create the highlight object for the player's character
    local highlight = Instance.new("Highlight")
    highlight.Name = "ChamHighlight"
    highlight.Parent = character
    highlight.Adornee = character  -- Set the highlight target to the entire character
    highlight.FillColor = highlightColor  -- Set color to chosen value
    highlight.FillTransparency = 0.5  -- Make the highlight semi-transparent
    highlight.OutlineTransparency = 1  -- Fully transparent outline (no outline)

    -- Clean up when the character is removed
    character:WaitForChild("HumanoidRootPart").AncestryChanged:Connect(function()
        highlight:Destroy()  -- Remove the highlight when the player leaves or the character is destroyed
    end)
end

LeftGroupBox:AddToggle('ChamsToggle', {
    Text = 'Chams',
    Default = false, -- Default value (true / false)
    Tooltip = 'Toggles cham effect for players',

    Callback = function(Value)
        _G.chams = Value
        -- Apply or remove the cham effect based on the toggle state
        if _G.chams then
            -- Apply cham effect for players when enabled
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    CreateCham(player)
                end
            end
        else
            -- Remove cham effect for players when disabled
            for _, player in pairs(Players:GetPlayers()) do
                local character = player.Character
                if character then
                    local highlight = character:FindFirstChild("ChamHighlight")
                    if highlight then
                        highlight:Destroy()
                    end
                end
            end
        end
    end
})

-- Add color picker UI for Chams
LeftGroupBox:AddLabel('Cham Color'):AddColorPicker('ColorPicker', {
    Default = Color3.fromRGB(255, 255, 255), -- White color (default)
    Title = 'Cham Color', -- Title of the color picker
    Transparency = 0, -- Disables transparency changing for this color picker

    Callback = function(Value)
        highlightColor = Value  -- Update the highlight color when the user picks a color
        -- Update the cham color for existing players
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local highlight = player.Character:FindFirstChild("ChamHighlight")
                if highlight then
                    highlight.FillColor = highlightColor  -- Apply the new color to the existing highlight
                end
            end
        end
    end
})

-- Handle player join to ensure chams are applied
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        -- Wait until the character's root part is available before applying chams
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        if _G.chams and player ~= LocalPlayer then
            CreateCham(player)  -- Apply cham if enabled and not the local player
        end
    end)
end)

Players.PlayerRemoving:Connect(function(player)
    -- Remove cham when player leaves
    if player.Character then
        local highlight = player.Character:FindFirstChild("ChamHighlight")
        if highlight then
            highlight:Destroy()
        end
    end
end)

-- Periodically update chams for players when enabled using RunService.Heartbeat
RunService.Heartbeat:Connect(function()
    if _G.chams then
        -- Loop through all players and ensure chams are applied
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                -- Create cham if it doesn't exist for the player
                local character = player.Character
                if not character:FindFirstChild("ChamHighlight") then
                    CreateCham(player)
                end
            end
        end
    else
        -- Disable the cham effect if _G.chams is false
        for _, player in pairs(Players:GetPlayers()) do
            local character = player.Character
            if character then
                local highlight = character:FindFirstChild("ChamHighlight")
                if highlight then
                    highlight:Destroy()
                end
            end
        end
    end
end)

-- Ensure chams are applied to players who have respawned
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        -- In case a player respawns
        if _G.chams and player ~= LocalPlayer then
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            CreateCham(player)
        end
    end)
end)

-- Execute the toggle when the script is first run
if _G.chams then
    -- Enable the cham effect for players (not including local player)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            CreateCham(player)
        end
    end
else
    -- Disable the cham effect for all players
    for _, player in pairs(Players:GetPlayers()) do
        local character = player.Character
        if character then
            local highlight = character:FindFirstChild("ChamHighlight")
            if highlight then
                highlight:Destroy()
            end
        end
    end
end

local RightGroupBox = Tabs.Misc:AddRightGroupbox('Character')

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

local antiVoidEnabled = false

RightGroupBox:AddToggle('AntiVoidToggle', {
    Text = 'anti-void',
    Default = false,
    Tooltip = 'Prevents falling into the void by teleporting up',

    Callback = function(Value)
        antiVoidEnabled = Value
        print('[cb] AntiVoidToggle changed to:', Value)
    end
})

local function antiVoidCheck()
    if antiVoidEnabled and rootPart and rootPart.Position.Y <= -150 then
        rootPart.CFrame = rootPart.CFrame + Vector3.new(0, 500, 0)
    end
end

RunService.Heartbeat:Connect(antiVoidCheck)

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    rootPart = character:WaitForChild("HumanoidRootPart")
end)

    local CollectionService = game:GetService("CollectionService")

    -- Table to cache seats
    local cachedSeats = {}

    -- Function to process a seat
    local function processSeat(seat, state)
    if seat:IsA("Seat") and not cachedSeats[seat] then
        cachedSeats[seat] = seat -- Cache the seat
    end
    if cachedSeats[seat] then
        seat.Disabled = state -- Update the state
        if state then
            CollectionService:AddTag(seat, "Seat")
        else
            CollectionService:RemoveTag(seat, "Seat")
        end
    end
    end

    -- Initialize cached seats
    local function initializeSeats()
    for _, object in ipairs(workspace:GetDescendants()) do
        if object:IsA("Seat") then
            cachedSeats[object] = object
        end
    end
    end

    -- Monitor new seats dynamically
    local function monitorNewSeats()
    workspace.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("Seat") then
            processSeat(descendant, CollectionService:HasTag(descendant, "Seat"))
        end
    end)
    end

    -- Integration with the toggle
    RightGroupBox:AddToggle('MyToggle', {
    Text = 'no-seats',
    Default = false, -- Default value
    Tooltip = 'Makes it so you cant sit down on anything', -- Tooltip info

    Callback = function(value)
        print('[cb] MyToggle changed to:', value)
        for seat, _ in pairs(cachedSeats) do
            if seat and seat:IsA("Seat") then
                seat.Disabled = value -- Update seat state
                if value then
                    CollectionService:AddTag(seat, "Seat")
                else
                    CollectionService:RemoveTag(seat, "Seat")
                end
            end
        end
    end
    })

    -- Initialize and start monitoring
    initializeSeats()
    monitorNewSeats()

    RightGroupBox:AddToggle('MyToggle', {
        Text = 'cash-dropper',
        Default = false, -- Default value (true / false)
        Tooltip = 'Automatically drops cash', -- Information shown when you hover over the toggle
    
        Callback = function(Value)
            -- Locals
local Player = game:GetService("Players").LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local MainScreenGui = Player.PlayerGui.MainScreenGui
local MoneyText = MainScreenGui.MoneyText

-- Global variable to track Money Drop state
getgenv().moneyDropEnabled = getgenv().moneyDropEnabled or false -- Initialize as false if not already set

-- Function to safely extract the money amount from the text
local function getMoneyAmount()
    local moneyText = MoneyText.Text:match("%$(%d[%,%d]*)")  -- Extract the money amount after "$"
    if moneyText then
        local cleanedMoneyString = moneyText:gsub(",", "")  -- Remove commas
        local amount = tonumber(cleanedMoneyString)  -- Convert to number
        return amount or 0  -- If the conversion fails, return 0
    else
        return 0
    end
end

-- Function to drop money
local function dropMoney(amountToDrop)
    if amountToDrop > 0 then
        ReplicatedStorage.MainEvent:FireServer("DropMoney", tostring(amountToDrop))  -- Convert amount to string
    end
end

-- Function to enable or disable the money drop
local function toggleMoneyDrop()
    getgenv().moneyDropEnabled = not getgenv().moneyDropEnabled -- Toggle the state
end

-- Main loop (this will stop doing anything when moneyDropEnabled is false)
RunService.Heartbeat:Connect(function()
    if getgenv().moneyDropEnabled then
        local money = getMoneyAmount()  -- Get the current money amount
        dropMoney(money < 15000 and money or 15000)  -- Drop all money if under 15,000, or drop 15,000
    end
end)

-- Call this function to toggle the money drop
toggleMoneyDrop()  -- Toggle the money drop (enable or disable)
        end
    })

_G.autoStomp = _G.autoStomp or false

local stompRemote = game.ReplicatedStorage.MainEvent
local player = game.Players.LocalPlayer
local runService = game:GetService("RunService")

local isLooping = false

local function startStomping()
    local stompConnection
    stompConnection = runService.Heartbeat:Connect(function()
        if isLooping then
            if player.Character and player.Character:FindFirstChild("Humanoid") then
                stompRemote:FireServer("Stomp")
            end
        end
    end)
    _G.stompConnection = stompConnection
end

local function stopStomping()
    if _G.stompConnection then
        _G.stompConnection:Disconnect()
        _G.stompConnection = nil
    end
end

RightGroupBox:AddToggle('AutoStompToggle', {
    Text = 'auto-stomp',
    Default = false,
    Tooltip = 'Automatically stomps when near downed players',

    Callback = function(Value)
        _G.autoStomp = Value
        isLooping = Value
        if Value then
            startStomping()
        else
            stopStomping()
        end
    end
})

local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local debris = game:GetService("Debris")  -- For cleanup

local antiStompEnabled = false  -- Default value for anti-stomp toggle

local HumanoidStateType = Enum.HumanoidStateType
local KOD = "K.O"
local GRABBING_CONSTRAINT = "GRABBING_CONSTRAINT"

RightGroupBox:AddToggle('MyToggle', {
    Text = 'anti-stomp',
    Default = false, -- Default value (true / false)
    Tooltip = 'prevents stomps',
    
    Callback = function(Value)
        antiStompEnabled = Value  -- Update the toggle value
    end
})

-- RunService heartbeat to monitor character state
RunService.Heartbeat:Connect(function()
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")

    -- Check if the character and humanoid exist
    if character and humanoid then
        -- Use a variable for BodyEffects and K.O state to avoid repeated calls
        local bodyEffects = character:FindFirstChild("BodyEffects")
        local KOd = bodyEffects and bodyEffects[KOD] and bodyEffects[KOD].Value
        local Grabbed = character:FindFirstChild(GRABBING_CONSTRAINT) ~= nil

        -- Only execute if Anti Stomp is enabled
        if antiStompEnabled and (KOd or Grabbed) then
            -- Prevent interaction by disabling humanoid interactions
            humanoid.PlatformStand = true  -- Disable normal character movements
            humanoid.WalkSpeed = 0  -- Prevent walking
            humanoid.JumpHeight = 0  -- Prevent jumping
            humanoid.Health = 0  -- Force kill the character immediately

            -- Disable collision to make it untouchable by other players
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false  -- Disable collision with other players
                end
            end

            -- Disable unnecessary humanoid states
            humanoid:SetStateEnabled(HumanoidStateType.Physics, false)
            humanoid:SetStateEnabled(HumanoidStateType.Seated, false)
            humanoid:SetStateEnabled(HumanoidStateType.Climbing, false)
            humanoid:SetStateEnabled(HumanoidStateType.Freefall, false)
            humanoid:SetStateEnabled(HumanoidStateType.Ragdoll, false)

            -- Prevent health changes from other players
            humanoid.MaxHealth = humanoid.Health

            -- Clean up BodyEffects to remove any effects causing interaction
            if bodyEffects then
                bodyEffects:ClearAllChildren()
            end

            -- Prevent stomping or any other interaction from players
            local collisionParts = character:GetChildren()
            for _, part in pairs(collisionParts) do
                if part:IsA("BasePart") then
                    part.CanCollide = false  -- Fully prevent collision interactions
                end
            end

            -- Immediately reset the character to remove any potential interaction
            player:LoadCharacter()  -- Reload the character to reset the player
        end
    end
end)

RightGroupBox:AddToggle('ForceResetToggle', {
    Text = 'force-reset',
    Default = false,  -- Default value (true for enabled, false for disabled)
    Tooltip = 'Toggle to force reset your character',

    Callback = function(Value)
        local Players = game:GetService("Players")
        local StarterGui = game:GetService("StarterGui")
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")

        if humanoid then
            if Value then
                -- Force reset when toggle is on
                humanoid.Health = 0
            else
                -- No reset when toggle is off (can also clear the health or just keep it as is)
            end
        end
    end
})

RightGroupBox:AddToggle('MyToggle', {
    Text = 'inf-zoom',
    Default = false, -- Default value (true / false) 
    Tooltip = 'Lets you zoom out infinitely', -- Information shown when you hover over the toggle

    Callback = function(Value)

        -- Initialize zoom if it's not set
        if _G.zoomInitialized == nil then
            _G.zoomInitialized = false
        end

        if Value and not _G.zoomInitialized then
            -- Enable Infinite Zoom
            player.CameraMaxZoomDistance = math.huge

            _G.zoomInitialized = true
        elseif not Value and _G.zoomInitialized then
            -- Disable Infinite Zoom
            player.CameraMaxZoomDistance = 30

            _G.zoomInitialized = false
        end
    end
})

getgenv().Time = 0.1 -- Delay for applying effects
    getgenv().HeadlessOverlay = "rbxassetid://15093053680" -- Provided headless ID

    -- Services
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local StarterGui = game:GetService("StarterGui")

    -- Cache player
    local LocalPlayer = Players.LocalPlayer

    -- Optimized Notify Function
    local function notifyUser(title, text)
    StarterGui:SetCore("SendNotification", {Title = title; Text = text; Duration = 5})
    end

    -- Apply Headless Effect (Hides the head)
    local function applyHeadless()
    local character = LocalPlayer.Character
    if not character then return end

    local head = character:FindFirstChild("Head")
    if head and not head:GetAttribute("HeadlessApplied") then
        head.Transparency = 1
        head:SetAttribute("HeadlessApplied", true) -- Prevent redundant operations
        local faceDecal = head:FindFirstChild("face")
        if faceDecal then
            faceDecal.Transparency = 1
        end
    end
    end

    -- Revert to Normal (Restores the head and face visibility)
    local function revertToNormal()
    local character = LocalPlayer.Character
    if not character then return end

    local head = character:FindFirstChild("Head")
    if head and head:GetAttribute("HeadlessApplied") then
        head.Transparency = 0
        head:SetAttribute("HeadlessApplied", nil) -- Clear applied attribute
        local faceDecal = head:FindFirstChild("face")
        if faceDecal then
            faceDecal.Transparency = 0
        end
    end
    end

    -- Continuously ensure the headless effect is applied when active
    RunService.RenderStepped:Connect(function()
    local character = LocalPlayer.Character
    if character then
        if _G.headlessEffectActive then
            applyHeadless()
        else
            revertToNormal()
        end
    end
    end)

    -- Integration with Toggle
    RightGroupBox:AddToggle('HeadlessToggle', {
    Text = 'headless',
    Default = false, -- Default value (true / false)
    Tooltip = 'Toggle the headless effect on your character',

    Callback = function(Value)
        if Value then
            -- Enable headless effect
            _G.headlessEffectActive = true
            applyHeadless()
        else
            -- Revert to normal
            _G.headlessEffectActive = false
            revertToNormal()
        end
    end
    })

LeftGroupBox = Tabs.Teleport:AddLeftGroupbox('Teleports')

MyButton = LeftGroupBox:AddButton({
    Text = 'Bank',
    Func = function()
        teleportCFrame = CFrame.new(-442, 39, -284)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Inside Bank',
    Func = function()
        teleportCFrame = CFrame.new(-443, 23, -284)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})


MyButton = LeftGroupBox:AddButton({
    Text = 'Vault',
    Func = function()
        teleportCFrame = CFrame.new(-658, -30, -285)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Mid Appartment Building',
    Func = function()
        teleportCFrame = CFrame.new(-323, 80, -299)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Revolver',
    Func = function()
        teleportCFrame = CFrame.new(-634, 21, -132)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'LMG',
    Func = function()
        teleportCFrame = CFrame.new(-626, 23, -295)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Swimming Pool',
    Func = function()
        teleportCFrame = CFrame.new(-847, 21, -279)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Broken Fire Station',
    Func = function()
        teleportCFrame = CFrame.new(-1182, 28, -521)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'DownHill',
    Func = function()
        teleportCFrame = CFrame.new(-559, 8, -735)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Military Base',
    Func = function()
        teleportCFrame = CFrame.new(-40, 65, -926)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Uphill',
    Func = function()
        teleportCFrame = CFrame.new(481, 48, -602)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Breaking Bad',
    Func = function()
        teleportCFrame = CFrame.new(598, 28, -214)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Church',
    Func = function()
        teleportCFrame = CFrame.new(205, 21, -124)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Police Station',
    Func = function()
        teleportCFrame = CFrame.new(-264, 21, -93)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'School',
    Func = function()
        teleportCFrame = CFrame.new(-594, 21, 173)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

local LeftGroupBox = Tabs.Misc:AddLeftGroupbox('Movement')

local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local KeyCode = Enum.KeyCode -- Store Enum for repeated use

    -- Utility Functions
    local Utility = {
    hasCharacter = function(player)
        local character = player and player.Character
        return character and character:FindFirstChild("HumanoidRootPart", true) and character:FindFirstChild("Humanoid", true)
    end,
    newConnection = function(event, callback)
        return event:Connect(callback)
    end
    }

    -- Configuration Flags
    local Flags = {
    cframeSpeedEnabled = false, -- Initially off
    cframeSpeedToggleAllowed = false, -- Toggle must be enabled via UI
    cframeSpeedKeybind = KeyCode.V, -- Default toggle key set to V
    cframeSpeedAmount = 150 -- Default speed
    }

    -- CFrame Speed Functionality
    local function updateCframeSpeed(deltaTime)
    if Flags.cframeSpeedEnabled and Utility.hasCharacter(LocalPlayer) then
        local character = LocalPlayer.Character
        local hrp = character:FindFirstChild("HumanoidRootPart", true)
        local humanoid = character:FindFirstChild("Humanoid", true)
        local moveDirection = humanoid and humanoid.MoveDirection

        if hrp and moveDirection then
            local movement = moveDirection.Unit * Flags.cframeSpeedAmount * deltaTime
            if movement.Magnitude > 0 then
                hrp.CFrame = hrp.CFrame + movement
            end
        end
    end
    end

    -- UI Integration
    LeftGroupBox:AddToggle('CframeSpeedToggle', {
    Text = 'Toggle CFrame Speed',
    Default = false,
    Tooltip = 'Toggles speed using CFrames',
    Callback = function(value)
        Flags.cframeSpeedToggleAllowed = value
        if not value then
            Flags.cframeSpeedEnabled = false
        end
    end
    })

    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('CframeSpeedKeybind', {
    Default = 'V',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'CFrame Speed',
    NoUI = false,
    Callback = function(value)
        if value and typeof(value) == "EnumItem" then
            Flags.cframeSpeedKeybind = KeyCode[value.Name]
        end
    end,
    ChangedCallback = function(newValue)
        if newValue and typeof(newValue) == "EnumItem" then
            Flags.cframeSpeedKeybind = KeyCode[newValue.Name]
        end
    end
    })

    LeftGroupBox:AddSlider('CframeSpeedSlider', {
    Text = 'Speed Amount',
    Default = 150,
    Min = 16,
    Max = 1000,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        Flags.cframeSpeedAmount = value
    end
    })

    -- RenderStepped Connection for CFrame Speed
    if _G.cframeSpeedRenderSteppedConnection then
    _G.cframeSpeedRenderSteppedConnection:Disconnect()
    end
    _G.cframeSpeedRenderSteppedConnection = RunService.Heartbeat:Connect(updateCframeSpeed)

    -- Input Listener for Keybind
    if _G.cframeSpeedToggleListener then
    _G.cframeSpeedToggleListener:Disconnect()
    end
    _G.cframeSpeedToggleListener = Utility.newConnection(UserInputService.InputBegan, function(input, gameProcessed)
    if gameProcessed then return end

    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Flags.cframeSpeedKeybind then
        if Flags.cframeSpeedToggleAllowed then
            Flags.cframeSpeedEnabled = not Flags.cframeSpeedEnabled
        end
    end
    end)

LeftGroupBox:AddLabel('')

local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local KeyCode = Enum.KeyCode -- Store Enum for repeated use

    -- Utility Functions
    local Utility = {
    hasCharacter = function(player)
        local character = player and player.Character
        return character and character:FindFirstChild("HumanoidRootPart", true) and character:FindFirstChild("Humanoid", true)
    end,
    newConnection = function(event, callback)
        return event:Connect(callback)
    end
    }

    -- Configuration Flags
    local Flags = {
    rageCFrameFlyEnabled = false, -- Initially off
    rageCFrameFlyToggleAllowed = false, -- Toggle must be enabled via UI
    rageCFrameFlyKeybind = KeyCode.B, -- Default toggle key set to B
    rageCFrameFlyAmount = 250 -- Default fly speed
    }

    -- Fly Functionality
    local function updateFly(deltaTime)
    if Flags.rageCFrameFlyEnabled and Utility.hasCharacter(LocalPlayer) then
        local character = LocalPlayer.Character
        local hrp = character:FindFirstChild("HumanoidRootPart", true)
        local moveDirection = character:FindFirstChild("Humanoid", true).MoveDirection

        -- Vertical movement based on key input
        local verticalSpeed = (UserInputService:IsKeyDown(KeyCode.Space) and 1 or UserInputService:IsKeyDown(KeyCode.LeftShift) and -1 or 0)
        local verticalMovement = Vector3.new(0, verticalSpeed, 0)

        -- Combine horizontal and vertical movement for consistent speed
        local movement = (moveDirection + verticalMovement).Unit * Flags.rageCFrameFlyAmount * deltaTime

        -- Update position using CFrame
        if movement.Magnitude > 0 then
            hrp.CFrame = hrp.CFrame + movement
        end

        -- Adjust velocity to prevent conflicts
        hrp.Velocity = Vector3.zero
    end
    end

    -- UI Integration
    LeftGroupBox:AddToggle('CframeFlightToggle', {
    Text = 'Toggle Cframe Flight',
    Default = false,
    Tooltip = 'Toggles flight using CFrames',
    Callback = function(value)
        Flags.rageCFrameFlyToggleAllowed = value
        if not value then
            Flags.rageCFrameFlyEnabled = false
        end
    end
    })

    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('FlightKeybind', {
    Default = 'B',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Flight',
    NoUI = false,

    Callback = function(value)
        if value and typeof(value) == "EnumItem" then
            Flags.rageCFrameFlyKeybind = KeyCode[value.Name]
        end
    end,

    ChangedCallback = function(newValue)
        if newValue and typeof(newValue) == "EnumItem" then
            Flags.rageCFrameFlyKeybind = KeyCode[newValue.Name]
        end
    end
    })

    LeftGroupBox:AddSlider('CframeFlightSpeed', {
    Text = 'Flight Speed',
    Default = 250,
    Min = 16,
    Max = 2000,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        Flags.rageCFrameFlyAmount = value
    end
    })

    -- RenderStepped Connection for Flight
    if _G.flyRenderSteppedConnection then
    _G.flyRenderSteppedConnection:Disconnect()
    end
    _G.flyRenderSteppedConnection = RunService.Heartbeat:Connect(updateFly)

    -- Input Listener for Keybind
    if _G.flyToggleListener then
    _G.flyToggleListener:Disconnect()
    end
    _G.flyToggleListener = Utility.newConnection(UserInputService.InputBegan, function(input, gameProcessed)
    if gameProcessed then return end

    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Flags.rageCFrameFlyKeybind then
        if Flags.rageCFrameFlyToggleAllowed then
            Flags.rageCFrameFlyEnabled = not Flags.rageCFrameFlyEnabled
        end
    end
    end)

LeftGroupBox:AddLabel('')

LeftGroupBox:AddToggle('MyToggle', {
        Text = 'Fake Macro',
        Default = false,
        Tooltip = 'Activates fake macro!',
    
        Callback = function(Value)
            print('[cb] MyToggle changed to:', Value)
            
            -- Toggle the speed feature based on the toggle value
            if Value then
                _G.ScriptEnabled = true
                resetCharacter()
            else
                _G.ScriptEnabled = false
            end
        end
    })
    
    player = game.Players.LocalPlayer
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    emoteId = "rbxassetid://3189777795"
    
    -- Speed variables
    maxSpeed = 300
    baseSpeed = 16
    speedIncrement = 1.75
    emoteDuration = 1.6 -- Default emote duration
    
    -- Variables to track speed and state
    currentSpeed = baseSpeed
    isSpeedEnabled = false
    emoteTrack = nil
    isSpeedReady = false
    
    -- Cache the hotkey (Q) for reuse
    Keybind = Enum.KeyCode.Q
    
    -- Efficient use of services and enum values
    UserInputService = game:GetService("UserInputService")
    RunService = game:GetService("RunService")
    
    -- Function to initialize the character and humanoid
    function initializeCharacter(newCharacter)
        character = newCharacter or player.Character
        humanoid = character:WaitForChild("Humanoid")
        currentSpeed = baseSpeed
        humanoid.WalkSpeed = baseSpeed
        isSpeedEnabled = false
        isSpeedReady = false
    end
    
    -- Function to forcefully reset the character
    function resetCharacter()
        if humanoid then
            humanoid.Health = 0
        end
    end
    
    -- Function to play the emote
    function playEmote()
        animation = Instance.new("Animation")
        animation.AnimationId = emoteId
        emoteTrack = humanoid:LoadAnimation(animation)
        emoteTrack:Play()
    
        -- Stop the emote after the duration from the slider
        task.wait(emoteDuration)
        if emoteTrack and emoteTrack.IsPlaying then
            emoteTrack:Stop()
        end
    
        -- After the emote ends, set isSpeedReady to true to start gradual speed increase
        isSpeedReady = true
    end
    
    -- Function to manage speed (gradual increase)
    function updateSpeed()
        if _G.ScriptEnabled and isSpeedEnabled then
            if isSpeedReady then
                currentSpeed = math.min(currentSpeed + speedIncrement, maxSpeed)
                humanoid.WalkSpeed = currentSpeed
            else
                humanoid.WalkSpeed = baseSpeed
            end
        elseif not isSpeedEnabled or not _G.ScriptEnabled then
            humanoid.WalkSpeed = baseSpeed
            currentSpeed = baseSpeed
        end
    end
    
    -- Toggle the speed feature
    function toggleSpeedFeature()
        if not _G.ScriptEnabled then return end
        isSpeedEnabled = not isSpeedEnabled
        if isSpeedEnabled then
            currentSpeed = baseSpeed
            humanoid.WalkSpeed = baseSpeed
            isSpeedReady = false
            playEmote()
        else
            currentSpeed = baseSpeed
            humanoid.WalkSpeed = baseSpeed
            isSpeedReady = false
        end
    end
    
    -- Reinitialize the script on character respawn
    player.CharacterAdded:Connect(initializeCharacter)
    
    -- Bind the hotkey (Q) to toggle the feature
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if _G.ScriptEnabled and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Keybind then
            toggleSpeedFeature()
        end
    end)
    
    -- Do not reset character immediately on script load, only when toggle is true
    if _G.ScriptEnabled then
        resetCharacter()
    end
    
    -- Bind RunService Heartbeat to continuously update speed
    RunService.Heartbeat:Connect(updateSpeed)
    
    -- Initialize the script for the current character
    initializeCharacter(character)
    
    -- Add KeyPicker for dynamic hotkey
    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', { 
        Default = 'Q', -- Initial keybind (can be changed)
        SyncToggleState = false,
        Mode = 'Toggle', -- Modes: Always, Toggle, Hold
        Text = 'Speed Toggle Keybind',
    
        Callback = function(Value)
            print('[cb] Keybind clicked!', Value)
        end,
    
        ChangedCallback = function(New)
            print('[cb] Keybind changed!', New)
            -- Update the hotkey to the new key selected
            Keybind = New
        end
    })
    
    -- Add Slider for emote duration
    LeftGroupBox:AddSlider('EmoteDuration', {
        Text = 'Emote Duration',
        Default = 1.6,
        Min = 0,
        Max = 2.5,
        Rounding = 2,
        Compact = false,
    
        Callback = function(Value)
            print('[cb] Emote Duration changed! New value:', Value)
            emoteDuration = Value
        end
    })
    
    -- Add Slider for max speed
    LeftGroupBox:AddSlider('MaxSpeed', {
        Text = 'Speed',
        Default = 300,
        Min = 16,
        Max = 1000, -- Adjust max limit as needed
        Rounding = 0,
        Compact = false,
    
        Callback = function(Value)
            print('[cb] Max Speed changed! New value:', Value)
            maxSpeed = Value
        end
    })
    
    -- Add Slider for speed increment
    LeftGroupBox:AddSlider('SpeedIncrement', {
        Text = 'Speed Increment',
        Default = 1.75,
        Min = 0.1,
        Max = 10,
        Rounding = 2,
        Compact = false,
    
        Callback = function(Value)
            print('[cb] Speed Increment changed! New value:', Value)
            speedIncrement = Value
        end
    })

LeftGroupBox:AddLabel('')

local function toggleNoJumpCooldown(enabled)
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")

    -- Helper function to update the humanoid's jump settings
    local function updateJumpSettings(humanoid, state)
        humanoid.UseJumpPower = not state -- Disable cooldown when `enabled` is true
        print("Jump cooldown " .. (state and "disabled!" or "enabled!"))
    end

    -- Apply the setting to the current humanoid
    updateJumpSettings(humanoid, enabled)

    -- Monitor for respawn and reapply the no jump cooldown setting if enabled
    player.CharacterAdded:Connect(function(newCharacter)
        local newHumanoid = newCharacter:WaitForChild("Humanoid")
        updateJumpSettings(newHumanoid, enabled)
    end)
    end

    -- Add a toggle to the UI
    LeftGroupBox:AddToggle('NoJumpCooldownToggle', {
    Text = 'no-jump cooldown',
    Default = false, -- Default value (true / false)
    Tooltip = 'Toggles the jump cooldown on or off', -- Information shown when you hover over the toggle

    Callback = function(value)
        -- Update the global state and toggle the feature
        _G.noJumpCooldownEnabled = value
        toggleNoJumpCooldown(value)
        print('[cb] NoJumpCooldownToggle changed to:', value)
    end
    })

    -- Optimized example: Instead of repeatedly using :FindFirstChild, store the result in a variable
    local part = workspace:FindFirstChild("MyPart")
    if part then
    -- Perform actions with the part
    print("Found part:", part.Name)
    end

local gh = false -- Set to true to enable Anti-Slow, false to disable it.
    local debris = game:GetService("Debris") -- Access Debris service for cleanup
    local player = game.Players.LocalPlayer
    local toggleValue = false -- Store the current state of the toggle

    -- Replace the print statements with your NotifyLibrary.Notify call once it's defined
    local function notify(title, description)
    print(title .. ": " .. description)
    end

    -- Anti-slow logic that gets activated based on the toggle value
    local function antiSlowToggle(value)
    if value == true then
        gh = true

        -- Use RunService once and bind the logic only when enabled
        game:GetService('RunService'):BindToRenderStep("Anti-Slow", 0 , function()
            if player.Character then
                local bodyEffects = player.Character:WaitForChild("BodyEffects", 10)
                local movement = bodyEffects and bodyEffects:WaitForChild("Movement", 10)
                
                if movement then
                    -- Only check for the existence of these once and remove them if found
                    local noWalkSpeed = movement:FindFirstChild("NoWalkSpeed")
                    if noWalkSpeed then
                        noWalkSpeed:Destroy()
                    end
                    
                    local reduceWalk = movement:FindFirstChild("ReduceWalk")
                    if reduceWalk then
                        reduceWalk:Destroy()
                    end
                    
                    local noJumping = movement:FindFirstChild("NoJumping")
                    if noJumping then
                        noJumping:Destroy()
                    end
                end

                -- Use a more efficient way to check and modify the reload value
                if bodyEffects and bodyEffects.Reload and bodyEffects.Reload.Value == true then
                    bodyEffects.Reload.Value = false
                end
            end
        end)
    else
        gh = false

        -- Cleanup properly and unbind RunService
        game:GetService('RunService'):UnbindFromRenderStep("Anti-Slow")
    end
    end

    -- Integrate with the UI toggle, add it only once
    if not _G.AntiSlowToggle then
    LeftGroupBox:AddToggle('MyToggle', {
        Text = 'anti-slow',
        Default = false, -- Default value (true / false)
        Tooltip = 'Removes any kind of slowness', -- Information shown when you hover over the toggle

        Callback = function(Value)
            toggleValue = Value
            antiSlowToggle(Value)  -- Call the anti-slow function based on the toggle's value
        end
    })

    _G.AntiSlowToggle = true
    end

    -- Listen for character respawn and reapply the anti-slow system
    player.CharacterAdded:Connect(function()
    antiSlowToggle(toggleValue)  -- Reapply the toggle value after respawn
    end)

    -- Initial setup on first load
    if player.Character then
    antiSlowToggle(toggleValue)  -- Apply the anti-slow based on the current toggle state
    end

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local MainEvent = ReplicatedStorage:WaitForChild("MainEvent")

-- Variables for tool and ammo
local tool
local ammoValue

-- Pool for animation connection
local animationConnection

-- Function to handle Auto Reload
local function handleAutoReload()
    tool = LocalPlayer.Character:FindFirstChildWhichIsA("Tool")

    if tool and tool:FindFirstChild("Ammo") then
        ammoValue = tool.Ammo.Value
        if ammoValue <= 0 then
            MainEvent:FireServer("Reload", tool)
        end
    end
end

-- Function to handle Silent Reload setup (with animation stop)
local function setupSilentReload(Value)
    -- Check if the player has a character
    if LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:WaitForChild("Humanoid")
        local targetAnimationId = "rbxassetid://2877910736"

        -- Stop any existing connections to Heartbeat
        if animationConnection then
            animationConnection:Disconnect()
        end

        -- Function to check and stop animation only when enabled
        if Value then
            local function checkAnimations()
                local playingAnimations = humanoid:GetPlayingAnimationTracks()
                for _, animationTrack in pairs(playingAnimations) do
                    local animation = animationTrack.Animation
                    if animation.AnimationId == targetAnimationId then
                        animationTrack:Stop()
                    end
                end
            end

            -- Reconnect the heartbeat listener if Silent Reload is enabled
            animationConnection = RunService.Heartbeat:Connect(checkAnimations)
        end
    end
end

-- Optimized AutoReload Toggle
RightGroupBox:AddToggle('AutoReloadToggle', {
    Text = 'Auto Reload',
    Default = false, -- Default value (true / false)
    Tooltip = 'Reloads Automatically when 0 ammo', -- Information shown when you hover over the toggle

    Callback = function(Value)
        _G.AutoReload = Value -- Set AutoReload based on the toggle state
    end
})

-- Silent Reload Toggle with animation cleanup
RightGroupBox:AddToggle('SilentReloadToggle', {
    Text = 'Silent Reload',
    Default = false, -- Default value (true / false)
    Tooltip = 'Reloads Silently', -- Information shown when you hover over the toggle

    Callback = function(Value)
        -- Apply the Silent Reload setup each time the toggle is changed
        setupSilentReload(Value)

        -- If the player dies and respawns, reset Silent Reload setup
        LocalPlayer.CharacterAdded:Connect(function()
            setupSilentReload(Value)
        end)
    end
})

-- Ensure auto reload is functioning right from the start if enabled
RunService.Heartbeat:Connect(function()
    if _G.AutoReload then
        handleAutoReload()
    end
end)

-- Cleanup function for removing unused objects or connections
local function cleanup()
    if animationConnection then
        animationConnection:Disconnect()
    end
end

-- Use Debris service for cleanup (if necessary in your context)
game:GetService("Debris"):AddItem(animationConnection, 5)

-- Ensure auto reload is functioning right from the start if enabled
RunService.Heartbeat:Connect(function()
    if _G.AutoReload then
        handleAutoReload()
    end
end)

RightGroupBox = Tabs.Misc:AddRightGroupbox('Player Detections')

if _G.staffCheckerEnabled == nil then
    _G.staffCheckerEnabled = false -- Default value
end

RightGroupBox:AddToggle('MyToggle', {
    Text = 'anti-staff',
    Default = _G.staffCheckerEnabled,
    Tooltip = 'Enables real-time staff detection',

    Callback = function(Value)
        _G.staffCheckerEnabled = Value
        if Value then
            enableStaffChecker()
        else
            disableStaffChecker()
        end
        print('[Staff Checker] Toggled:', Value)
    end
})

-- Anti-Staff logic
function isStaff(player)
    -- Check if the player has the "Staff" role or badge
    -- Modify this depending on how the game defines staff players
    local isStaff = player.HasStaffRole or false  -- Example, adjust this condition based on your game's staff identification system
    return isStaff
end

function enableStaffChecker()
    -- Example function where you can disable actions for staff players
    game.Players.PlayerAdded:Connect(function(player)
        if isStaff(player) then
            print("Anti-Staff Detected: " .. player.Name)
            if game.Players.LocalPlayer == player then
                -- Kicks the player running the script if they are a staff member
                game.Players.LocalPlayer:Kick("Anti-Staff Detected: You are a staff member and cannot interact.")
            end
        else
            -- Regular logic here for non-staff players
            print(player.Name .. " is not a staff member.")
        end
    end)
end

function disableStaffChecker()
    -- Disable the staff checking functionality if toggled off
    print("Staff Checker is disabled.")
end


if _G.staffCheckerEnabled == nil then
    _G.staffCheckerEnabled = false -- Default value
end

RightGroupBox:AddToggle('MyToggle', {
    Text = 'anti-star',
    Default = _G.staffCheckerEnabled,
    Tooltip = 'Enables real-time staff detection and prevents stars from being checked',

    Callback = function(Value)
        _G.staffCheckerEnabled = Value
        if Value then
            enableStaffChecker()
        else
            disableStaffChecker()
        end
        print('[Star Checker] Toggled:', Value)
    end
})

-- Anti-Star logic
function isStar(player)
    -- Check if the player has the "Star" role or badge
    -- Modify this depending on how the game handles stars; this is an example
    local isStar = player.HasStar or false  -- This could be changed depending on how the game flags Star players
    return isStar
end

function enableStaffChecker()
    -- Example function where you can disable actions for Star players
    game.Players.PlayerAdded:Connect(function(player)
        if isStar(player) then
            print("Anti-Star Detected: " .. player.Name)
            if game.Players.LocalPlayer == player then
                -- Kicks the player running the script if they are a star
                game.Players.LocalPlayer:Kick("Anti-Star Detected: You are a Star and cannot interact.")
            end
        else
            -- Regular staff checker logic here for non-Star players
            print(player.Name .. " is not a star.")
        end
    end)
end

function disableStaffChecker()
    -- Disable the star checking functionality if toggled off
    print("Star Checker is disabled.")
end

if _G.verifyCheckerEnabled == nil then
    _G.verifyCheckerEnabled = false -- Default value
end

RightGroupBox:AddToggle('MyToggle', {
    Text = 'anti-verified',
    Default = _G.verifyCheckerEnabled,
    Tooltip = 'Enables real-time verified player detection',

    Callback = function(Value)
        _G.verifyCheckerEnabled = Value
        if Value then
            enableVerifyChecker()
        else
            disableVerifyChecker()
        end
        print('[Verified Checker] Toggled:', Value)
    end
})

-- Anti-Verified logic
function isVerified(player)
    -- Check if the player has the "Verified" role or badge
    -- Modify this depending on how the game defines verified players
    local isVerified = player.HasVerifiedBadge or false  -- Example, adjust this condition based on your game's system for verified players
    return isVerified
end

function enableVerifyChecker()
    -- Example function where you can disable actions for verified players
    game.Players.PlayerAdded:Connect(function(player)
        if isVerified(player) then
            print("Anti-Verified Detected: " .. player.Name)
            if game.Players.LocalPlayer == player then
                -- Kicks the player running the script if they are verified
                game.Players.LocalPlayer:Kick("Anti-Verified Detected: You are a verified player and cannot interact.")
            end
        else
            -- Regular logic for non-verified players
            print(player.Name .. " is not verified.")
        end
    end)
end

function disableVerifyChecker()
    -- Disable the verified player checking functionality if toggled off
    print("Verified Checker is disabled.")
end

RightGroupBox:AddLabel('kicks u when they are in ur server.')

RightGroupBox = Tabs.Misc:AddRightGroupbox('Animations')

    Players = game:GetService("Players")  -- Store the Players service in a variable
    player = Players.LocalPlayer  -- Store the LocalPlayer in a variable

    -- Base URL for the animation assets
    animationBaseUrl = "http://www.roblox.com/asset/?id="

    -- Table of animations with optimized base URL usage
    animations = {
    R15 = {
        idle = animationBaseUrl .. "2510196951",
        walk = animationBaseUrl .. "2510202577",
        run = animationBaseUrl .. "2510198475",
        jump = animationBaseUrl .. "2510197830",
        climb = animationBaseUrl .. "2510192778",
        fall = animationBaseUrl .. "2510195892",
    },
    Loser = {
        idle = animationBaseUrl .. "782841498",
        walk = animationBaseUrl .. "616168032",
        run = animationBaseUrl .. "616163682",
        jump = animationBaseUrl .. "1083218792",
        climb = animationBaseUrl .. "1083439238",
        fall = animationBaseUrl .. "707829716",
    },
    Astronaut = {
        idle = animationBaseUrl .. "891621366",
        jump = animationBaseUrl .. "891627522",
        fall = animationBaseUrl .. "891617961",
        walk = animationBaseUrl .. "891667138",
        run = animationBaseUrl .. "891636393",
        climb = animationBaseUrl .. "891609353",
    },
    Bubbly = {
        idle = animationBaseUrl .. "910004836",
        jump = animationBaseUrl .. "910016857",
        fall = animationBaseUrl .. "910001910",
        walk = animationBaseUrl .. "910034870",
        run = animationBaseUrl .. "910025107",
        climb = animationBaseUrl .. "940996062",
    },
    Cartoony = {
        idle = animationBaseUrl .. "742637544",
        jump = animationBaseUrl .. "742637942",
        fall = animationBaseUrl .. "742637151",
        walk = animationBaseUrl .. "742640026",
        run = animationBaseUrl .. "742638842",
        climb = animationBaseUrl .. "742636889",
    },
    Confident = {
        idle = animationBaseUrl .. "1069977950",
        jump = animationBaseUrl .. "1069984524",
        fall = animationBaseUrl .. "1069973677",
        walk = animationBaseUrl .. "1070017263",
        run = animationBaseUrl .. "1070001516",
        climb = animationBaseUrl .. "1069946257",
    },
    Cowboy = {
        idle = animationBaseUrl .. "1014390418",
        jump = animationBaseUrl .. "1014394726",
        fall = animationBaseUrl .. "1014384571",
        walk = animationBaseUrl .. "1014421541",
        run = animationBaseUrl .. "1014401683",
        climb = animationBaseUrl .. "1014380606",
    },
    Elder = {
        idle = animationBaseUrl .. "845397899",
        jump = animationBaseUrl .. "845398858",
        fall = animationBaseUrl .. "845396048",
        walk = animationBaseUrl .. "845403856",
        run = animationBaseUrl .. "845386501",
        climb = animationBaseUrl .. "845392038",
    },
    Knight = {
        idle = animationBaseUrl .. "657595757",
        jump = animationBaseUrl .. "658409194",
        fall = animationBaseUrl .. "657600338",
        walk = animationBaseUrl .. "657552124",
        run = animationBaseUrl .. "657564596",
        climb = animationBaseUrl .. "658360781",
    },
    Levitation = {
        idle = animationBaseUrl .. "616006778",
        jump = animationBaseUrl .. "616008936",
        fall = animationBaseUrl .. "616005863",
        walk = animationBaseUrl .. "616013216",
        run = animationBaseUrl .. "616010382",
        climb = animationBaseUrl .. "616003713",
    },
    Mage = {
        idle = animationBaseUrl .. "707742142",
        jump = animationBaseUrl .. "707853694",
        fall = animationBaseUrl .. "707829716",
        walk = animationBaseUrl .. "707897309",
        run = animationBaseUrl .. "707861613",
        climb = animationBaseUrl .. "707826056",
    },
    Ninja = {
        idle = animationBaseUrl .. "656117400",
        jump = animationBaseUrl .. "656117878",
        fall = animationBaseUrl .. "656115606",
        walk = animationBaseUrl .. "656121766",
        run = animationBaseUrl .. "656118852",
        climb = animationBaseUrl .. "656114359",
    },
    Patrol = {
        idle = animationBaseUrl .. "1149612882",
        jump = animationBaseUrl .. "1148811837",
        fall = animationBaseUrl .. "1148863382",
        walk = animationBaseUrl .. "1151231493",
        run = animationBaseUrl .. "1150967949",
        climb = animationBaseUrl .. "1148811837",
    },
    Pirate = {
        idle = animationBaseUrl .. "750781874",
        jump = animationBaseUrl .. "750782230",
        fall = animationBaseUrl .. "750780242",
        walk = animationBaseUrl .. "750785693",
        run = animationBaseUrl .. "750783738",
        climb = animationBaseUrl .. "750779899",
    },
    Popstar = {
        idle = animationBaseUrl .. "1212900985",
        jump = animationBaseUrl .. "1212954642",
        fall = animationBaseUrl .. "1212900995",
        walk = animationBaseUrl .. "1212980338",
        run = animationBaseUrl .. "1212980348",
        climb = animationBaseUrl .. "1213044953",
    },
    Princess = {
        idle = animationBaseUrl .. "941003647",
        jump = animationBaseUrl .. "941008832",
        fall = animationBaseUrl .. "941000007",
        walk = animationBaseUrl .. "941028902",
        run = animationBaseUrl .. "941015281",
        climb = animationBaseUrl .. "940996062",
    },
    Robot = {
        idle = animationBaseUrl .. "616088211",
        jump = animationBaseUrl .. "616090535",
        fall = animationBaseUrl .. "616087089",
        walk = animationBaseUrl .. "616095330",
        run = animationBaseUrl .. "616091570",
        climb = animationBaseUrl .. "616086039",
    },
    Sneaky = {
        idle = animationBaseUrl .. "1132473842",
        jump = animationBaseUrl .. "1132489853",
        fall = animationBaseUrl .. "1132469004",
        walk = animationBaseUrl .. "1132510133",
        run = animationBaseUrl .. "1132494274",
        climb = animationBaseUrl .. "1132461372",
    },
    Stylish = {
        idle = animationBaseUrl .. "616136790",
        jump = animationBaseUrl .. "616139451",
        fall = animationBaseUrl .. "616134815",
        walk = animationBaseUrl .. "616146177",
        run = animationBaseUrl .. "616140816",
        climb = animationBaseUrl .. "616133594",
    },
    Superhero = {
        idle = animationBaseUrl .. "616111295",
        jump = animationBaseUrl .. "616115533",
        fall = animationBaseUrl .. "616108001",
        walk = animationBaseUrl .. "616122287",
        run = animationBaseUrl .. "616117076",
        climb = animationBaseUrl .. "616104706",
    },
    Toy = {
        idle = animationBaseUrl .. "782841498",
        jump = animationBaseUrl .. "782847020",
        fall = animationBaseUrl .. "782846423",
        walk = animationBaseUrl .. "782843345",
        run = animationBaseUrl .. "782842708",
        climb = animationBaseUrl .. "782843869",
    },
    Vampire = {
        idle = animationBaseUrl .. "1083445855",
        jump = animationBaseUrl .. "1083455352",
        fall = animationBaseUrl .. "1083443587",
        walk = animationBaseUrl .. "1083473930",
        run = animationBaseUrl .. "1083462077",
        climb = animationBaseUrl .. "1083439238",
    },
    Werewolf = {
        idle = animationBaseUrl .. "1083195517",
        jump = animationBaseUrl .. "1083218792",
        fall = animationBaseUrl .. "1083189019",
        walk = animationBaseUrl .. "1083178339",
        run = animationBaseUrl .. "1083216690",
        climb = animationBaseUrl .. "1083182000",
    },
    Zombie = {
        idle = animationBaseUrl .. "616158929",
        jump = animationBaseUrl .. "616161997",
        fall = animationBaseUrl .. "616157476",
        walk = animationBaseUrl .. "616168032",
        run = animationBaseUrl .. "616163682",
        climb = animationBaseUrl .. "616156119",
    },
    RealisticZombie = {
        idle = animationBaseUrl .. "3489171152",
        jump = animationBaseUrl .. "616161997",
        fall = animationBaseUrl .. "616157476",
        walk = animationBaseUrl .. "3489174223",
        run = animationBaseUrl .. "3489173414",
        climb = animationBaseUrl .. "616156119", 
    },
    }

    -- Function to apply animations based on the selected preset
    local function applyAnimations(animate, preset)
    -- Ensure the animation IDs are applied correctly
    if animate and preset then
        if animate.idle and animate.idle:FindFirstChild("Animation1") then
            animate.idle.Animation1.AnimationId = preset.idle
        else
            warn("Idle animation or Animation1 not found")
        end
        
        if animate.walk and animate.walk:FindFirstChild("WalkAnim") then
            animate.walk.WalkAnim.AnimationId = preset.walk
        else
            warn("Walk animation or WalkAnim not found")
        end

        if animate.run and animate.run:FindFirstChild("RunAnim") then
            animate.run.RunAnim.AnimationId = preset.run
        else
            warn("Run animation or RunAnim not found")
        end

        if animate.jump and animate.jump:FindFirstChild("JumpAnim") then
            animate.jump.JumpAnim.AnimationId = preset.jump
        else
            warn("Jump animation or JumpAnim not found")
        end

        if animate.climb and animate.climb:FindFirstChild("ClimbAnim") then
            animate.climb.ClimbAnim.AnimationId = preset.climb
        else
            warn("Climb animation or ClimbAnim not found")
        end

        if animate.fall and animate.fall:FindFirstChild("FallAnim") then
            animate.fall.FallAnim.AnimationId = preset.fall
        else
            warn("Fall animation or FallAnim not found")
        end
    end
    end

    -- Function to apply the selected animation preset to the player's character
    local function applySelectedAnimations(character)
    -- Ensure the character has the Animate object
    local animate = character:FindFirstChild("Animate")
    if animate then
        local selectedPreset = animations[currentAnimationPreset]  -- Use the preset based on the dropdown
        applyAnimations(animate, selectedPreset)
    end
    end

    -- Set up the dropdown to choose which animation preset to apply
    RightGroupBox:AddDropdown('AnimationSelector', {
    Values = {'R15', 'Loser', 'Astronaut', 'Bubbly', 'Cartoony', 'Confident', 'Cowboy', 'Elder', 'Knight', 'Levitation', 'Mage', 'Ninja', 'Patrol', 'Pirate', 'Popstar', 'Princess', 'Robot', 'Sneaky', 'Stylish', 'Superhero', 'Toy', 'Vampire', 'Werewolf', 'Zombie', 'RealisticZombie'}, -- Add new presets here if needed
    Default = 1, -- Default option (R15)
    Multi = false, -- Allow single selection only

    Text = 'Select Animation',
    Tooltip = 'Choose the animation you want to apply',

    Callback = function(Value)
        currentAnimationPreset = Value  -- Update the preset based on the dropdown selection
    end
    })

    -- Connect to Heartbeat and apply the animation every frame
    game:GetService("RunService").Heartbeat:Connect(function()
    if player.Character then
        applySelectedAnimations(player.Character)  -- Apply the selected animation
    end
    end)

local LeftGroupBox = Tabs.Misc:AddLeftGroupbox('Desync')

local Toggle = LeftGroupBox:AddToggle('Desync', {
    Text = 'extreme desync',
    Default = false,
    Tooltip = 'Players see ur character teleporting and dissapearing',

    Callback = function(Value)
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "extreme desync",
            Text = Value and "on" or "off",
            Duration = 3,
        })
    end
})

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

RunService.Heartbeat:Connect(function()
    if Toggle.Value then
        local Character = LocalPlayer.Character
        if Character and Character:FindFirstChild("HumanoidRootPart") then
            local RootPart = Character.HumanoidRootPart
            local v = RootPart.Velocity
            RootPart.CFrame = RootPart.CFrame * CFrame.Angles(0, math.rad(0.01), 0)

            local randomVelocity = Vector3.new(
                math.random(-3000, 3000),
                math.random(-3000, 3000),
                math.random(-3000, 3000)
            )

            RootPart.Velocity = randomVelocity
            RunService.RenderStepped:Wait()
            RootPart.Velocity = v
        end
    end
end)

local RightGroupBox = Tabs.Visuals:AddRightGroupbox('Game GFX Settings')

    MyButton = RightGroupBox:AddButton({
    Text = 'Low GFX',
    Func = function()
        if not _G.Ignore then
            _G.Ignore = {} -- Add Instances to this table to ignore them (e.g. _G.Ignore = {workspace.Map, workspace.Map2})
        end
        if not _G.WaitPerAmount then
            _G.WaitPerAmount = 500 -- Set Higher or Lower depending on your computer's performance
        end
        if _G.SendNotifications == nil then
            _G.SendNotifications = true -- Set to false if you don't want notifications
        end
        if _G.ConsoleLogs == nil then
            _G.ConsoleLogs = false -- Set to true if you want console logs (mainly for debugging)
        end
        
        
        
        if not game:IsLoaded() then
            repeat
                task.wait()
            until game:IsLoaded()
        end
        if not _G.Settings then
            _G.Settings = {
                Players = {
                    ["Ignore Me"] = true,
                    ["Ignore Others"] = true,
                    ["Ignore Tools"] = true
                },
                Meshes = {
                    NoMesh = false,
                    NoTexture = false,
                    Destroy = false
                },
                Images = {
                    Invisible = true,
                    Destroy = false
                },
                Explosions = {
                    Smaller = true,
                    Invisible = false, -- Not recommended for PVP games
                    Destroy = false -- Not recommended for PVP games
                },
                Particles = {
                    Invisible = true,
                    Destroy = false
                },
                TextLabels = {
                    LowerQuality = false,
                    Invisible = false,
                    Destroy = false
                },
                MeshParts = {
                    LowerQuality = true,
                    Invisible = false,
                    NoTexture = false,
                    NoMesh = false,
                    Destroy = false
                },
                Other = {
                    ["FPS Cap"] = true, -- Set this true to uncap FPS
                    ["No Camera Effects"] = true,
                    ["No Clothes"] = true,
                    ["Low Water Graphics"] = true,
                    ["No Shadows"] = true,
                    ["Low Rendering"] = false,
                    ["Low Quality Parts"] = true,
                    ["Low Quality Models"] = true,
                    ["Reset Materials"] = true,
                    ["Lower Quality MeshParts"] = true
                }
            }
        end
        local Players, Lighting, StarterGui, MaterialService = game:GetService("Players"), game:GetService("Lighting"), game:GetService("StarterGui"), game:GetService("MaterialService")
        local ME, CanBeEnabled = Players.LocalPlayer, {"ParticleEmitter", "Trail", "Smoke", "Fire", "Sparkles"}
        local function PartOfCharacter(Instance)
            for i, v in pairs(Players:GetPlayers()) do
                if v ~= ME and v.Character and Instance:IsDescendantOf(v.Character) then
                    return true
                end
            end
            return false
        end
        local function DescendantOfIgnore(Instance)
            for i, v in pairs(_G.Ignore) do
                if Instance:IsDescendantOf(v) then
                    return true
                end
            end
            return false
        end
        local function CheckIfBad(Instance)
            if not Instance:IsDescendantOf(Players) and (_G.Settings.Players["Ignore Others"] and not PartOfCharacter(Instance) or not _G.Settings.Players["Ignore Others"]) and (_G.Settings.Players["Ignore Me"] and ME.Character and not Instance:IsDescendantOf(ME.Character) or not _G.Settings.Players["Ignore Me"]) and (_G.Settings.Players["Ignore Tools"] and not Instance:IsA("BackpackItem") and not Instance:FindFirstAncestorWhichIsA("BackpackItem") or not _G.Settings.Players["Ignore Tools"])--[[not PartOfCharacter(Instance)]] and (_G.Ignore and not table.find(_G.Ignore, Instance) and not DescendantOfIgnore(Instance) or (not _G.Ignore or type(_G.Ignore) ~= "table" or #_G.Ignore <= 0)) then
                if Instance:IsA("DataModelMesh") then
                    if _G.Settings.Meshes.NoMesh and Instance:IsA("SpecialMesh") then
                        Instance.MeshId = ""
                    end
                    if _G.Settings.Meshes.NoTexture and Instance:IsA("SpecialMesh") then
                        Instance.TextureId = ""
                    end
                    if _G.Settings.Meshes.Destroy or _G.Settings["No Meshes"] then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("FaceInstance") then
                    if _G.Settings.Images.Invisible then
                        Instance.Transparency = 1
                        Instance.Shiny = 1
                    end
                    if _G.Settings.Images.LowDetail then
                        Instance.Shiny = 1
                    end
                    if _G.Settings.Images.Destroy then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("ShirtGraphic") then
                    if _G.Settings.Images.Invisible then
                        Instance.Graphic = ""
                    end
                    if _G.Settings.Images.Destroy then
                        Instance:Destroy()
                    end
                elseif table.find(CanBeEnabled, Instance.ClassName) then
                    if _G.Settings["Invisible Particles"] or _G.Settings["No Particles"] or (_G.Settings.Other and _G.Settings.Other["Invisible Particles"]) or (_G.Settings.Particles and _G.Settings.Particles.Invisible) then
                        Instance.Enabled = false
                    end
                    if (_G.Settings.Other and _G.Settings.Other["No Particles"]) or (_G.Settings.Particles and _G.Settings.Particles.Destroy) then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("PostEffect") and (_G.Settings["No Camera Effects"] or (_G.Settings.Other and _G.Settings.Other["No Camera Effects"])) then
                    Instance.Enabled = false
                elseif Instance:IsA("Explosion") then
                    if _G.Settings["Smaller Explosions"] or (_G.Settings.Other and _G.Settings.Other["Smaller Explosions"]) or (_G.Settings.Explosions and _G.Settings.Explosions.Smaller) then
                        Instance.BlastPressure = 1
                        Instance.BlastRadius = 1
                    end
                    if _G.Settings["Invisible Explosions"] or (_G.Settings.Other and _G.Settings.Other["Invisible Explosions"]) or (_G.Settings.Explosions and _G.Settings.Explosions.Invisible) then
                        Instance.BlastPressure = 1
                        Instance.BlastRadius = 1
                        Instance.Visible = false
                    end
                    if _G.Settings["No Explosions"] or (_G.Settings.Other and _G.Settings.Other["No Explosions"]) or (_G.Settings.Explosions and _G.Settings.Explosions.Destroy) then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("Clothing") or Instance:IsA("SurfaceAppearance") or Instance:IsA("BaseWrap") then
                    if _G.Settings["No Clothes"] or (_G.Settings.Other and _G.Settings.Other["No Clothes"]) then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("BasePart") and not Instance:IsA("MeshPart") then
                    if _G.Settings["Low Quality Parts"] or (_G.Settings.Other and _G.Settings.Other["Low Quality Parts"]) then
                        Instance.Material = Enum.Material.Plastic
                        Instance.Reflectance = 0
                    end
                elseif Instance:IsA("TextLabel") and Instance:IsDescendantOf(workspace) then
                    if _G.Settings["Lower Quality TextLabels"] or (_G.Settings.Other and _G.Settings.Other["Lower Quality TextLabels"]) or (_G.Settings.TextLabels and _G.Settings.TextLabels.LowerQuality) then
                        Instance.Font = Enum.Font.SourceSans
                        Instance.TextScaled = false
                        Instance.RichText = false
                        Instance.TextSize = 14
                    end
                    if _G.Settings["Invisible TextLabels"] or (_G.Settings.Other and _G.Settings.Other["Invisible TextLabels"]) or (_G.Settings.TextLabels and _G.Settings.TextLabels.Invisible) then
                        Instance.Visible = false
                    end
                    if _G.Settings["No TextLabels"] or (_G.Settings.Other and _G.Settings.Other["No TextLabels"]) or (_G.Settings.TextLabels and _G.Settings.TextLabels.Destroy) then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("Model") then
                    if _G.Settings["Low Quality Models"] or (_G.Settings.Other and _G.Settings.Other["Low Quality Models"]) then
                        Instance.LevelOfDetail = 1
                    end
                elseif Instance:IsA("MeshPart") then
                    if _G.Settings["Low Quality MeshParts"] or (_G.Settings.Other and _G.Settings.Other["Low Quality MeshParts"]) or (_G.Settings.MeshParts and _G.Settings.MeshParts.LowerQuality) then
                        Instance.RenderFidelity = 2
                        Instance.Reflectance = 0
                        Instance.Material = Enum.Material.Plastic
                    end
                    if _G.Settings["Invisible MeshParts"] or (_G.Settings.Other and _G.Settings.Other["Invisible MeshParts"]) or (_G.Settings.MeshParts and _G.Settings.MeshParts.Invisible) then
                        Instance.Transparency = 1
                        Instance.RenderFidelity = 2
                        Instance.Reflectance = 0
                        Instance.Material = Enum.Material.Plastic
                    end
                    if _G.Settings.MeshParts and _G.Settings.MeshParts.NoTexture then
                        Instance.TextureID = ""
                    end
                    if _G.Settings.MeshParts and _G.Settings.MeshParts.NoMesh then
                        Instance.MeshId = ""
                    end
                    if _G.Settings["No MeshParts"] or (_G.Settings.Other and _G.Settings.Other["No MeshParts"]) or (_G.Settings.MeshParts and _G.Settings.MeshParts.Destroy) then
                        Instance:Destroy()
                    end
                end
            end
        end
        coroutine.wrap(pcall)(function()
            if (_G.Settings["Low Water Graphics"] or (_G.Settings.Other and _G.Settings.Other["Low Water Graphics"])) then
                if not workspace:FindFirstChildOfClass("Terrain") then
                    repeat
                        task.wait()
                    until workspace:FindFirstChildOfClass("Terrain")
                end
                workspace:FindFirstChildOfClass("Terrain").WaterWaveSize = 0
                workspace:FindFirstChildOfClass("Terrain").WaterWaveSpeed = 0
                workspace:FindFirstChildOfClass("Terrain").WaterReflectance = 0
                workspace:FindFirstChildOfClass("Terrain").WaterTransparency = 0
                if sethiddenproperty then
                    sethiddenproperty(workspace:FindFirstChildOfClass("Terrain"), "Decoration", false)
                else
                    warn("Your exploit does not support sethiddenproperty, please use a different exploit.")
                end
                if _G.ConsoleLogs then
                    warn("Low Water Graphics Enabled")
                end
            end
        end)
        coroutine.wrap(function()
            pcall(function()
                if _G.Settings["No Shadows"] or (_G.Settings.Other and _G.Settings.Other["No Shadows"]) then
                    Lighting.GlobalShadows = false
                    Lighting.FogEnd = 9e9
                    Lighting.ShadowSoftness = 0
                    if sethiddenproperty then
                        sethiddenproperty(Lighting, "Technology", 2)
                    end
                    if _G.ConsoleLogs then
                        warn("No Shadows Enabled")
                    end
                end
            end)
        end)()
        
        -- Low Rendering
        coroutine.wrap(function()
            pcall(function()
                if _G.Settings["Low Rendering"] or (_G.Settings.Other and _G.Settings.Other["Low Rendering"]) then
                    settings().Rendering.QualityLevel = 1
                    settings().Rendering.MeshPartDetailLevel = Enum.MeshPartDetailLevel.Level04
                    if _G.ConsoleLogs then
                        warn("Low Rendering Enabled")
                    end
                end
            end)
        end)()
        
        -- Reset Materials
        coroutine.wrap(function()
            pcall(function()
                if _G.Settings["Reset Materials"] or (_G.Settings.Other and _G.Settings.Other["Reset Materials"]) then
                    for i, v in pairs(MaterialService:GetChildren()) do
                        v:Destroy()
                    end
                    if _G.ConsoleLogs then
                        warn("Reset Materials Enabled")
                    end
                end
            end)
        end)()
        coroutine.wrap(function()
            pcall(function()
                if _G.Settings["FPS Cap"] or (_G.Settings.Other and _G.Settings.Other["FPS Cap"]) then
                    local fpsCapSetting = _G.Settings["FPS Cap"] or (_G.Settings.Other and _G.Settings.Other["FPS Cap"])
        
                    if type(fpsCapSetting) == "string" or type(fpsCapSetting) == "number" then
                        if setfpscap then
                            setfpscap(tonumber(fpsCapSetting))
                            if _G.ConsoleLogs then
                                warn("FPS Capped to " .. tostring(fpsCapSetting))
                            end
                        end
                    elseif fpsCapSetting == true then
                        if setfpscap then
                            setfpscap(1e6)
                            if _G.ConsoleLogs then
                                warn("FPS Uncapped")
                            end
                        end
                    end
                else
                    warn("FPS Cap Failed")
                end
            end)
        end)()
        game.DescendantAdded:Connect(function(value)
            wait(_G.LoadedWait or 1)
            CheckIfBad(value)
        end)
        
        local Descendants = game:GetDescendants()
        local StartNumber = _G.WaitPerAmount or 500
        local WaitNumber = _G.WaitPerAmount or 500
        if _G.ConsoleLogs then
            warn("Checking " .. #Descendants .. " Instances...")
        end
        for i, v in pairs(Descendants) do
            CheckIfBad(v)
            if i == WaitNumber then
                task.wait()
                if _G.ConsoleLogs then
                    print("Loaded " .. i .. "/" .. #Descendants)
                end
                WaitNumber = WaitNumber + StartNumber
            end
        end
        
        StarterGui:SetCore("SendNotification", {
            Title = "Fps Booster Loaded",
            Text = "Vilant Exploit V2",
            Duration = 5,
        })
        
        warn("FPS Booster Loaded!")
        --game.DescendantAdded:Connect(CheckIfBad)
        --[[game.DescendantAdded:Connect(function(value)
            CheckIfBad(value)
        end)]]
    end,
    DoubleClick = true,
    Tooltip = 'Makes your Gfx low CANT BE REVERTED'
    })

    local lighting = game:GetService("Lighting")
    local StarterGui = game:GetService("StarterGui")
    local debris = game:GetService("Debris")

    -- Store common values in variables to minimize repetitive calls
    local fogEnd = lighting.FogEnd
    local fogStart = lighting.FogStart

    -- Create the toggle button (integrated from your provided example)
    RightGroupBox:AddToggle('MyToggle', {
    Text = 'no-fog',
    Default = false, -- Default value (true / false)
    Tooltip = 'This removes any kind of Fog from the game', -- Information shown when you hover over the toggle

    Callback = function(Value)
        if Value then
            -- Check if the fog removal has been executed before
            if not _G.FogRemovalExecuted then
                -- Store original fog settings
                _G.OriginalFogSettings = {
                    FogEnd = fogEnd,
                    FogStart = fogStart,
                }

                lighting.FogEnd = 100000  -- Set this to a high value to push fog far away
                lighting.FogStart = 0     -- Set this to 0 to ensure fog doesn't start close

                local atmosphere = lighting:FindFirstChildOfClass("Atmosphere")
                if atmosphere then
                    atmosphere:Destroy()
                end

                _G.FogRemovalExecuted = true
            end
        else
            if _G.FogRemovalExecuted then
                lighting.FogEnd = _G.OriginalFogSettings.FogEnd
                lighting.FogStart = _G.OriginalFogSettings.FogStart

                _G.FogRemovalExecuted = false
            end
        end

        print('[cb] MyToggle changed to:', Value)
    end
    })

    RightGroupBox:AddToggle('MyToggle', {
        Text = 'full-bright',
        Default = false, -- Default value (true / false)
        Tooltip = 'Removes shadows and increases brightness', -- Information shown when you hover over the toggle
    
        Callback = function(Value)
            if not _G.FullBrightExecuted then
                _G.FullBrightEnabled = false
    
                local Lighting = game:GetService("Lighting")
                
                -- Store default settings in a table
                _G.NormalLightingSettings = {
                    Brightness = Lighting.Brightness,
                    ClockTime = Lighting.ClockTime,
                    GlobalShadows = Lighting.GlobalShadows,
                    Ambient = Lighting.Ambient
                }
    
                -- Full Bright settings
                local FullBrightSettings = {
                    Brightness = 1,
                    ClockTime = 12,
                    GlobalShadows = false,
                    Ambient = Color3.fromRGB(178, 178, 178)
                }
    
                -- Set lighting properties
                local function setLightingProperties(properties)
                    for property, value in pairs(properties) do
                        Lighting[property] = value
                    end
                end
    
                -- Initial setup
                setLightingProperties(FullBrightSettings)
    
                -- Create a single function to handle property changes
                local function createPropertyChangeListener(property, defaultValue, newValue)
                    Lighting:GetPropertyChangedSignal(property):Connect(function()
                        if Lighting[property] ~= defaultValue and Lighting[property] ~= _G.NormalLightingSettings[property] then
                            _G.NormalLightingSettings[property] = Lighting[property]
                            if not _G.FullBrightEnabled then
                                repeat wait() until _G.FullBrightEnabled
                            end
                            Lighting[property] = newValue
                        end
                    end)
                end
    
                -- Set up property listeners
                for property, newValue in pairs(FullBrightSettings) do
                    createPropertyChangeListener(property, newValue, newValue)
                end
    
                -- Periodically toggle FullBright settings
                local LatestValue = true
                spawn(function()
                    while wait() do
                        if _G.FullBrightEnabled ~= LatestValue then
                            if not _G.FullBrightEnabled then
                                setLightingProperties(_G.NormalLightingSettings)
                            else
                                setLightingProperties(FullBrightSettings)
                            end
                            LatestValue = not LatestValue
                        end
                    end
                end)
            end
    
            -- Toggle full bright state
            _G.FullBrightExecuted = true
            _G.FullBrightEnabled = Value -- directly using Value here to toggle the state
        end
    })

RightGroupBox:AddLabel('')

local lighting = game:GetService("Lighting")
local StarterGui = game:GetService("StarterGui")
local runService = game:GetService("RunService")
local debris = game:GetService("Debris")

if not _G.OriginalLightingSettings then
    _G.OriginalLightingSettings = {
        Ambient = lighting.Ambient,
        OutdoorAmbient = lighting.OutdoorAmbient,
        Brightness = lighting.Brightness,
        ColorShift_Bottom = lighting.ColorShift_Bottom,
        ColorShift_Top = lighting.ColorShift_Top,
        FogColor = lighting.FogColor,
        FogStart = lighting.FogStart,
        FogEnd = lighting.FogEnd,
        TimeOfDay = lighting.TimeOfDay,
        Skybox = lighting:FindFirstChildOfClass("Sky"), -- Ensure no errors if skybox doesn't exist
        ClockTime = lighting.ClockTime
    }
end

local selectedAmbientColor = _G.OriginalLightingSettings.Ambient
local selectedOutdoorAmbientColor = _G.OriginalLightingSettings.OutdoorAmbient
local selectedColorShiftBottom = _G.OriginalLightingSettings.ColorShift_Bottom
local selectedColorShiftTop = _G.OriginalLightingSettings.ColorShift_Top
local selectedFogColor = _G.OriginalLightingSettings.FogColor

local skyboxAssetID = "rbxassetid://1294489738"

-- Add the toggle for the royal purple ambience
RightGroupBox:AddToggle('AmbienceToggle', {
    Text = 'Ambient',
    Default = false, -- Default value (true / false)
    Tooltip = 'Toggle to switch between original and custom ambient lighting',

    Callback = function(Value)
        if Value then
            -- Apply the altered custom ambient lighting settings
            lighting.Ambient = selectedAmbientColor
            lighting.OutdoorAmbient = selectedOutdoorAmbientColor
            lighting.Brightness = 2
            lighting.ColorShift_Bottom = selectedColorShiftBottom
            lighting.ColorShift_Top = selectedColorShiftTop
            lighting.FogColor = selectedFogColor
            lighting.FogStart = 0
            lighting.FogEnd = 500
            lighting.TimeOfDay = "18:00:00"

            -- Set a custom skybox for the custom ambience
            local skybox = lighting:FindFirstChildOfClass("Sky")
            if not skybox then
                skybox = Instance.new("Sky")
                skybox.Parent = lighting
            end
            skybox.SkyboxBk = skyboxAssetID
            skybox.SkyboxDn = skyboxAssetID
            skybox.SkyboxFt = skyboxAssetID
            skybox.SkyboxLf = skyboxAssetID
            skybox.SkyboxRt = skyboxAssetID
            skybox.SkyboxUp = skyboxAssetID

            -- Set the flag to indicate that the lighting has been altered
            _G.AmbienceToggled = true

            -- Immediately set the time of day to the current slider value when toggle is enabled
            lighting.ClockTime = _G.ClockTimeOverride or 17 -- Default to the slider value if set
        else
            -- Reset the lighting back to the original settings
            lighting.Ambient = _G.OriginalLightingSettings.Ambient
            lighting.OutdoorAmbient = _G.OriginalLightingSettings.OutdoorAmbient
            lighting.Brightness = _G.OriginalLightingSettings.Brightness
            lighting.ColorShift_Bottom = _G.OriginalLightingSettings.ColorShift_Bottom
            lighting.ColorShift_Top = _G.OriginalLightingSettings.ColorShift_Top
            lighting.FogColor = _G.OriginalLightingSettings.FogColor
            lighting.FogStart = _G.OriginalLightingSettings.FogStart
            lighting.FogEnd = _G.OriginalLightingSettings.FogEnd
            lighting.TimeOfDay = _G.OriginalLightingSettings.TimeOfDay

            local sky = lighting:FindFirstChildOfClass("Sky")
            if sky then
                debris:AddItem(sky, 1) -- Use debris to clean up skybox instance
            end

            if _G.OriginalLightingSettings.Skybox then
                local originalSkybox = _G.OriginalLightingSettings.Skybox:Clone()
                originalSkybox.Parent = lighting
            end

            _G.AmbienceToggled = false
        end
    end
})

RightGroupBox:AddSlider('BrightnessSlider', { 
    Text = 'Brightness',
    Default = 10,  -- Set initial brightness to 2 (adjust if needed)
    Min = 0,
    Max = 20,  -- Max brightness set to 20
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        -- Immediately change the lighting brightness live based on slider value
        lighting.Brightness = Value
    end
})

-- Add the slider to control fog end with max value set to 1000
RightGroupBox:AddSlider('FogEndSlider', { 
    Text = 'Fog End',
    Default = 500,  -- Set initial fog end to 500 (adjust if needed)
    Min = 100,
    Max = 10000,  -- Max fog end set to 100000
    Rounding = 0,
    Compact = false,

    Callback = function(Value)
        lighting.FogEnd = Value
    end
})

RightGroupBox:AddSlider('TimeOfDaySlider', { 
    Text = 'Time of Day',
    Default = 17,  -- Set initial time to 12:00 (adjust if needed)
    Min = 0,
    Max = 24,  -- 24-hour format for time of day
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        -- Lock the time of day client-side by setting it
        if _G.AmbienceToggled then
            lighting.ClockTime = Value
            -- Save the desired value so it stays fixed
            _G.ClockTimeOverride = Value
        end
    end
})

runService.Heartbeat:Connect(function()
    if _G.AmbienceToggled and _G.ClockTimeOverride then
        lighting.ClockTime = _G.ClockTimeOverride
    end
end)

RightGroupBox:AddLabel('Ambient Color Picker'):AddColorPicker('AmbientColorPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default royal purple
    Title = 'Ambient Color',
    Transparency = 0,  -- Optional

    Callback = function(Value)
        selectedAmbientColor = Value
        if _G.AmbienceToggled then
            lighting.Ambient = selectedAmbientColor
        end
    end
})

RightGroupBox:AddLabel('Outdoor Ambient Color Picker'):AddColorPicker('OutdoorAmbientColorPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default color
    Title = 'Select Outdoor Ambient Color',

    Callback = function(Value)
        selectedOutdoorAmbientColor = Value
        if _G.AmbienceToggled then
            lighting.OutdoorAmbient = selectedOutdoorAmbientColor
        end
    end
})

RightGroupBox:AddLabel('Color Shift Bottom Picker'):AddColorPicker('ColorShiftBottomPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default color
    Title = 'Select Color Shift Bottom',

    Callback = function(Value)
        selectedColorShiftBottom = Value
        if _G.AmbienceToggled then
            lighting.ColorShift_Bottom = selectedColorShiftBottom
        end
    end
})

RightGroupBox:AddLabel('Color Shift Top Picker'):AddColorPicker('ColorShiftTopPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default color
    Title = 'Select Color Shift Top',

    Callback = function(Value)
        selectedColorShiftTop = Value
        if _G.AmbienceToggled then
            lighting.ColorShift_Top = selectedColorShiftTop
        end
    end
})

RightGroupBox:AddLabel('Fog Color Picker'):AddColorPicker('FogColorPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default color
    Title = 'Select Fog Color',

    Callback = function(Value)
        selectedFogColor = Value
        if _G.AmbienceToggled then
            lighting.FogColor = selectedFogColor
        end
    end
})

RightGroupBox = Tabs.Visuals:AddRightGroupbox('Damage Settings')

    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local TweenService = game:GetService("TweenService")
    local Camera = game.Workspace.CurrentCamera
    local RaycastParams = RaycastParams.new()
    RaycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    RaycastParams.IgnoreWater = true

    -- Settings
    local font = Enum.Font.SourceSansBold
    local baseSize = 32
    local distance = 500 -- Maximum distance at which damage numbers will be visible
    local animationDuration = 3 -- Time it takes for the number to slowly move upwards
    local fadeDuration = 1 -- Time it takes for the number to fade away after floating
    local maxOffset = 20 -- Maximum random offset for damage numbers

    local isDamageNumbersEnabled = false  -- Toggle state for enabling/disabling damage numbers
    local damageColor = Color3.fromRGB(255, 255, 255)  -- Default red color for damage numbers

    -- Previous health of the nearest player
    local previousHealth = {}

    -- Function to check if a player is behind a wall
    local function isPlayerVisible(player)
        if not player.Character or not player.Character:FindFirstChild("Head") then return false end
        local head = player.Character.Head
        local origin = Camera.CFrame.Position
        local direction = (head.Position - origin).Unit * (head.Position - origin).Magnitude
        RaycastParams.FilterDescendantsInstances = {Players.LocalPlayer.Character}
        local result = workspace:Raycast(origin, direction, RaycastParams)
        return not result or result.Instance:IsDescendantOf(player.Character)
    end

    -- Function to get the player nearest to the cursor with visibility check
    local function getNearestToCursor()
        local mouseLocation = UserInputService:GetMouseLocation()
        local nearestPlayer
        local shortestDistance = math.huge

        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild("Head") and isPlayerVisible(player) then
                local head = player.Character.Head
                local screenPosition, onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local distanceToCursor = (Vector2.new(screenPosition.X, screenPosition.Y) - mouseLocation).Magnitude
                    if distanceToCursor < shortestDistance then
                        shortestDistance = distanceToCursor
                        nearestPlayer = player
                    end
                end
            end
        end
        return nearestPlayer
    end

    -- Function to create damage number display
    local function createDamageDisplay(player, damageAmount)
        if not isDamageNumbersEnabled then return end

        local head = player.Character and player.Character:FindFirstChild("Head")
        if head then
            local damageContainer = head:FindFirstChild("DamageContainer")
            if not damageContainer then
                damageContainer = Instance.new("BillboardGui")
                damageContainer.Name = "DamageContainer"
                damageContainer.Parent = head
                damageContainer.Adornee = head
                damageContainer.Size = UDim2.new(0, 100, 0, 50)
                damageContainer.StudsOffset = Vector3.new(0, 2, 0)
                damageContainer.AlwaysOnTop = true
                damageContainer.MaxDistance = distance
                damageContainer.Enabled = true
            end

            -- Create the new damage number label
            local textLabel = Instance.new("TextLabel")
            textLabel.Parent = damageContainer
            textLabel.Text = tostring(damageAmount)
            textLabel.TextColor3 = damageColor
            textLabel.TextSize = baseSize + (damageAmount / 10) -- Scale size based on damage
            textLabel.Font = font
            textLabel.BackgroundTransparency = 1
            textLabel.Size = UDim2.new(1, 0, 0, baseSize)
            textLabel.TextStrokeTransparency = 0.4
            textLabel.Position = UDim2.new(0.5, -50 + math.random(-maxOffset, maxOffset), 0, math.random(-maxOffset, maxOffset)) -- Random offset

            -- Target position for the damage number to slowly move upwards
            local targetPosition = UDim2.new(0.5, -50, 0, -100) -- Final position for all damage numbers

            -- Create the upward movement tween
            local moveUpTween = TweenService:Create(
                textLabel, 
                TweenInfo.new(animationDuration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), 
                {Position = targetPosition}
            )

            -- Create the fade-out tween
            local fadeOutTween = TweenService:Create(
                textLabel,
                TweenInfo.new(fadeDuration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
                {TextTransparency = 1, TextStrokeTransparency = 1} -- Fade both text and stroke
            )

            -- Play the move-up tween
            moveUpTween:Play()

            -- Once the move-up animation is completed, start fading out
            moveUpTween.Completed:Connect(function()
                fadeOutTween:Play()

                -- Destroy the label after the fade-out is complete
                fadeOutTween.Completed:Connect(function()
                    textLabel:Destroy()
                end)
            end)
        end
    end

    -- Function to check and display damage numbers for the nearest player
    local function checkNearestPlayerDamage()
        local nearestPlayer = getNearestToCursor()

        if nearestPlayer and nearestPlayer.Character and nearestPlayer.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = nearestPlayer.Character:FindFirstChildOfClass("Humanoid")
            local currentHealth = humanoid.Health

            -- Get the previous health of the player, or set it to their current health if not tracked
            local prevHealth = previousHealth[nearestPlayer.UserId] or currentHealth

            -- If the player has lost health, display the damage number
            if currentHealth < prevHealth and isDamageNumbersEnabled then
                createDamageDisplay(nearestPlayer, math.floor(prevHealth - currentHealth))
            end

            -- Update the player's previous health
            previousHealth[nearestPlayer.UserId] = currentHealth
        end
    end

    -- Run every frame to check the nearest player's health
    RunService.RenderStepped:Connect(checkNearestPlayerDamage)

    -- Integrating UI Toggle for enabling/disabling damage numbers and Color Picker
    RightGroupBox:AddToggle('DamageNumbersToggle', {
        Text = 'Damage numbers',
        Default = false, -- Default value (false so it doesn't show on script execution)
        Tooltip = 'Shows damage dealt with numbers',
        Callback = function(Value)
            isDamageNumbersEnabled = Value
        end
    })

    RightGroupBox:AddLabel('numbers color'):AddColorPicker('DamageColorPicker', {
        Default = damageColor, -- Default color for damage numbers
        Title = 'Number Color', -- Title of the color picker
        Transparency = 0, -- Enable transparency control for the color picker
        Callback = function(Value)
            damageColor = Value
        end
    })

    Options.DamageColorPicker:OnChanged(function()
        print('Damage Number Color changed to:', Options.DamageColorPicker.Value)
    end)

RightGroupBox:AddLabel('')

    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Camera = game.Workspace.CurrentCamera
    local RaycastParams = RaycastParams
    RaycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    RaycastParams.IgnoreWater = true
    
    -- Settings
    local soundOptions = {
        Ding = "rbxassetid://8578195318",
        Hitmarker = "rbxassetid://9116483270",
        Fortnite_Headshot = "rbxassetid://2513174484"
    }
    
    local currentHitSoundId = soundOptions.Ding  -- Default sound
    local soundVolume = 1  -- Volume of the hit sound
    local previousHealth = {}  -- Store previous health of players
    local isHitSoundEnabled = false  -- Default state of the hit sound toggle
    
    -- Function to check if a player is visible
    local function isPlayerVisible(player)
        local character = player.Character
        local head = character and character:FindFirstChild("Head")
        if not head then return false end
    
        local origin = Camera.CFrame.Position
        local direction = (head.Position - origin).Unit * (head.Position - origin).Magnitude
        RaycastParams.FilterDescendantsInstances = {Players.LocalPlayer.Character}
        local result = workspace:Raycast(origin, direction, RaycastParams)
        return not result or result.Instance:IsDescendantOf(character)
    end
    
    -- Function to get the nearest player to the cursor with visibility check
    local function getNearestToCursor()
        local mouseLocation = UserInputService:GetMouseLocation()
        local nearestPlayer, shortestDistance = nil, math.huge
    
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= Players.LocalPlayer then
                local character = player.Character
                if character and character:FindFirstChild("Head") and isPlayerVisible(player) then
                    local head = character.Head
                    local screenPosition, onScreen = Camera:WorldToViewportPoint(head.Position)
                    if onScreen then
                        local distanceToCursor = (Vector2.new(screenPosition.X, screenPosition.Y) - mouseLocation).Magnitude
                        if distanceToCursor < shortestDistance then
                            shortestDistance = distanceToCursor
                            nearestPlayer = player
                        end
                    end
                end
            end
        end
    
        return nearestPlayer
    end
    
    -- Function to play the hit sound on the nearest player when they take damage
    local function playHitSound(player)
        if not isHitSoundEnabled then return end  -- Only proceed if the hit sound is enabled
    
        local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local currentHealth = humanoid.Health
            local prevHealth = previousHealth[player.UserId] or currentHealth
    
            -- If the player has lost health, play the hit sound
            if currentHealth < prevHealth then
                local sound = Instance.new("Sound")
                sound.SoundId = currentHitSoundId
                sound.Volume = soundVolume
                sound.Parent = player.Character:FindFirstChild("Head")
                sound:Play()
                sound.Ended:Connect(function()
                    sound:Destroy()
                end)
            end
    
            -- Update the player's previous health
            previousHealth[player.UserId] = currentHealth
        end
    end
    
    -- Run every frame to check the nearest player's health
    local function checkNearestPlayerDamage()
        local nearestPlayer = getNearestToCursor()
        if nearestPlayer then
            playHitSound(nearestPlayer)
        end
    end
    
    RunService.RenderStepped:Connect(checkNearestPlayerDamage)
    
    -- Toggle for enabling/disabling hit sound
    RightGroupBox:AddToggle('HitSoundsToggle', {
        Text = 'Hit Sounds',
        Default = false,  -- Default value (false so it doesn't play the sound initially)
        Tooltip = 'Plays a sound when a player takes damage',
        Callback = function(Value)
            isHitSoundEnabled = Value
        end
    })
    
    -- Dropdown for selecting hit sound, positioned under the toggle
    RightGroupBox:AddDropdown('SoundDropdown', {
        Values = { 'Ding', 'Hitmarker', 'Fortnite_Headshot' },
        Default = 1,
        Multi = false,
        Text = 'Hit Sound',
        Tooltip = 'Choose a sound to play when you hit players',
        Callback = function(Value)
            currentHitSoundId = soundOptions[Value]
        end
    })  

RightGroupBox = Tabs.Misc:AddRightGroupbox('Auto Redeem Codes')

MyButton = RightGroupBox:AddButton({
    Text = 'Redeem All Codes',
    Func = function()
        local codes = {
            "SHRIMP",
            "VIP",
            "2025",
            "DACARNIVAL",
            "RUBY",
            "THANKSGIVING24",
            "HALLOWEEN2024",
            "pumpkins2023",
            "TRADEME!",
            "Beary",
            "ShortCake",
            "DAUP"
        }
        
        -- Table to track successful codes
        local successfulCodes = {}
        
        -- Function to redeem a code
        local function redeemCode(code)
            -- Arguments for the server event
            local args = {
                [1] = "EnterPromoCode",
                [2] = code
            }
        
            -- Fire the server event
            game:GetService("ReplicatedStorage").MainEvent:FireServer(unpack(args))
        
            -- Wait for response or success (adjust the response as needed)
            local successIndicator = false
            game:GetService("ReplicatedStorage").MainEvent.OnClientEvent:Connect(function(response)
                if response == "CodeRedeemed" then  -- Adjust response check as per actual server logic
                    successIndicator = true
                end
            end)
        
            -- Wait for a short time before proceeding to next code
            wait(6)  -- 6 second wait between attempts (you can adjust this)
        
            -- If successfully redeemed, log the code
            if successIndicator then
                table.insert(successfulCodes, code)
            end
        
            print("Attempted to redeem code: " .. code)
        end
        
        -- Attempt to redeem each code
        for _, code in ipairs(codes) do
            redeemCode(code)
        end        
    end,
    DoubleClick = false,
    Tooltip = 'Redeems Active codes in the game'
})

watermarkVisible = true  -- Boolean to track watermark visibility
Library:SetWatermarkVisibility(watermarkVisible)  -- Set initial visibility to true

-- Function to toggle the watermark visibility
function toggleWatermarkVisibility(Value)
    watermarkVisible = Value  -- Update the visibility state
    Library:SetWatermarkVisibility(watermarkVisible)  -- Apply the new visibility
end

-- FPS and Ping display update
FrameTimer = tick()
FrameCounter = 0
FPS = 60

-- Corrected FPS and Ping update inside RenderStepped
WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    if not watermarkVisible then return end  -- Skip updating if watermark is hidden

    FrameCounter += 1

    -- Update FPS every second
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end

    -- Update watermark with FPS and Ping
    local ping = math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    Library:SetWatermark(('Vilant Exploit V2 | %s fps | %s ms'):format(
        math.floor(FPS),
        ping
    ))
end)
