 Library = loadstring(game:HttpGet('https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/refs/heads/main/Library.lua'))()

    Window = Library:CreateWindow({

    Title = 'Vilant Exploit | v1.7',
    Center = true,
    AutoShow = true,
    TabPadding = 9
    })

    Tabs = {
    Main = Window:AddTab('Main'),
    Visuals = Window:AddTab('Visuals'),
    Movement = Window:AddTab('Movement'),
    Misc = Window:AddTab('Misc'),
    Teleport = Window:AddTab('Teleport'),
    }

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Aimbot')

    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Camera = workspace.CurrentCamera
    local Workspace = game:GetService("Workspace")
    
    local LocalPlayer = Players.LocalPlayer
    
    local cursorLocked = false
    local targetHead = nil
    local targetPlayer = nil
    local previewHighlight = nil
    local lockedHighlight = nil
    local predictionLevel = 0 -- Default prediction level, can be changed (higher value = more prediction)
    local currentKeybind = Enum.KeyCode.C
    local previewColor = Color3.fromRGB(0, 0, 255) -- Default preview color
    local lockedHighlightColor = Color3.fromRGB(255, 0, 0) -- Default locked highlight color
    local smoothness = 0 -- Default smoothness value
    local highlightsEnabled = false -- Default value for highlights toggle
    
    local ragelock = false  -- Default value for ragelock
    local orbitActive = false  -- Flag for orbit feature
    local orbitSpeed = 10 -- Orbit speed
    local radius = 8 -- Orbit size
    local rotation = CFrame.Angles(0, 0, 0) -- Rotation angles
    
    if _G.aimlock == nil then
        _G.aimlock = false  -- Default value if not previously set
    end
    
    local function IsPlayerKnockedOrGrabbed(player)
        local character = player.Character
        if character then
            local bodyEffects = character:FindFirstChild("BodyEffects")
            local grabbingConstraint = character:FindFirstChild("GRABBING_CONSTRAINT")
            if bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value or grabbingConstraint then
                return true
            end
        end
        return false
    end
    
    -- Function to calculate the predicted position based on velocity
    local function GetPredictedPosition(player)
        local character = player.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            local head = character:FindFirstChild("Head")
            if humanoid and head then
                local velocity = humanoid.RootPart.AssemblyLinearVelocity
                return head.Position + velocity * predictionLevel
            end
        end
        return nil
    end
    
    local function FindClosestPlayerHead()
        local closestPlayer = nil
        local closestDistance = math.huge
        local mousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
    
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
                local character = player.Character
                local humanoid = character:FindFirstChild("Humanoid")
    
                if humanoid and humanoid.Health > 0 then
                    if IsPlayerKnockedOrGrabbed(player) then continue end  -- Skip locked/knocked/grabbed players
                    local head = character.Head
                    local predictedHeadPosition = GetPredictedPosition(player) or head.Position
                    local screenPoint = Camera:WorldToScreenPoint(predictedHeadPosition)
                    local distance = (mousePosition - Vector2.new(screenPoint.X, screenPoint.Y)).Magnitude
                    local playerDistance = (Camera.CFrame.Position - predictedHeadPosition).Magnitude
    
                    local ray = Ray.new(Camera.CFrame.Position, predictedHeadPosition - Camera.CFrame.Position)
                    local hitPart, hitPosition = Workspace:FindPartOnRay(ray, LocalPlayer.Character)
    
                    -- Lock even through walls for players within 100 studs
                    if playerDistance <= 100 or (not hitPart or hitPart.Parent == character) then
                        if distance < closestDistance then
                            closestDistance = distance
                            closestPlayer = player
                        end
                    end
                end
            end
        end
    
        if closestPlayer then
            return closestPlayer.Character.Head, closestPlayer
        end
        return nil, nil
    end
    
    local function AddPreviewHighlight(player)
        if not highlightsEnabled then return end -- Skip if highlights are disabled
    
        if previewHighlight and previewHighlight.Parent == player.Character then
            previewHighlight.FillColor = previewColor
            return
        end
    
        if previewHighlight then
            previewHighlight:Destroy()
        end
    
        if player and player.Character then
            previewHighlight = Instance.new("Highlight")
            previewHighlight.Parent = player.Character
            previewHighlight.FillTransparency = 0.5
            previewHighlight.FillColor = previewColor
        end
    end
    
    local function AddLockedHighlight(player)
        if not highlightsEnabled then return end -- Skip if highlights are disabled
    
        if lockedHighlight and lockedHighlight.Parent == player.Character then
            lockedHighlight.FillColor = lockedHighlightColor
            return
        end
    
        if lockedHighlight then
            lockedHighlight:Destroy()
        end
    
        -- Create a new locked highlight for the locked player
        if player and player.Character then
            lockedHighlight = Instance.new("Highlight")
            lockedHighlight.Parent = player.Character
            lockedHighlight.FillTransparency = 0.5
            lockedHighlight.FillColor = lockedHighlightColor
        end
    end
    
    -- Lock the cursor to the nearest player's head
    local function LockCursorToHead()
        targetHead, targetPlayer = FindClosestPlayerHead()
        if targetHead then
            AddLockedHighlight(targetPlayer)  -- Add highlight to locked player
            if previewHighlight then previewHighlight:Destroy() end  -- Destroy preview highlight if it exists
            UserInputService.MouseIconEnabled = false
        end
    end
    
    -- Unlock the cursor
    local function UnlockCursor()
        UserInputService.MouseIconEnabled = true
        targetHead = nil
        targetPlayer = nil
        if lockedHighlight then lockedHighlight:Destroy() end
    end
    
    -- Function to activate orbiting around the target player
    local function ActivateOrbit(player)
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            targetPlayer = player
        end
    end
    
    -- Function to deactivate orbiting
    local function DeactivateOrbit()
        targetPlayer = nil
    end
    
    -- Function to handle automatic targeting for RageLock
    local function HandleRageLock()
        -- Ensure RageLock only locks onto the target if it's valid
        if ragelock then
            -- Check if targetPlayer is invalid or knocked
            if targetPlayer and IsPlayerKnockedOrGrabbed(targetPlayer) then
                -- If the locked target is knocked or grabbed, unlock and search for the next target
                cursorLocked = false
                UnlockCursor()
                DeactivateOrbit()
                print("[RageLock] Target is knocked/grabbed, unlocking and searching for next target.")
                targetHead, targetPlayer = FindClosestPlayerHead()
                if targetPlayer then
                    cursorLocked = true
                    LockCursorToHead()
                    AddLockedHighlight(targetPlayer)  -- Add highlight to new target
                end
                return
            end
    
            -- If no valid target is locked, search for a new one
            if not targetPlayer then
                targetHead, targetPlayer = FindClosestPlayerHead()
                if targetPlayer then
                    cursorLocked = true
                    LockCursorToHead()
                    AddLockedHighlight(targetPlayer)  -- Add highlight to new target
                end
            end
        end
    end
    
    -- Orbit update loop (only runs when orbit toggle is true)
    RunService.Stepped:Connect(function(_, dt)
        if orbitActive then
            -- Only update orbit if the toggle is true and the player is locked onto a valid target
            if cursorLocked and targetPlayer then
                -- Only update orbit if the target is locked (Aimlock or RageLock)
                local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if targetHumanoidRootPart then
                    local rot = tick() * orbitSpeed
                    local lpr = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if lpr then
                        -- Orbit calculation (only orbits if locked onto target)
                        lpr.CFrame = CFrame.new(
                            targetHumanoidRootPart.Position + Vector3.new(math.sin(rot) * radius, 0, math.cos(rot) * radius)
                        )
                    end
                end
            end
        end
    
        -- Update loop to continuously follow the locked target for aimlock
        if cursorLocked and _G.aimlock and targetHead then
            -- Handle ragelock to auto lock onto next target if necessary
            if ragelock then
                HandleRageLock()  -- Call the function to handle RageLock auto-targeting
            end
    
            -- Check if the locked player is knocked or grabbed and unlock if necessary
            if IsPlayerKnockedOrGrabbed(targetPlayer) then
                cursorLocked = false
                UnlockCursor()
                DeactivateOrbit()
                print("[Auto Unlock] Target player is knocked or grabbed, unlocking cursor.")
            else
                        -- Proceed with the normal aimlock and orbit
        local predictedHeadPosition = GetPredictedPosition(targetPlayer) or targetHead.Position
        -- Smoothly interpolate the camera's CFrame
        local alpha = 1 - smoothness
        alpha = math.max(alpha, 0.01)  -- Ensure alpha is never 0
        Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, predictedHeadPosition), alpha)
            end
        elseif not cursorLocked and _G.aimlock then
            local closestHead, closestPlayer = FindClosestPlayerHead()
            if closestPlayer ~= targetPlayer then
                AddPreviewHighlight(closestPlayer)
            end
        end
    end)
    
    -- Handle key press (C) for locking the cursor
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == currentKeybind then
            if _G.aimlock then
                cursorLocked = not cursorLocked
                if cursorLocked then
                    LockCursorToHead()
                    if orbitActive then
                        ActivateOrbit(targetPlayer)  -- Activate orbit when locking onto a player and orbiting is enabled
                    end
                else
                    UnlockCursor()
                    DeactivateOrbit()  -- Deactivate orbit when unlocking
                end
            end
        end
    end)
    
    -- UI Controls for setting various values like keybinds and highlight colors
    LeftGroupBox:AddToggle('Aimbot', {
        Text = 'Aimbot',
        Default = false,
        Tooltip = 'Locks your aim onto players heads',
        Callback = function(Value)
            _G.aimlock = Value
            print('[cb] Aimlock changed to:', Value)
            if _G.aimlock then
                cursorLocked = false  -- Ensure cursor is not locked when aimlock is turned on
            end
        end
    })
    
    LeftGroupBox:AddToggle('RageLock', {
        Text = 'RageLock',
        Default = false,
        Tooltip = 'Automatically locks onto the next available player',
        Callback = function(Value)
            ragelock = Value
            print('[cb] RageLock changed to:', Value)
        end
    })
    
    LeftGroupBox:AddToggle('OrbitFeature', {
        Text = 'Orbit Around Target',
        Default = false,
        Tooltip = 'Toggle to start orbiting around the player you lock onto.',
        Callback = function(value)
            orbitActive = value  -- Directly set orbitActive based on toggle state
            if orbitActive and cursorLocked then
                ActivateOrbit(targetPlayer) -- Activate orbit only if locked onto a player
            else
                DeactivateOrbit()  -- Deactivate orbit when the toggle is off
            end
        end
    })
    
    -- Add Toggle for Highlights
    LeftGroupBox:AddToggle('HighlightsToggle', {
        Text = 'Highlights',
        Default = highlightsEnabled,
        Tooltip = 'Toggle to enable or disable highlights',
        Callback = function(Value)
            highlightsEnabled = Value
            print('[cb] Highlights toggled:', Value)
            if not Value then
                -- Destroy highlights if they exist
                if previewHighlight then
                    previewHighlight:Destroy()
                    previewHighlight = nil
                end
                if lockedHighlight then
                    lockedHighlight:Destroy()
                    lockedHighlight = nil
                end
            end
        end
    })
    
    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
        Default = 'C',
        SyncToggleState = false,
        Mode = 'Toggle',
        Text = 'Aimlock',
        ChangedCallback = function(New)
            print('[cb] Keybind changed!', New)
            currentKeybind = New
        end
    })
    
    LeftGroupBox:AddLabel('Preview Color'):AddColorPicker('PreviewColorPicker', {
        Default = previewColor,
        Title = 'Preview Color',
        Transparency = 0,
        Callback = function(Value)
            print('[cb] Preview Color changed!', Value)
            previewColor = Value
            if previewHighlight then
                previewHighlight.FillColor = Value
            end
        end
    })
    
    LeftGroupBox:AddLabel('Locked Highlight Color'):AddColorPicker('LockedColorPicker', {
        Default = lockedHighlightColor,
        Title = 'Locked Player Highlight Color',
        Transparency = 0,
        Callback = function(Value)
            print('[cb] Locked Highlight Color changed!', Value)
            lockedHighlightColor = Value
            if lockedHighlight then
                lockedHighlight.FillColor = Value
            end
        end
    })
    
    -- Add Smoothness Slider
    LeftGroupBox:AddSlider('SmoothnessSlider', {
        Text = 'Smoothness',
        Default = smoothness,
        Min = 0,
        Max = 1,
        Rounding = 2,
        Callback = function(Value)
            print('[cb] Smoothness changed!', Value)
            smoothness = Value
        end
    })
    
    LeftGroupBox:AddSlider('Orbit Speed', {
        Text = 'Orbit Speed',
        Default = orbitSpeed,
        Min = 0,
        Max = 100,
        Rounding = 1,
        Callback = function(Value)
            print('[cb] Orbit Speed changed!', Value)
            orbitSpeed = Value
        end
    })
    
    LeftGroupBox:AddSlider('PredictionSlider', {
        Text = 'Prediction',
        Default = predictionLevel,
        Min = 0,
        Max = 1,
        Rounding = 1,
        Callback = function(Value)
            print('[cb] Prediction changed!', Value)
            predictionLevel = Value
        end
    })

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Triggerbot')

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local lp = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer"):Wait() and Players.LocalPlayer
local mouse = lp:GetMouse()

local EnumKeyCode = Enum.KeyCode -- Store Enum values for reuse
local EnumUserInputType = Enum.UserInputType

local Script = {
    Functions = {},
    Table = {
        Start = {
            TriggerBot = {
                Keybind = "Z", -- Default keybind, can be changed via UI
                Delay = 0.1, -- Default delay, can be changed via UI
                Blacklisted = {} -- Add blacklisted tool names here
            }
        }
    },
    Connections = {}
}

-- Use Object Pooling for frequently accessed properties like BodyEffects
Script.Functions.isDead = function(player)
    local character = player.Character
    if not character then return false end

    local bodyEffects = character:FindFirstChild("BodyEffects")
    if not bodyEffects then return false end

    local ko = bodyEffects:FindFirstChild("K.O") or bodyEffects:FindFirstChild("KO")
    return ko and ko.Value or false
end

Script.Functions.getTarget = function(instance)
    if not instance then return false end

    for _, player in next, Players:GetPlayers() do
        if player.Character and (instance == player.Character or instance:IsDescendantOf(player.Character)) then
            if not Script.Functions.isDead(player) then
                return player
            end
        end
    end

    return false
end

Script.Functions.isToolBlacklisted = function(tool)
    for _, toolName in ipairs(Script.Table.Start.TriggerBot.Blacklisted) do
        if tool.Name == toolName then
            return true
        end
    end
    return false
end

-- Flag to toggle triggerbot state
local JAIROUGH = false
local hotkeyEnabled = false -- Flag to control if the hotkey is enabled or not

-- Update delay when slider is changed
Script.Functions.updateDelay = function(Value)
    Script.Table.Start.TriggerBot.Delay = Value
end

-- Toggle triggerbot state on keypress, but only if hotkey is enabled
Script.Functions.onKeyPress = function(input, gameProcessed)
    if gameProcessed then return end

    -- Only allow the hotkey to toggle triggerbot if the hotkey is enabled
    if hotkeyEnabled and input.UserInputType == EnumUserInputType.Keyboard and input.KeyCode == EnumKeyCode[Script.Table.Start.TriggerBot.Keybind] then
        JAIROUGH = not JAIROUGH
    end
end

-- Keybind handler to change keybind via UI
Script.Functions.updateKeybind = function(NewKey)
    Script.Table.Start.TriggerBot.Keybind = NewKey.Name
    print('[cb] Keybind changed!', NewKey.Name)
end

UserInputService.InputBegan:Connect(Script.Functions.onKeyPress)

-- TriggerBot activation logic
Script.Functions.triggerBot = function()
    local con
    con = RunService.Heartbeat:Connect(function()
        if JAIROUGH then
            local target = mouse.Target
            if target and Script.Functions.getTarget(target) then
                if lp.Character then
                    local tool = lp.Character:FindFirstChildWhichIsA('Tool')
                    if tool and not Script.Functions.isToolBlacklisted(tool) then
                        task.wait(Script.Table.Start.TriggerBot.Delay)
                        tool:Activate()
                    end
                end
            end
        end
    end)

    Script.Connections.triggerBot = con
end

Script.Functions.triggerBot()

-- Disable function to disconnect triggerbot and cleanup
getgenv().disable = function()
    getgenv().disable = nil
    if Script.Connections.triggerBot then
        Script.Connections.triggerBot:Disconnect()
    end
end

-- UI Integration
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Enable Hotkey',
    Default = false, -- Default value (true / false)
    Tooltip = 'Enable or Disable the hotkey for TriggerBot', -- Information shown when you hover over the toggle
    Callback = function(Value)
        -- Enable or disable hotkey based on toggle state
        hotkeyEnabled = Value
        
        -- If hotkey is disabled, immediately disable the TriggerBot as well
        if not hotkeyEnabled then
            JAIROUGH = false
        end
    end
})

LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
    Default = Script.Table.Start.TriggerBot.Keybind, -- Default keybind value
    SyncToggleState = false, -- Keybind is independent of toggle state
    Mode = 'Toggle', -- Modes: Always, Toggle, Hold
    Text = 'Triggerbot Keybind', -- Text to display in the keybind menu
    NoUI = false, -- Set to true if you want to hide from the Keybind menu,
    ChangedCallback = function(New)
        Script.Functions.updateKeybind(New)
    end
})

LeftGroupBox:AddSlider('MySlider', {
    Text = 'Delay Slider',
    Default = Script.Table.Start.TriggerBot.Delay, -- Default delay value
    Min = 0,
    Max = 1,
    Rounding = 3,
    Compact = false,
    Callback = function(Value)
        Script.Functions.updateDelay(Value)
    end
})

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Rapid Fire')

    LeftGroupBox:AddToggle('MyToggle', {
        Text = 'Rapid Fire',
        Default = false, -- Default value (true / false)
        Tooltip = 'Rapid Fire v2 is better for some', -- Information shown when you hover over the toggle
    
        Callback = function(Value)
    
            -- Ensure script state is toggled correctly on each execution
            if _G.gunActivation == nil then
                _G.gunActivation = false  -- Default value if not previously set
            end
    
            -- Toggle script state
            _G.gunActivation = not _G.gunActivation
    
            -- Store frequently used Enum values in variables
            local UserInputType = Enum.UserInputType
            local MouseButton1 = UserInputType.MouseButton1
    
            if _G.gunActivation then
                local player = game.Players.LocalPlayer
                local userInputService = game:GetService("UserInputService")
                local runService = game:GetService("RunService")
                local isActive = false  -- Tracks whether the gun activation is enabled or not
    
                -- Function to continuously activate the held item (gun) at the fastest rate possible
                local function continuouslyActivateHeldItem()
                    while _G.gunActivation and runService.Heartbeat:Wait() do
                        if isActive then
                            local character = player.Character
                            if character then
                                local gunTool = character:FindFirstChildOfClass("Tool")
                                if gunTool then
                                    gunTool:Activate()
                                end
                            end
                        end
                    end
                end
    
                local function onMouseClick(input, gameProcessedEvent)
                    if gameProcessedEvent then return end
    
                    if input.UserInputType == MouseButton1 then
                        isActive = true
                    end
                end
    
                local function onMouseRelease(input, gameProcessedEvent)
                    if gameProcessedEvent then return end
    
                    if input.UserInputType == MouseButton1 then
                        isActive = false
                    end
                end
    
                _G.mouseClickConnection = userInputService.InputBegan:Connect(onMouseClick)
                _G.mouseReleaseConnection = userInputService.InputEnded:Connect(onMouseRelease)
                spawn(continuouslyActivateHeldItem)
            else
                if _G.mouseClickConnection then
                    _G.mouseClickConnection:Disconnect()
                    _G.mouseClickConnection = nil
                end
                if _G.mouseReleaseConnection then
                    _G.mouseReleaseConnection:Disconnect()
                    _G.mouseReleaseConnection = nil
                end
            end
        end
    })    

LeftGroupBox = Tabs.Main:AddRightGroupbox('Hitbox Expander')

    repeat wait() until game:IsLoaded()

Players = game:GetService('Players')
RunService = game:GetService('RunService')
EnumMaterial = Enum.Material.Neon  -- Enum value for Material

-- Initialize global state
_G.ToggleState = _G.ToggleState or false -- Default state
_G.HITBOX_SIZE = Vector3.new(16, 16, 16)  -- Default hitbox size
_G.HitboxColor = Color3.fromRGB(0, 0, 0)  -- Default hitbox color Black
_G.HitboxTransparency = 0.8  -- Default transparency
_G.OutlineColor = Color3.fromRGB(108, 59, 170) -- Default outline color Royal Purple
_G.OutlineTransparency = 0  -- Default outline transparency
_G.Disabled = not _G.ToggleState

-- UI setup (skip UI references here)
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Hitbox Expander',
    Default = false,
    Tooltip = 'Increases size of player Hitboxes for easier targeting',
    Callback = function(Value)
        _G.ToggleState = Value
        _G.Disabled = not Value
    end
})

-- Color Pickers and Sliders for customization
LeftGroupBox:AddLabel('Outline Color'):AddColorPicker('OutlineColorPicker', {
    Default = Color3.new(0.4235, 0.2314, 0.6667), -- Royal Purple
    Title = 'Outline Color',
    Callback = function(Value) _G.OutlineColor = Value end
})

LeftGroupBox:AddLabel('Hitbox Color'):AddColorPicker('HitboxColorPicker', {
    Default = Color3.new(0, 0, 0), -- Default Black
    Title = 'Hitbox Color',
    Callback = function(Value) _G.HitboxColor = Value end
})

LeftGroupBox:AddSlider('HitboxSizeSlider', {
    Text = 'Size of the hitbox',
    Default = 16,
    Min = 5,
    Max = 37.5,
    Rounding = 1,
    Callback = function(Value) _G.HITBOX_SIZE = Vector3.new(Value, Value, Value) end
})

LeftGroupBox:AddSlider('TransparencySlider', {
    Text = 'Transparency of the hitbox',
    Default = _G.HitboxTransparency,
    Min = 0,
    Max = 1,
    Rounding = 1,
    Callback = function(Value) _G.HitboxTransparency = Value end
})

LeftGroupBox:AddSlider('OutlineTransparencySlider', {
    Text = 'Transparency of the outline',
    Default = _G.OutlineTransparency,
    Min = 0,
    Max = 1,
    Rounding = 1,
    Callback = function(Value) _G.OutlineTransparency = Value end
})

-- Object pooling for outlines
outlinePool = {}

-- Function to get the outline or create it
getOutline = function(part)
    local outline = part:FindFirstChild("Outline")
    if not outline then
        outline = #outlinePool > 0 and table.remove(outlinePool) or Instance.new("SelectionBox")
        outline.LineThickness = 0.05
        outline.Color3 = _G.OutlineColor
        outline.Name = "Outline"
    end
    outline.Adornee = part
    outline.Parent = part
    outline.Transparency = _G.OutlineTransparency
    return outline
end

-- Function to release the outline
releaseOutline = function(outline)
    outline.Adornee = nil
    outline.Parent = nil
    table.insert(outlinePool, outline)
end

-- Throttle updates
local lastUpdate = tick()

-- Function to batch and optimize updates
updateHitboxes = function()
    local now = tick()
    if now - lastUpdate < 0.2 then -- Update every 0.2 seconds (5 times per second)
        return
    end
    lastUpdate = now

    -- Loop through players and update hitboxes
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            local character = player.Character
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    local bodyEffects = character:FindFirstChild("BodyEffects")
                    local isKOd = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
                    local isGrabbed = character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil

                    -- Only modify the hitbox if not KO'd or grabbed
                    if isKOd or isGrabbed then
                        if humanoidRootPart.Size ~= Vector3.new(0, 0, 0) then
                            humanoidRootPart.Size = Vector3.new(0, 0, 0)
                            humanoidRootPart.Transparency = 1
                            local outline = humanoidRootPart:FindFirstChild("Outline")
                            if outline then releaseOutline(outline) end
                        end
                    else
                        -- Update size, color, transparency, and outline dynamically
                        if humanoidRootPart.Size ~= _G.HITBOX_SIZE then
                            humanoidRootPart.Size = _G.HITBOX_SIZE
                            humanoidRootPart.Transparency = _G.HitboxTransparency
                            humanoidRootPart.BrickColor = BrickColor.new(_G.HitboxColor)
                            humanoidRootPart.Material = EnumMaterial
                            humanoidRootPart.CanCollide = false
                            getOutline(humanoidRootPart)
                        else
                            -- Dynamically update color and transparency based on the UI changes
                            humanoidRootPart.BrickColor = BrickColor.new(_G.HitboxColor)
                            humanoidRootPart.Transparency = _G.HitboxTransparency
                        end
                        
                        -- Update outline color and transparency dynamically based on the selected Outline settings
                        local outline = humanoidRootPart:FindFirstChild("Outline")
                        if outline then
                            outline.Color3 = _G.OutlineColor
                            outline.Transparency = _G.OutlineTransparency
                        end
                    end
                end
            end
        end
    end
end

-- Use Heartbeat for smoother updates
RunService.Heartbeat:Connect(function()
    if not _G.Disabled then
        updateHitboxes()
    else
        -- Reset the hitboxes if disabled
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= Players.LocalPlayer then
                local character = player.Character
                if character then
                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        humanoidRootPart.Size = Vector3.new(2, 2, 1)
                        humanoidRootPart.Transparency = 1
                        local outline = humanoidRootPart:FindFirstChild("Outline")
                        if outline then releaseOutline(outline) end
                    end
                end
            end
        end
    end
end)

LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('Cham Esp')

-- The actual cham effect
Players = game:GetService("Players")
RunService = game:GetService("RunService")
LocalPlayer = Players.LocalPlayer
highlightColor = Color3.fromRGB(255, 255, 255)  -- Default color for chams

-- Function to create a cham (highlight) effect for a player
function CreateCham(player)
    local character = player.Character or player.CharacterAdded:Wait()
    if not character:FindFirstChild("HumanoidRootPart") then return end

    -- Create the highlight object for the player's character
    local highlight = Instance.new("Highlight")
    highlight.Name = "ChamHighlight"
    highlight.Parent = character
    highlight.Adornee = character  -- Set the highlight target to the entire character
    highlight.FillColor = highlightColor  -- Set color to chosen value
    highlight.FillTransparency = 0.5  -- Make the highlight semi-transparent
    highlight.OutlineTransparency = 1  -- Fully transparent outline (no outline)

    -- Clean up when the character is removed
    character:WaitForChild("HumanoidRootPart").AncestryChanged:Connect(function()
        highlight:Destroy()  -- Remove the highlight when the player leaves or the character is destroyed
    end)
end

-- UI Toggle for Chams
LeftGroupBox:AddToggle('ChamsToggle', {
    Text = 'Chams',
    Default = false, -- Default value (true / false)
    Tooltip = 'Toggles cham effect for players',

    Callback = function(Value)
        _G.chams = Value
        -- Apply or remove the cham effect based on the toggle state
        if _G.chams then
            -- Apply cham effect for players when enabled
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    CreateCham(player)
                end
            end
        else
            -- Remove cham effect for players when disabled
            for _, player in pairs(Players:GetPlayers()) do
                local character = player.Character
                if character then
                    local highlight = character:FindFirstChild("ChamHighlight")
                    if highlight then
                        highlight:Destroy()
                    end
                end
            end
        end
    end
})

-- Add color picker UI for Chams
LeftGroupBox:AddLabel('Color'):AddColorPicker('ColorPicker', {
    Default = Color3.fromRGB(255, 255, 255), -- White color (default)
    Title = 'Cham Color', -- Title of the color picker
    Transparency = 0, -- Disables transparency changing for this color picker

    Callback = function(Value)
        highlightColor = Value  -- Update the highlight color when the user picks a color
        -- Update the cham color for existing players
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local highlight = player.Character:FindFirstChild("ChamHighlight")
                if highlight then
                    highlight.FillColor = highlightColor  -- Apply the new color to the existing highlight
                end
            end
        end
    end
})

-- Handle player join to ensure chams are applied
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        -- Wait until the character's root part is available before applying chams
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        if _G.chams and player ~= LocalPlayer then
            CreateCham(player)  -- Apply cham if enabled and not the local player
        end
    end)
end)

Players.PlayerRemoving:Connect(function(player)
    -- Remove cham when player leaves
    if player.Character then
        local highlight = player.Character:FindFirstChild("ChamHighlight")
        if highlight then
            highlight:Destroy()
        end
    end
end)

-- Periodically update chams for players when enabled using RunService.Heartbeat
RunService.Heartbeat:Connect(function()
    if _G.chams then
        -- Loop through all players and ensure chams are applied
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                -- Create cham if it doesn't exist for the player
                local character = player.Character
                if not character:FindFirstChild("ChamHighlight") then
                    CreateCham(player)
                end
            end
        end
    else
        -- Disable the cham effect if _G.chams is false
        for _, player in pairs(Players:GetPlayers()) do
            local character = player.Character
            if character then
                local highlight = character:FindFirstChild("ChamHighlight")
                if highlight then
                    highlight:Destroy()
                end
            end
        end
    end
end)

-- Ensure chams are applied to players who have respawned
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        -- In case a player respawns
        if _G.chams and player ~= LocalPlayer then
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            CreateCham(player)
        end
    end)
end)

-- Execute the toggle when the script is first run
if _G.chams then
    -- Enable the cham effect for players (not including local player)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            CreateCham(player)
        end
    end
else
    -- Disable the cham effect for all players
    for _, player in pairs(Players:GetPlayers()) do
        local character = player.Character
        if character then
            local highlight = character:FindFirstChild("ChamHighlight")
            if highlight then
                highlight:Destroy()
            end
        end
    end
end

LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('Name Esp')

Players = game:GetService("Players")
RunService = game:GetService("RunService")
Debris = game:GetService("Debris")  -- For cleanup
LocalPlayer = Players.LocalPlayer

displayOption = 'Username'  -- Default display option
nameTagESPEnabled = false  -- Default for the name tag ESP toggle

-- Function to create a name tag for a player
function CreateNameTag(player)
    -- Skip the local player
    if player == LocalPlayer then return end

    local character = player.Character or player.CharacterAdded:Wait()
    local head = character:WaitForChild("Head")

    -- Create BillboardGui and TextLabel for the name tag
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Parent = character
    billboardGui.Size = UDim2.new(0, 100, 0, 30)  -- Adjust the size for the name tag
    billboardGui.AlwaysOnTop = true
    billboardGui.Adornee = head
    billboardGui.StudsOffset = Vector3.new(0, 6, 0)  -- Adjust position

    local nameTag = Instance.new("TextLabel")
    nameTag.Parent = billboardGui
    nameTag.Size = UDim2.new(1, 0, 1, 0)  -- Full size of the BillboardGui
    nameTag.BackgroundTransparency = 1
    nameTag.TextColor3 = Color3.new(1, 1, 1)  -- White text color
    nameTag.TextStrokeTransparency = 0.6  -- Adjust outline visibility
    nameTag.TextStrokeColor3 = Color3.new(0, 0, 0)  -- Black stroke for visibility
    nameTag.TextSize = 10  -- Smaller base text size

    -- Set the name text based on the selected option
    if displayOption == "Username" then
        nameTag.Text = player.Name  -- Display the player's username
    else
        nameTag.Text = player.DisplayName  -- Display the player's display name
    end

    -- Cleanup when the player leaves
    Debris:AddItem(billboardGui, 5)  -- Automatically cleanup after 5 seconds
end

-- Function to remove name tags
function RemoveNameTags()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character then
            local character = player.Character
            local billboardGui = character:FindFirstChildOfClass("BillboardGui")
            if billboardGui then
                -- Cleanup with Debris service
                Debris:AddItem(billboardGui, 0)
            end
        end
    end
end

-- Add the toggle to enable or disable the Name Tag ESP
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Enable Name Tag ESP',
    Default = false,  -- Default value (true / false)
    Tooltip = 'Toggles the name tag ESP visibility.',
    Callback = function(Value)
        nameTagESPEnabled = Value
        if nameTagESPEnabled then
            -- Update name tags immediately if ESP is enabled
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    CreateNameTag(player)
                end
            end
        else
            -- If ESP is disabled, remove all name tags
            RemoveNameTags()
        end
    end
})

-- Add the dropdown for selecting between Username or DisplayName
LeftGroupBox:AddDropdown('NameDisplayOption', {
    Values = { 'DisplayName', 'Username' },
    Default = 1,  -- Default to "Username"
    Multi = false, -- Single selection only
    Text = 'Name Display Option',
    Tooltip = 'Choose whether to display the player\'s Username or DisplayName',
    Callback = function(Value)
        displayOption = Value  -- Update the display option based on dropdown selection
        if nameTagESPEnabled then
            -- Reapply name tags immediately when the dropdown value changes
            RemoveNameTags()  -- Remove existing name tags
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    CreateNameTag(player)
                end
            end
        end
    end
})

-- Periodically update name tags every heartbeat (for new players)
RunService.Heartbeat:Connect(function()
    if nameTagESPEnabled then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and not player.Character:FindFirstChildOfClass("BillboardGui") then
                CreateNameTag(player)
            end
        end
    end
end)

LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('Cash Esp')

cashESPEnabled = false
textSize = 20

-- Caching frequently used Enum values
Workspace = game:GetService("Workspace")
Ignored = Workspace:WaitForChild("Ignored")
Drop = Ignored:WaitForChild("Drop")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")

-- Function to create or update BillboardGui for MoneyDrop
function cham(object)
    if object.Name == "MoneyDrop" then
        local bill = object:FindFirstChild("BillboardGui")
        
        if bill then
            if cashESPEnabled then
                bill.AlwaysOnTop = true
                bill.Size = UDim2.new(textSize, 0, textSize / 2, 0)
                bill.Enabled = true
            else
                bill.Enabled = false
            end
        end
    end
end

-- Apply Cash ESP toggle
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Cash Esp',
    Default = false, 
    Tooltip = 'Shows cash through walls', 
    Callback = function(Value)
        cashESPEnabled = Value
    end
})

-- Apply Text Size slider functionality
LeftGroupBox:AddSlider('MySlider', {
    Text = 'Text size slider',
    Default = 20,
    Min = 5,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        textSize = Value
    end
})

-- Function to check and update ESP for all Money Drops
function updateCashESP()
    for _, v in pairs(Drop:GetChildren()) do
        cham(v)
    end
end

-- Initial check for existing Money Drops on script load
updateCashESP()

-- Connect ChildAdded event to efficiently handle new Money Drops
Drop.ChildAdded:Connect(function(child)
    -- Debris cleanup for objects not needed anymore
    Debris:AddItem(child, 60)  -- Set a lifetime for ESP objects if necessary
    cham(child)
end)

-- Use RunService.Heartbeat to periodically check and update ESP for existing Money Drops
RunService.Heartbeat:Connect(function()
    if cashESPEnabled then
        updateCashESP()  -- Continually apply the Cash ESP effect
    end
end)

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Silent Aim HvH')

getgenv().TracerEnabled = true
getgenv().AutoShootEnabled = true
getgenv().shootCooldown = 0.1
getgenv().ScriptEnabled = false
getgenv().LockKey = Enum.KeyCode.T

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Camera = game.Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local MainEvent = ReplicatedStorage:FindFirstChild("MainEvent")
local selectedPlayer = nil
local lockedPlayer = nil

local tracer = Drawing.new("Line")
tracer.Thickness = 2
tracer.Visible = false
tracer.Color = Color3.fromRGB(128, 0, 128)

if not MainEvent then
    return
end

local function isKnocked(player)
    if player and player.Character then
        local KO = player.Character:FindFirstChild("BodyEffects") and player.Character.BodyEffects:FindFirstChild("K.O")
        return KO and KO.Value == true
    end
    return false
end

local function getClosestPlayerToMouse()
    local closestPlayer = nil
    local shortestDistance = math.huge
    local mousePos = UserInputService:GetMouseLocation()

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") and not isKnocked(player) then
            local head = player.Character.Head
            local headScreenPos, onScreen = Camera:WorldToViewportPoint(head.Position)

            if onScreen then
                local distance = (Vector2.new(headScreenPos.X, headScreenPos.Y) - mousePos).Magnitude
                if distance < shortestDistance then
                    closestPlayer = player
                    shortestDistance = distance
                end
            end
        end
    end

    return closestPlayer
end

local function updateTracer()
    if getgenv().TracerEnabled and getgenv().ScriptEnabled then
        local targetPlayer = lockedPlayer or getClosestPlayerToMouse()

        if targetPlayer then
            local head = targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head")
            if head then
                local headScreenPos, onScreen = Camera:WorldToViewportPoint(head.Position)

                if onScreen then
                    selectedPlayer = targetPlayer
                    tracer.Visible = true
                    tracer.To = Vector2.new(headScreenPos.X, headScreenPos.Y)
                    tracer.From = UserInputService:GetMouseLocation()
                end
            end
        else
            tracer.Visible = false
        end
    end
end

local function shoot()
    if lockedPlayer and lockedPlayer.Character and not isKnocked(lockedPlayer) and getgenv().ScriptEnabled then
        local targetHead = lockedPlayer.Character:FindFirstChild("Head")
        local Tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")

        if Tool and Tool:FindFirstChild("Handle") and targetHead then
            MainEvent:FireServer(
                "ShootGun",
                Tool.Handle,
                Tool.Handle.Position,
                targetHead.Position,
                targetHead,
                Vector3.new(0, 0, 0)
            )
        end
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == getgenv().LockKey and not gameProcessed then
        if getgenv().ScriptEnabled then
            if lockedPlayer then
                lockedPlayer = nil
            else
                lockedPlayer = getClosestPlayerToMouse()
            end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if getgenv().ScriptEnabled then
        updateTracer()

        if lockedPlayer then
            shoot()
        end
    else
        tracer.Visible = false
    end
end)

LeftGroupBox:AddToggle('ScriptToggle', {
    Text = 'Toggle Silent Aim',
    Default = false,

    Callback = function(Value)
        if Value then
            getgenv().ScriptEnabled = true
        else
            getgenv().ScriptEnabled = false
            tracer.Visible = false
        end
    end
})

LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
    Default = 'T',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Silent Aim Keybind',
    NoUI = false,

    Callback = function(Value)
    end,

    ChangedCallback = function(New)
        getgenv().LockKey = New
    end
})

RightGroupBox = Tabs.Main:AddRightGroupbox('Kill Aura')

RightGroupBox:AddToggle('MyToggle', {
    Text = 'Toggle KillAura',
    Default = false,
    Tooltip = 'Enables The KillAura Feature',
    Callback = function(Value)
        if Value then
        player = game:GetService("Players").LocalPlayer
        runService = game:GetService("RunService")
        workspace = game:GetService("Workspace")

        range = 100
        killAuraEnabled = true

        local lastDamagedPlayer = nil

        function isGunEquipped()
            local character = player.Character
            if character then
                local tool = character:FindFirstChildWhichIsA("Tool")
                return tool and tool:FindFirstChild("Handle") ~= nil
            end
            return false
        end

        function isTargetValid(targetCharacter)
            if targetCharacter then
                local bodyEffects = targetCharacter:FindFirstChild("BodyEffects")
                local KOd = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
                local Grabbed = targetCharacter:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
                return not KOd and not Grabbed
            end
            return false
        end

        function getNearestPlayer()
            local character = player.Character
            local rootPart = character and character:FindFirstChild("HumanoidRootPart")
            local nearestPlayer = nil
            local shortestDistance = range

            if rootPart then
                for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
                    if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and isTargetValid(plr.Character) then
                        local targetRootPart = plr.Character:FindFirstChild("HumanoidRootPart")
                        local distance = (targetRootPart.Position - rootPart.Position).Magnitude

                        if distance <= shortestDistance then
                            nearestPlayer = plr
                            shortestDistance = distance
                        end
                    end
                end
            end
            return nearestPlayer
        end

        function shootNearestPlayer()
            if not killAuraEnabled or not isGunEquipped() then
                return
            end

            local character = player.Character
            local rootPart = character and character:FindFirstChild("HumanoidRootPart")
            local tool = character and character:FindFirstChildWhichIsA("Tool") or player.Backpack:FindFirstChildWhichIsA("Tool")
            local targetPlayer = getNearestPlayer()

            if tool and tool:FindFirstChild("Handle") and rootPart and targetPlayer and targetPlayer.Character then
                local targetHead = targetPlayer.Character:FindFirstChild("Head")
                if targetHead then
                    local direction = (targetHead.Position - rootPart.Position).unit
                    game:GetService("ReplicatedStorage"):WaitForChild("MainEvent"):FireServer("ShootGun", tool.Handle, rootPart.Position, targetHead.Position, targetHead, direction)
                end
            end
        end

        runService.Heartbeat:Connect(function()
            if killAuraEnabled then
                shootNearestPlayer()
            end
        end)  
        else
            killAuraEnabled = false
        end
    end
})

local ESPSection = Tabs.Visuals:AddLeftGroupbox('ESP Settings')

local ESP_Toggles = {
    Boxes = false,
    HealthBar = false
}

ESPSection:AddToggle('BoxesToggle', {
    Text = 'Show Boxes',
    Default = false,
    Tooltip = 'Toggle ESP Boxes on/off',

    Callback = function(Value)
        ESP_Toggles.Boxes = Value
    end
})

ESPSection:AddToggle('HealthToggle', {
    Text = 'Show Health Bar',
    Default = false,
    Tooltip = 'Toggle ESP Health Bar on/off',

    Callback = function(Value)
        ESP_Toggles.HealthBar = Value
    end
})

local player = game:GetService("Players").LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera

local function NewQuad(thickness, color)
    local quad = Drawing.new("Quad")
    quad.Visible = false
    quad.PointA = Vector2.new(0, 0)
    quad.PointB = Vector2.new(0, 0)
    quad.PointC = Vector2.new(0, 0)
    quad.PointD = Vector2.new(0, 0)
    quad.Color = color
    quad.Filled = false
    quad.Thickness = thickness
    quad.Transparency = 1
    return quad
end

local function NewLine(thickness, color)
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = color
    line.Thickness = thickness
    line.Transparency = 1
    return line
end

local function Visibility(state, lib)
    for _, x in pairs(lib) do
        x.Visible = state
    end
end

local black = Color3.fromRGB(0, 0 ,0)
local white = Color3.fromRGB(255, 255, 255)

local function ESP(plr)
    local library = {
        black = NewQuad(2, black),
        box = NewQuad(1, white), -- Changed box color to white
        healthbar = NewLine(3, black),
        greenhealth = NewLine(1.5, black)
    }

    local function Updater()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") then
                local HumPos, OnScreen = camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                if OnScreen then
                    local head = camera:WorldToViewportPoint(plr.Character.Head.Position)
                    local DistanceY = math.clamp((Vector2.new(head.X, head.Y) - Vector2.new(HumPos.X, HumPos.Y)).magnitude, 2, math.huge)

                    local boxSize = DistanceY * 1.2  

                    local function Size(item)
                        item.PointA = Vector2.new(HumPos.X + boxSize, HumPos.Y - boxSize * 2)
                        item.PointB = Vector2.new(HumPos.X - boxSize, HumPos.Y - boxSize * 2)
                        item.PointC = Vector2.new(HumPos.X - boxSize, HumPos.Y + boxSize * 2)
                        item.PointD = Vector2.new(HumPos.X + boxSize, HumPos.Y + boxSize * 2)
                    end
                    Size(library.box)
                    Size(library.black)

                    -- Health Bar scaling with box
                    local health_offset = plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth * (boxSize * 4)  

                    library.healthbar.From = Vector2.new(HumPos.X - boxSize - 4, HumPos.Y - boxSize * 2)
                    library.healthbar.To = Vector2.new(HumPos.X - boxSize - 4, HumPos.Y + boxSize * 2)

                    library.greenhealth.From = Vector2.new(HumPos.X - boxSize - 4, HumPos.Y + boxSize * 2)
                    library.greenhealth.To = Vector2.new(HumPos.X - boxSize - 4, HumPos.Y + boxSize * 2 - health_offset)

                    -- Health color transition
                    local green = Color3.fromRGB(0, 255, 0)
                    local red = Color3.fromRGB(255, 0, 0)
                    library.greenhealth.Color = red:lerp(green, plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth)

                    -- Apply Toggles
                    Visibility(ESP_Toggles.Boxes, { library.box, library.black })
                    Visibility(ESP_Toggles.HealthBar, { library.healthbar, library.greenhealth })

                else 
                    Visibility(false, library)
                end
            else 
                Visibility(false, library)
                if game.Players:FindFirstChild(plr.Name) == nil then
                    connection:Disconnect()
                end
            end
        end)
    end

    coroutine.wrap(Updater)()
end

for _, v in pairs(game:GetService("Players"):GetPlayers()) do
    if v.Name ~= player.Name then
        coroutine.wrap(ESP)(v)
    end
end

game.Players.PlayerAdded:Connect(function(newplr)
    if newplr.Name ~= player.Name then
        coroutine.wrap(ESP)(newplr)
    end
end)

local ESPEnabled = false
local ESPConnections = {}
local ESPObjects = {}
local DisplayOption = "Username"

local function ToggleESP(Value)
    ESPEnabled = Value
    if not Value then
        for _, connection in ipairs(ESPConnections) do
            connection:Disconnect()
        end
        ESPConnections = {}
        for _, obj in pairs(ESPObjects) do
            if obj then
                obj:Destroy()
            end
        end
        ESPObjects = {}
    else
        for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
            if not ESPObjects[player] then
                CreateESP(player)
            end
        end
    end
end

local Settings = {
    Box_Color = Color3.fromRGB(255, 255, 255), -- Set box outline to white
    Box_Thickness = 2,
    Team_Check = false,
    Team_Color = false,
    Autothickness = true,
    ESP_Active = false, -- To control ESP activation
}

ESPSection:AddToggle('ESP_Toggle', {
    Text = 'Corner Boxes',
    Default = false, -- ESP is inactive by default
    Tooltip = 'Toggle the visibility of the corner ESP boxes.',
    Callback = function(Value)
        Settings.ESP_Active = Value -- Set the global setting to the toggle value
    end
})

local Space = game:GetService("Workspace")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Camera = Space.CurrentCamera
local RunService = game:GetService("RunService")

local function NewLine(color, thickness)
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = color
    line.Thickness = thickness
    line.Transparency = 1
    return line
end

local function Vis(lib, state)
    for i, v in pairs(lib) do
        v.Visible = state
    end
end

local function Colorize(lib, color)
    for i, v in pairs(lib) do
        v.Color = color
    end
end

local function Main(plr)
    repeat wait() until plr.Character and plr.Character:FindFirstChild("Humanoid")
    
    local R15 = plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R15
    local Library = {
        TL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness)
    }

    local oripart = Instance.new("Part")
    oripart.Parent = Space
    oripart.Transparency = 1
    oripart.CanCollide = false
    oripart.Size = Vector3.new(1, 1, 1)
    oripart.Position = Vector3.new(0, 0, 0)

        local function Updater()
        local c
        c = RunService.RenderStepped:Connect(function()
            if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") then
                local Hum = plr.Character
                local HumPos, vis = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position)

                if vis then
                    oripart.Size = Vector3.new(Hum.HumanoidRootPart.Size.X, Hum.HumanoidRootPart.Size.Y * 1.5, Hum.HumanoidRootPart.Size.Z)
                    oripart.CFrame = CFrame.new(Hum.HumanoidRootPart.CFrame.Position, Camera.CFrame.Position)
                    local SizeX = oripart.Size.X
                    local SizeY = oripart.Size.Y
                    local TL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(SizeX, SizeY, 0)).p)
                    local TR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-SizeX, SizeY, 0)).p)
                    local BL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(SizeX, -SizeY, 0)).p)
                    local BR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-SizeX, -SizeY, 0)).p)

                    if Settings.Team_Check then
                        if plr.TeamColor == Player.TeamColor then
                            Colorize(Library, Color3.fromRGB(0, 255, 0))
                        else
                            Colorize(Library, Color3.fromRGB(255, 0, 0))
                        end
                    end

                    if Settings.Team_Color then
                        Colorize(Library, plr.TeamColor.Color)
                    end

                    local ratio = (Camera.CFrame.p - Hum.HumanoidRootPart.Position).magnitude
                    local offset = math.clamp(1 / ratio * 750, 2, 300)

                    Library.TL1.From = Vector2.new(TL.X, TL.Y)
                    Library.TL1.To = Vector2.new(TL.X + offset, TL.Y)
                    Library.TL2.From = Vector2.new(TL.X, TL.Y)
                    Library.TL2.To = Vector2.new(TL.X, TL.Y + offset)

                    Library.TR1.From = Vector2.new(TR.X, TR.Y)
                    Library.TR1.To = Vector2.new(TR.X - offset, TR.Y)
                    Library.TR2.From = Vector2.new(TR.X, TR.Y)
                    Library.TR2.To = Vector2.new(TR.X, TR.Y + offset)

                    Library.BL1.From = Vector2.new(BL.X, BL.Y)
                    Library.BL1.To = Vector2.new(BL.X + offset, BL.Y)
                    Library.BL2.From = Vector2.new(BL.X, BL.Y)
                    Library.BL2.To = Vector2.new(BL.X, BL.Y - offset)

                    Library.BR1.From = Vector2.new(BR.X, BR.Y)
                    Library.BR1.To = Vector2.new(BR.X - offset, BR.Y)
                    Library.BR2.From = Vector2.new(BR.X, BR.Y)
                    Library.BR2.To = Vector2.new(BR.X, BR.Y - offset)

                    Vis(Library, Settings.ESP_Active)

                    if Settings.Autothickness then
                        local distance = (Player.Character.HumanoidRootPart.Position - oripart.Position).magnitude
                        local value = math.clamp(1 / distance * 100, 1, 4) --0.1 is min thickness, 6 is max
                        for u, x in pairs(Library) do
                            x.Thickness = value
                        end
                    else
                        for u, x in pairs(Library) do
                            x.Thickness = Settings.Box_Thickness
                        end
                    end
                else
                    Vis(Library, false)
                end
            else
                Vis(Library, false)
                if not Players:FindFirstChild(plr.Name) then
                    for i, v in pairs(Library) do
                        v:Remove()
                    end
                    oripart:Destroy()
                    c:Disconnect()
                end
            end
        end)
    end
    coroutine.wrap(Updater)()
end

for _, v in pairs(Players:GetPlayers()) do
    if v.Name ~= Player.Name then
        coroutine.wrap(Main)(v)
    end
end

Players.PlayerAdded:Connect(function(newplr)
    coroutine.wrap(Main)(newplr)
end)

local LeftGroupBox = Tabs.Misc:AddLeftGroupbox('anti-void')

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

local teleportHeight = 500
local antiVoidEnabled = false

LeftGroupBox:AddToggle('AntiVoidToggle', {
    Text = 'Enable Anti-Void',
    Default = false,
    Tooltip = 'Prevents falling into the void by teleporting up',

    Callback = function(Value)
        antiVoidEnabled = Value
        print('[cb] AntiVoidToggle changed to:', Value)
    end
})

LeftGroupBox:AddSlider('TeleportHeightSlider', {
    Text = 'Studs it teleports up', 
    Default = 500,
    Min = 100,
    Max = 1000,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        teleportHeight = Value
        print('[cb] Teleport height changed to:', Value)
    end
})

local function antiVoidCheck()
    if antiVoidEnabled and rootPart and rootPart.Position.Y <= -150 then
        rootPart.CFrame = rootPart.CFrame + Vector3.new(0, teleportHeight, 0)
    end
end

local connection
connection = RunService.Heartbeat:Connect(antiVoidCheck)

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    rootPart = character:WaitForChild("HumanoidRootPart")
end)

 LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('No Fog')

    local lighting = game:GetService("Lighting")
    local StarterGui = game:GetService("StarterGui")
    local debris = game:GetService("Debris")

    -- Store common values in variables to minimize repetitive calls
    local fogEnd = lighting.FogEnd
    local fogStart = lighting.FogStart

    -- Create the toggle button (integrated from your provided example)
    LeftGroupBox:AddToggle('MyToggle', {
    Text = 'No Fog',
    Default = false, -- Default value (true / false)
    Tooltip = 'This removes any kind of Fog from the game', -- Information shown when you hover over the toggle

    Callback = function(Value)
        if Value then
            -- Check if the fog removal has been executed before
            if not _G.FogRemovalExecuted then
                -- Store original fog settings
                _G.OriginalFogSettings = {
                    FogEnd = fogEnd,
                    FogStart = fogStart,
                }

                lighting.FogEnd = 100000  -- Set this to a high value to push fog far away
                lighting.FogStart = 0     -- Set this to 0 to ensure fog doesn't start close

                local atmosphere = lighting:FindFirstChildOfClass("Atmosphere")
                if atmosphere then
                    atmosphere:Destroy()
                end

                _G.FogRemovalExecuted = true
            end
        else
            if _G.FogRemovalExecuted then
                lighting.FogEnd = _G.OriginalFogSettings.FogEnd
                lighting.FogStart = _G.OriginalFogSettings.FogStart

                _G.FogRemovalExecuted = false
            end
        end

        print('[cb] MyToggle changed to:', Value)
    end
    })

    LeftGroupBox = Tabs.Visuals:AddRightGroupbox('Fullbright')

    LeftGroupBox:AddToggle('MyToggle', {
        Text = 'Fullbright',
        Default = false, -- Default value (true / false)
        Tooltip = 'Removes shadows and increases brightness', -- Information shown when you hover over the toggle
    
        Callback = function(Value)
            if not _G.FullBrightExecuted then
                _G.FullBrightEnabled = false
    
                local Lighting = game:GetService("Lighting")
                
                -- Store default settings in a table
                _G.NormalLightingSettings = {
                    Brightness = Lighting.Brightness,
                    ClockTime = Lighting.ClockTime,
                    GlobalShadows = Lighting.GlobalShadows,
                    Ambient = Lighting.Ambient
                }
    
                -- Full Bright settings
                local FullBrightSettings = {
                    Brightness = 1,
                    ClockTime = 12,
                    GlobalShadows = false,
                    Ambient = Color3.fromRGB(178, 178, 178)
                }
    
                -- Set lighting properties
                local function setLightingProperties(properties)
                    for property, value in pairs(properties) do
                        Lighting[property] = value
                    end
                end
    
                -- Initial setup
                setLightingProperties(FullBrightSettings)
    
                -- Create a single function to handle property changes
                local function createPropertyChangeListener(property, defaultValue, newValue)
                    Lighting:GetPropertyChangedSignal(property):Connect(function()
                        if Lighting[property] ~= defaultValue and Lighting[property] ~= _G.NormalLightingSettings[property] then
                            _G.NormalLightingSettings[property] = Lighting[property]
                            if not _G.FullBrightEnabled then
                                repeat wait() until _G.FullBrightEnabled
                            end
                            Lighting[property] = newValue
                        end
                    end)
                end
    
                -- Set up property listeners
                for property, newValue in pairs(FullBrightSettings) do
                    createPropertyChangeListener(property, newValue, newValue)
                end
    
                -- Periodically toggle FullBright settings
                local LatestValue = true
                spawn(function()
                    while wait() do
                        if _G.FullBrightEnabled ~= LatestValue then
                            if not _G.FullBrightEnabled then
                                setLightingProperties(_G.NormalLightingSettings)
                            else
                                setLightingProperties(FullBrightSettings)
                            end
                            LatestValue = not LatestValue
                        end
                    end
                end)
            end
    
            -- Toggle full bright state
            _G.FullBrightExecuted = true
            _G.FullBrightEnabled = Value -- directly using Value here to toggle the state
        end
    })    

LeftGroupBox = Tabs.Visuals:AddRightGroupbox('Ambience')

local lighting = game:GetService("Lighting")
local StarterGui = game:GetService("StarterGui")
local runService = game:GetService("RunService")
local debris = game:GetService("Debris")

if not _G.OriginalLightingSettings then
    _G.OriginalLightingSettings = {
        Ambient = lighting.Ambient,
        OutdoorAmbient = lighting.OutdoorAmbient,
        Brightness = lighting.Brightness,
        ColorShift_Bottom = lighting.ColorShift_Bottom,
        ColorShift_Top = lighting.ColorShift_Top,
        FogColor = lighting.FogColor,
        FogStart = lighting.FogStart,
        FogEnd = lighting.FogEnd,
        TimeOfDay = lighting.TimeOfDay,
        Skybox = lighting:FindFirstChildOfClass("Sky"), -- Ensure no errors if skybox doesn't exist
        ClockTime = lighting.ClockTime
    }
end

local selectedAmbientColor = _G.OriginalLightingSettings.Ambient
local selectedOutdoorAmbientColor = _G.OriginalLightingSettings.OutdoorAmbient
local selectedColorShiftBottom = _G.OriginalLightingSettings.ColorShift_Bottom
local selectedColorShiftTop = _G.OriginalLightingSettings.ColorShift_Top
local selectedFogColor = _G.OriginalLightingSettings.FogColor

local skyboxAssetID = "rbxassetid://1294489738"

-- Add the toggle for the royal purple ambience
LeftGroupBox:AddToggle('AmbienceToggle', {
    Text = 'Enable Custom Ambient Lighting',
    Default = false, -- Default value (true / false)
    Tooltip = 'Toggle to switch between original and custom ambient lighting',

    Callback = function(Value)
        if Value then
            -- Apply the altered custom ambient lighting settings
            lighting.Ambient = selectedAmbientColor
            lighting.OutdoorAmbient = selectedOutdoorAmbientColor
            lighting.Brightness = 2
            lighting.ColorShift_Bottom = selectedColorShiftBottom
            lighting.ColorShift_Top = selectedColorShiftTop
            lighting.FogColor = selectedFogColor
            lighting.FogStart = 0
            lighting.FogEnd = 500
            lighting.TimeOfDay = "18:00:00"

            -- Set a custom skybox for the custom ambience
            local skybox = lighting:FindFirstChildOfClass("Sky")
            if not skybox then
                skybox = Instance.new("Sky")
                skybox.Parent = lighting
            end
            skybox.SkyboxBk = skyboxAssetID
            skybox.SkyboxDn = skyboxAssetID
            skybox.SkyboxFt = skyboxAssetID
            skybox.SkyboxLf = skyboxAssetID
            skybox.SkyboxRt = skyboxAssetID
            skybox.SkyboxUp = skyboxAssetID

            -- Set the flag to indicate that the lighting has been altered
            _G.AmbienceToggled = true

            -- Immediately set the time of day to the current slider value when toggle is enabled
            lighting.ClockTime = _G.ClockTimeOverride or 17 -- Default to the slider value if set
        else
            -- Reset the lighting back to the original settings
            lighting.Ambient = _G.OriginalLightingSettings.Ambient
            lighting.OutdoorAmbient = _G.OriginalLightingSettings.OutdoorAmbient
            lighting.Brightness = _G.OriginalLightingSettings.Brightness
            lighting.ColorShift_Bottom = _G.OriginalLightingSettings.ColorShift_Bottom
            lighting.ColorShift_Top = _G.OriginalLightingSettings.ColorShift_Top
            lighting.FogColor = _G.OriginalLightingSettings.FogColor
            lighting.FogStart = _G.OriginalLightingSettings.FogStart
            lighting.FogEnd = _G.OriginalLightingSettings.FogEnd
            lighting.TimeOfDay = _G.OriginalLightingSettings.TimeOfDay

            local sky = lighting:FindFirstChildOfClass("Sky")
            if sky then
                debris:AddItem(sky, 1) -- Use debris to clean up skybox instance
            end

            if _G.OriginalLightingSettings.Skybox then
                local originalSkybox = _G.OriginalLightingSettings.Skybox:Clone()
                originalSkybox.Parent = lighting
            end

            _G.AmbienceToggled = false
        end
    end
})

LeftGroupBox:AddSlider('BrightnessSlider', { 
    Text = 'Brightness Control',
    Default = 10,  -- Set initial brightness to 2 (adjust if needed)
    Min = 0,
    Max = 20,  -- Max brightness set to 20
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        -- Immediately change the lighting brightness live based on slider value
        lighting.Brightness = Value
    end
})

-- Add the slider to control fog end with max value set to 1000
LeftGroupBox:AddSlider('FogEndSlider', { 
    Text = 'Fog End Control',
    Default = 500,  -- Set initial fog end to 500 (adjust if needed)
    Min = 100,
    Max = 10000,  -- Max fog end set to 100000
    Rounding = 0,
    Compact = false,

    Callback = function(Value)
        lighting.FogEnd = Value
    end
})

LeftGroupBox:AddSlider('TimeOfDaySlider', { 
    Text = 'Time of Day Control',
    Default = 17,  -- Set initial time to 12:00 (adjust if needed)
    Min = 0,
    Max = 24,  -- 24-hour format for time of day
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        -- Lock the time of day client-side by setting it
        if _G.AmbienceToggled then
            lighting.ClockTime = Value
            -- Save the desired value so it stays fixed
            _G.ClockTimeOverride = Value
        end
    end
})

runService.Heartbeat:Connect(function()
    if _G.AmbienceToggled and _G.ClockTimeOverride then
        lighting.ClockTime = _G.ClockTimeOverride
    end
end)

LeftGroupBox:AddLabel('Ambient Color Picker'):AddColorPicker('AmbientColorPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default royal purple
    Title = 'Select Ambient Color',
    Transparency = 0,  -- Optional

    Callback = function(Value)
        selectedAmbientColor = Value
        if _G.AmbienceToggled then
            lighting.Ambient = selectedAmbientColor
        end
    end
})

LeftGroupBox:AddLabel('Outdoor Ambient Color Picker'):AddColorPicker('OutdoorAmbientColorPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default color
    Title = 'Select Outdoor Ambient Color',

    Callback = function(Value)
        selectedOutdoorAmbientColor = Value
        if _G.AmbienceToggled then
            lighting.OutdoorAmbient = selectedOutdoorAmbientColor
        end
    end
})

LeftGroupBox:AddLabel('Color Shift Bottom Picker'):AddColorPicker('ColorShiftBottomPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default color
    Title = 'Select Color Shift Bottom',

    Callback = function(Value)
        selectedColorShiftBottom = Value
        if _G.AmbienceToggled then
            lighting.ColorShift_Bottom = selectedColorShiftBottom
        end
    end
})

LeftGroupBox:AddLabel('Color Shift Top Picker'):AddColorPicker('ColorShiftTopPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default color
    Title = 'Select Color Shift Top',

    Callback = function(Value)
        selectedColorShiftTop = Value
        if _G.AmbienceToggled then
            lighting.ColorShift_Top = selectedColorShiftTop
        end
    end
})

LeftGroupBox:AddLabel('Fog Color Picker'):AddColorPicker('FogColorPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default color
    Title = 'Select Fog Color',

    Callback = function(Value)
        selectedFogColor = Value
        if _G.AmbienceToggled then
            lighting.FogColor = selectedFogColor
        end
    end
})

LeftGroupBox = Tabs.Movement:AddLeftGroupbox('Speed')

    --// Required Services and Variables
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local KeyCode = Enum.KeyCode -- Store Enum for repeated use

    -- Utility Functions
    local Utility = {
    hasCharacter = function(player)
        local character = player and player.Character
        return character and character:FindFirstChild("HumanoidRootPart", true) and character:FindFirstChild("Humanoid", true)
    end,
    newConnection = function(event, callback)
        return event:Connect(callback)
    end
    }

    -- Configuration Flags
    local Flags = {
    cframeSpeedEnabled = false, -- Initially off
    cframeSpeedToggleAllowed = false, -- Toggle must be enabled via UI
    cframeSpeedKeybind = KeyCode.V, -- Default toggle key set to V
    cframeSpeedAmount = 150 -- Default speed
    }

    -- CFrame Speed Functionality
    local function updateCframeSpeed(deltaTime)
    if Flags.cframeSpeedEnabled and Utility.hasCharacter(LocalPlayer) then
        local character = LocalPlayer.Character
        local hrp = character:FindFirstChild("HumanoidRootPart", true)
        local humanoid = character:FindFirstChild("Humanoid", true)
        local moveDirection = humanoid and humanoid.MoveDirection

        if hrp and moveDirection then
            local movement = moveDirection.Unit * Flags.cframeSpeedAmount * deltaTime
            if movement.Magnitude > 0 then
                hrp.CFrame = hrp.CFrame + movement
            end
        end
    end
    end

    -- UI Integration
    LeftGroupBox:AddToggle('CframeSpeedToggle', {
    Text = 'Toggle CFrame Speed',
    Default = false,
    Tooltip = 'Toggles speed using CFrames',
    Callback = function(value)
        Flags.cframeSpeedToggleAllowed = value
        if not value then
            Flags.cframeSpeedEnabled = false
        end
    end
    })

    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('CframeSpeedKeybind', {
    Default = 'V',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Toggle CFrame Speed',
    NoUI = false,
    Callback = function(value)
        if value and typeof(value) == "EnumItem" then
            Flags.cframeSpeedKeybind = KeyCode[value.Name]
        end
    end,
    ChangedCallback = function(newValue)
        if newValue and typeof(newValue) == "EnumItem" then
            Flags.cframeSpeedKeybind = KeyCode[newValue.Name]
        end
    end
    })

    LeftGroupBox:AddSlider('CframeSpeedSlider', {
    Text = 'CFrame Speed Amount',
    Default = 150,
    Min = 16,
    Max = 1000,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        Flags.cframeSpeedAmount = value
    end
    })

    -- RenderStepped Connection for CFrame Speed
    if _G.cframeSpeedRenderSteppedConnection then
    _G.cframeSpeedRenderSteppedConnection:Disconnect()
    end
    _G.cframeSpeedRenderSteppedConnection = RunService.Heartbeat:Connect(updateCframeSpeed)

    -- Input Listener for Keybind
    if _G.cframeSpeedToggleListener then
    _G.cframeSpeedToggleListener:Disconnect()
    end
    _G.cframeSpeedToggleListener = Utility.newConnection(UserInputService.InputBegan, function(input, gameProcessed)
    if gameProcessed then return end

    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Flags.cframeSpeedKeybind then
        if Flags.cframeSpeedToggleAllowed then
            Flags.cframeSpeedEnabled = not Flags.cframeSpeedEnabled
        end
    end
    end)

    LeftGroupBox = Tabs.Movement:AddLeftGroupbox('Fly')

    --// Required Services and Variables
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local KeyCode = Enum.KeyCode -- Store Enum for repeated use

    -- Utility Functions
    local Utility = {
    hasCharacter = function(player)
        local character = player and player.Character
        return character and character:FindFirstChild("HumanoidRootPart", true) and character:FindFirstChild("Humanoid", true)
    end,
    newConnection = function(event, callback)
        return event:Connect(callback)
    end
    }

    -- Configuration Flags
    local Flags = {
    rageCFrameFlyEnabled = false, -- Initially off
    rageCFrameFlyToggleAllowed = false, -- Toggle must be enabled via UI
    rageCFrameFlyKeybind = KeyCode.B, -- Default toggle key set to B
    rageCFrameFlyAmount = 250 -- Default fly speed
    }

    -- Fly Functionality
    local function updateFly(deltaTime)
    if Flags.rageCFrameFlyEnabled and Utility.hasCharacter(LocalPlayer) then
        local character = LocalPlayer.Character
        local hrp = character:FindFirstChild("HumanoidRootPart", true)
        local moveDirection = character:FindFirstChild("Humanoid", true).MoveDirection

        -- Vertical movement based on key input
        local verticalSpeed = (UserInputService:IsKeyDown(KeyCode.Space) and 1 or UserInputService:IsKeyDown(KeyCode.LeftShift) and -1 or 0)
        local verticalMovement = Vector3.new(0, verticalSpeed, 0)

        -- Combine horizontal and vertical movement for consistent speed
        local movement = (moveDirection + verticalMovement).Unit * Flags.rageCFrameFlyAmount * deltaTime

        -- Update position using CFrame
        if movement.Magnitude > 0 then
            hrp.CFrame = hrp.CFrame + movement
        end

        -- Adjust velocity to prevent conflicts
        hrp.Velocity = Vector3.zero
    end
    end

    -- UI Integration
    LeftGroupBox:AddToggle('CframeFlightToggle', {
    Text = 'Toggle Cframe Flight',
    Default = false,
    Tooltip = 'Toggles flight using CFrames',
    Callback = function(value)
        Flags.rageCFrameFlyToggleAllowed = value
        if not value then
            Flags.rageCFrameFlyEnabled = false
        end
    end
    })

    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('FlightKeybind', {
    Default = 'B',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Toggle Cframe Flight',
    NoUI = false,

    Callback = function(value)
        if value and typeof(value) == "EnumItem" then
            Flags.rageCFrameFlyKeybind = KeyCode[value.Name]
        end
    end,

    ChangedCallback = function(newValue)
        if newValue and typeof(newValue) == "EnumItem" then
            Flags.rageCFrameFlyKeybind = KeyCode[newValue.Name]
        end
    end
    })

    LeftGroupBox:AddSlider('CframeFlightSpeed', {
    Text = 'CFrame Flight Speed',
    Default = 250,
    Min = 16,
    Max = 2000,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        Flags.rageCFrameFlyAmount = value
    end
    })

    -- RenderStepped Connection for Flight
    if _G.flyRenderSteppedConnection then
    _G.flyRenderSteppedConnection:Disconnect()
    end
    _G.flyRenderSteppedConnection = RunService.Heartbeat:Connect(updateFly)

    -- Input Listener for Keybind
    if _G.flyToggleListener then
    _G.flyToggleListener:Disconnect()
    end
    _G.flyToggleListener = Utility.newConnection(UserInputService.InputBegan, function(input, gameProcessed)
    if gameProcessed then return end

    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Flags.rageCFrameFlyKeybind then
        if Flags.rageCFrameFlyToggleAllowed then
            Flags.rageCFrameFlyEnabled = not Flags.rageCFrameFlyEnabled
        end
    end
    end)

 LeftGroupBox = Tabs.Movement:AddLeftGroupbox('Fake Macro')

    LeftGroupBox:AddToggle('MyToggle', {
        Text = 'Fake Macro',
        Default = false,
        Tooltip = 'Activates fake macro!',
    
        Callback = function(Value)
            print('[cb] MyToggle changed to:', Value)
            
            -- Toggle the speed feature based on the toggle value
            if Value then
                _G.ScriptEnabled = true
                resetCharacter()
            else
                _G.ScriptEnabled = false
            end
        end
    })
    
    player = game.Players.LocalPlayer
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    emoteId = "rbxassetid://3189777795"
    
    -- Speed variables
    maxSpeed = 300
    baseSpeed = 16
    speedIncrement = 1.75
    emoteDuration = 1.6 -- Default emote duration
    
    -- Variables to track speed and state
    currentSpeed = baseSpeed
    isSpeedEnabled = false
    emoteTrack = nil
    isSpeedReady = false
    
    -- Cache the hotkey (Q) for reuse
    Keybind = Enum.KeyCode.Q
    
    -- Efficient use of services and enum values
    UserInputService = game:GetService("UserInputService")
    RunService = game:GetService("RunService")
    
    -- Function to initialize the character and humanoid
    function initializeCharacter(newCharacter)
        character = newCharacter or player.Character
        humanoid = character:WaitForChild("Humanoid")
        currentSpeed = baseSpeed
        humanoid.WalkSpeed = baseSpeed
        isSpeedEnabled = false
        isSpeedReady = false
    end
    
    -- Function to forcefully reset the character
    function resetCharacter()
        if humanoid then
            humanoid.Health = 0
        end
    end
    
    -- Function to play the emote
    function playEmote()
        animation = Instance.new("Animation")
        animation.AnimationId = emoteId
        emoteTrack = humanoid:LoadAnimation(animation)
        emoteTrack:Play()
    
        -- Stop the emote after the duration from the slider
        task.wait(emoteDuration)
        if emoteTrack and emoteTrack.IsPlaying then
            emoteTrack:Stop()
        end
    
        -- After the emote ends, set isSpeedReady to true to start gradual speed increase
        isSpeedReady = true
    end
    
    -- Function to manage speed (gradual increase)
    function updateSpeed()
        if _G.ScriptEnabled and isSpeedEnabled then
            if isSpeedReady then
                currentSpeed = math.min(currentSpeed + speedIncrement, maxSpeed)
                humanoid.WalkSpeed = currentSpeed
            else
                humanoid.WalkSpeed = baseSpeed
            end
        elseif not isSpeedEnabled or not _G.ScriptEnabled then
            humanoid.WalkSpeed = baseSpeed
            currentSpeed = baseSpeed
        end
    end
    
    -- Toggle the speed feature
    function toggleSpeedFeature()
        if not _G.ScriptEnabled then return end
        isSpeedEnabled = not isSpeedEnabled
        if isSpeedEnabled then
            currentSpeed = baseSpeed
            humanoid.WalkSpeed = baseSpeed
            isSpeedReady = false
            playEmote()
        else
            currentSpeed = baseSpeed
            humanoid.WalkSpeed = baseSpeed
            isSpeedReady = false
        end
    end
    
    -- Reinitialize the script on character respawn
    player.CharacterAdded:Connect(initializeCharacter)
    
    -- Bind the hotkey (Q) to toggle the feature
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if _G.ScriptEnabled and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Keybind then
            toggleSpeedFeature()
        end
    end)
    
    -- Do not reset character immediately on script load, only when toggle is true
    if _G.ScriptEnabled then
        resetCharacter()
    end
    
    -- Bind RunService Heartbeat to continuously update speed
    RunService.Heartbeat:Connect(updateSpeed)
    
    -- Initialize the script for the current character
    initializeCharacter(character)
    
    -- Add KeyPicker for dynamic hotkey
    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', { 
        Default = 'Q', -- Initial keybind (can be changed)
        SyncToggleState = false,
        Mode = 'Toggle', -- Modes: Always, Toggle, Hold
        Text = 'Speed Toggle Keybind',
    
        Callback = function(Value)
            print('[cb] Keybind clicked!', Value)
        end,
    
        ChangedCallback = function(New)
            print('[cb] Keybind changed!', New)
            -- Update the hotkey to the new key selected
            Keybind = New
        end
    })
    
    -- Add Slider for emote duration
    LeftGroupBox:AddSlider('EmoteDuration', {
        Text = 'Emote Duration (Seconds)',
        Default = 1.6,
        Min = 0,
        Max = 2.5,
        Rounding = 2,
        Compact = false,
    
        Callback = function(Value)
            print('[cb] Emote Duration changed! New value:', Value)
            emoteDuration = Value
        end
    })
    
    -- Add Slider for max speed
    LeftGroupBox:AddSlider('MaxSpeed', {
        Text = 'Max Speed',
        Default = 300,
        Min = 16,
        Max = 1000, -- Adjust max limit as needed
        Rounding = 0,
        Compact = false,
    
        Callback = function(Value)
            print('[cb] Max Speed changed! New value:', Value)
            maxSpeed = Value
        end
    })
    
    -- Add Slider for speed increment
    LeftGroupBox:AddSlider('SpeedIncrement', {
        Text = 'Speed Increment',
        Default = 1.75,
        Min = 0.1,
        Max = 10,
        Rounding = 2,
        Compact = false,
    
        Callback = function(Value)
            print('[cb] Speed Increment changed! New value:', Value)
            speedIncrement = Value
        end
    })    

 LeftGroupBox = Tabs.Movement:AddLeftGroupbox('Jump settings') 

    -- Function to handle enabling/disabling the no jump cooldown feature
    local function toggleNoJumpCooldown(enabled)
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")

    -- Helper function to update the humanoid's jump settings
    local function updateJumpSettings(humanoid, state)
        humanoid.UseJumpPower = not state -- Disable cooldown when `enabled` is true
        print("Jump cooldown " .. (state and "disabled!" or "enabled!"))
    end

    -- Apply the setting to the current humanoid
    updateJumpSettings(humanoid, enabled)

    -- Monitor for respawn and reapply the no jump cooldown setting if enabled
    player.CharacterAdded:Connect(function(newCharacter)
        local newHumanoid = newCharacter:WaitForChild("Humanoid")
        updateJumpSettings(newHumanoid, enabled)
    end)
    end

    -- Add a toggle to the UI
    LeftGroupBox:AddToggle('NoJumpCooldownToggle', {
    Text = 'Toggle No Jump Cooldown',
    Default = false, -- Default value (true / false)
    Tooltip = 'Toggles the jump cooldown on or off', -- Information shown when you hover over the toggle

    Callback = function(value)
        -- Update the global state and toggle the feature
        _G.noJumpCooldownEnabled = value
        toggleNoJumpCooldown(value)
        print('[cb] NoJumpCooldownToggle changed to:', value)
    end
    })

    -- Optimized example: Instead of repeatedly using :FindFirstChild, store the result in a variable
    local part = workspace:FindFirstChild("MyPart")
    if part then
    -- Perform actions with the part
    print("Found part:", part.Name)
    end

    LeftGroupBox = Tabs.Movement:AddLeftGroupbox('Anti Slow')

    local gh = false -- Set to true to enable Anti-Slow, false to disable it.
    local debris = game:GetService("Debris") -- Access Debris service for cleanup
    local player = game.Players.LocalPlayer
    local toggleValue = false -- Store the current state of the toggle

    -- Replace the print statements with your NotifyLibrary.Notify call once it's defined
    local function notify(title, description)
    print(title .. ": " .. description)
    end

    -- Anti-slow logic that gets activated based on the toggle value
    local function antiSlowToggle(value)
    if value == true then
        gh = true

        -- Use RunService once and bind the logic only when enabled
        game:GetService('RunService'):BindToRenderStep("Anti-Slow", 0 , function()
            if player.Character then
                local bodyEffects = player.Character:WaitForChild("BodyEffects", 10)
                local movement = bodyEffects and bodyEffects:WaitForChild("Movement", 10)
                
                if movement then
                    -- Only check for the existence of these once and remove them if found
                    local noWalkSpeed = movement:FindFirstChild("NoWalkSpeed")
                    if noWalkSpeed then
                        noWalkSpeed:Destroy()
                    end
                    
                    local reduceWalk = movement:FindFirstChild("ReduceWalk")
                    if reduceWalk then
                        reduceWalk:Destroy()
                    end
                    
                    local noJumping = movement:FindFirstChild("NoJumping")
                    if noJumping then
                        noJumping:Destroy()
                    end
                end

                -- Use a more efficient way to check and modify the reload value
                if bodyEffects and bodyEffects.Reload and bodyEffects.Reload.Value == true then
                    bodyEffects.Reload.Value = false
                end
            end
        end)
    else
        gh = false

        -- Cleanup properly and unbind RunService
        game:GetService('RunService'):UnbindFromRenderStep("Anti-Slow")
    end
    end

    -- Integrate with the UI toggle, add it only once
    if not _G.AntiSlowToggle then
    LeftGroupBox:AddToggle('MyToggle', {
        Text = 'Anti Slow',
        Default = false, -- Default value (true / false)
        Tooltip = 'Removes any kind of slowness', -- Information shown when you hover over the toggle

        Callback = function(Value)
            toggleValue = Value
            antiSlowToggle(Value)  -- Call the anti-slow function based on the toggle's value
        end
    })

    _G.AntiSlowToggle = true
    end

    -- Listen for character respawn and reapply the anti-slow system
    player.CharacterAdded:Connect(function()
    antiSlowToggle(toggleValue)  -- Reapply the toggle value after respawn
    end)

    -- Initial setup on first load
    if player.Character then
    antiSlowToggle(toggleValue)  -- Apply the anti-slow based on the current toggle state
    end

RightGroupBox = Tabs.Misc:AddRightGroupbox('Skin Changer')

MyButton = RightGroupBox:AddButton({
    Text = 'Skin Changer',
    Func = function()
        	-- rev sound rbxassetid://1583819337

	local InventoryChanger = { Functions = {}, Selected = {}, Skins = {}, Owned = {} };


	do
		local Utilities = {};

-- Define the notification function
    function ShowNotification(title, text)
        local StarterGui = game:GetService("StarterGui")
        StarterGui:SetCore("SendNotification", {
            Title = title; -- Notification title
            Text = text; -- Notification message
            Duration = 5; -- Duration in seconds
        })
    end
    
    -- Define the custom print and notification function
    function cout(watermark, message)
        -- Print the message in the console
        print('['..watermark..'] DH skin changer made by affeboy')
        
        -- Show the notification
        ShowNotification("Skin Changer Loading", "Skibidi Changer")
    end
    
    -- Example usage
    cout("Skibidi Changer")           

		if not getgenv().InventoryConnections then
			getgenv().InventoryConnections = {};
		end;

		local players = game:GetService('Players');
		local client = players.LocalPlayer;

		local tween_service = game:GetService('TweenService');

		Utilities.AddConnection = function(signal, func)
			local connect = signal:Connect(func);

			table.insert(getgenv().InventoryConnections, { signal = signal, func = func, connect = connect });
			return connect;
		end;

		Utilities.Unload = function()
			for _, tbl in ipairs(getgenv().InventoryConnections) do
				if type(tbl) ~= 'table' then 
					tbl:Disconnect();
				end
			end;

			getgenv().InventoryConnections = {};
		end;

		Utilities.Unload();

		Utilities.Tween = function(args)
			local obj = args.obj or args.object;
			local prop = args.prop or args.properties;
			local duration = args.duration or args.time;
			local info = args.info or args.tween_info;
			local callback = args.callback;

			local tween = tween_service:Create(obj, duration and TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out) or info and TweenInfo.new(unpack(info)), prop);
			tween:Play();

			if callback then
				tween.Completed:Connect(callback);
			end;
		end;

		repeat task.wait() until client.Character:FindFirstChild('FULLY_LOADED_CHAR');

		local player_gui = client.PlayerGui;

		local main_gui = player_gui:WaitForChild('MainScreenGui');
		local crew = main_gui:WaitForChild('Crew');
		local bottom_left = crew:WaitForChild('BottomLeft').Frame;
		local skins_button = bottom_left:WaitForChild('Skins');

		local replicated_storage = game:GetService('ReplicatedStorage');
		local skin_modules = replicated_storage:WaitForChild('SkinModules');
		local meshes = skin_modules:WaitForChild('Meshes');

		local weapon_skins_gui = main_gui:WaitForChild('WeaponSkinsGUI');
		local gui_body_wrapper = weapon_skins_gui:WaitForChild('Body');
		local body_wrapper = gui_body_wrapper:WaitForChild('Wrapper');
		local skin_view = body_wrapper:WaitForChild('SkinView');
		local skin_view_frame = skin_view:WaitForChild('Frame');

		local guns = skin_view_frame:WaitForChild('Guns').Contents;
		local entries = skin_view_frame:WaitForChild('Skins').Contents.Entries;

		local Ignored = workspace.Ignored;
		local Siren = Ignored.Siren;
		local Radius = Siren.Radius;

		local regex = '%[(.-)%]';

		local newColorSequence = ColorSequence.new;
		local Color3fromRGB = Color3.fromRGB;
		local newCFrame = CFrame.new;
		local newColorSequenceKeypoint = ColorSequenceKeypoint.new;

		InventoryChanger.Skins = {
			['Aqua'] = {
				color = newColorSequence(Color3fromRGB(38, 96, 255)),
				guns = {
					['[Revolver]'] = {
						location = meshes.Aqua.rev,
						equipped = false,
						shoot_sound = 'rbxassetid://77877805688791',
						C0 = newCFrame(-0.105384827, 0.208259106, 0.00799560547, 1, -5.87381323e-27, 0, -5.87381323e-27, 1, 0, 0, 0, 1)
					},
					['[Double-Barrel SG]'] = {
						location = meshes.Aqua.db,
						equipped = false,
						shoot_sound = 'rbxassetid://137783932140587',
						C0 = newCFrame(0.204410553, 0.268578529, 0.0223999023, -1.00000572, 2.90278896e-27, 0, -2.90275526e-27, 0.999988556, 0, 0, 0, -0.999994278)
					},
					['RPG'] = {
						location = meshes.Aqua.rpg,
						equipped = false,
						shoot_sound = 'rbxassetid://136641811532905',
						C0 = newCFrame(-0.0422363281, 0.243108392, -0.243370056, -4.37113883e-08, 1.79695434e-18, -1, -5.64731205e-13, 1, -1.7722692e-18, 1, -5.64731205e-13, -4.37113883e-08)
					}
				}
			},
			['Arcade'] = {
				color = newColorSequence(Color3fromRGB(193, 92, 5)),
				guns = {
					['Revolver'] = {
						location = meshes.Arcade.Rev,
						equipped = false,
						shoot_sound = 'rbxassetid://110368146859788',
						C0 = newCFrame(0.0578613281, -0.0479719043, -0.00115966797, -1.00000405, 1.15596135e-16, 1.64267286e-30, -1.15596135e-16, 1, 2.99751983e-14, 1.66683049e-30, -2.99751983e-14, -1.00000405)
					},
					['Double-Barrel SG'] = {
						location = meshes.Arcade.DB,
						equipped = false,
						shoot_sound = 'rbxassetid://110368146859788',
						C0 = newCFrame(0.0578613281, -0.0479719043, -0.00115966797, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					}
				}
			},
			['Barbie'] = {
				guns = {
					['Revolver'] = {
						location = meshes.Barbie.Revol,
						equipped = false,
						C0 = newCFrame(0.0218505859, -0.0277693868, 0.0029296875, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['Double-Barrel SG'] = {
						location = meshes.Barbie.db,
						equipped = false,
						C0 = newCFrame(0.0457763672, 0.0508109927, 0.000579833984, -1, 0, 0, 0, 1, 0, 0, 0, -1)
					},
					['[RPG]'] = {
						location = meshes.Barbie.rpg,
						equipped = false,
						C0 = newCFrame(-0.0417480469, 0.253171682, 1.63067627, 4.37113883e-08, 3.46944654e-18, 1, -4.00865674e-13, 1, 3.48696912e-18, -1, 4.00865674e-13, 4.37113883e-08)
					},
					['[Flamethrower]'] = {
						location = meshes.Barbie.FT,
						equipped = false,
						C0 = newCFrame(-0.450744629, -0.232652962, 0.0798339844, -1, 0, 0, 0, 1, 0, 0, 0, -1)
					}
				}
			},
			['Butterfly'] = {
				color = newColorSequence(Color3fromRGB(255, 112, 236)),
				guns = {
					['[Revolver]'] = {
						location = meshes.Butterfly.Rev,
						equipped = false,
						shoot_sound = 'rbxassetid://135313010828275',
						C0 = newCFrame(0.0578613281, -0.0479719043, -0.00115966797, -1.00000405, 1.15596135e-16, 1.64267286e-30, -1.15596135e-16, 1, 2.99751983e-14, 1.66683049e-30, -2.99751983e-14, -1.00000405)
					},
					['[Double-Barrel SG]'] = {
						location = meshes.Butterfly.DB,
						equipped = false,
						shoot_sound = 'rbxassetid://91190443400371',
						C0 = newCFrame(0.36031723, 0.00864857435, -0.00158691406, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					}
				}
			},
		['CandyCane'] = {
			color = newColorSequence({newColorSequenceKeypoint(0, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(0.25, Color3.new(1, 0, 0)), ColorSequenceKeypoint.new(0.50, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(0.75, Color3.new(1, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}),
				guns = {
					['[Revolver]'] = {
						location = meshes.CandyCane.Rev,
						equipped = false,
						shoot_sound = 'rbxassetid://134944277318607',
						C0 = newCFrame(0.3, -0.0479719043, -0.00115966797, -1.00000405, 1.15596135e-16, 1.64267286e-30, -1.15596135e-16, 1, 2.99751983e-14, 1.66683049e-30, -2.99751983e-14, -1.00000405)
					},
				}
			},
			['PrestigeCandyCane'] = {
				color = newColorSequence({newColorSequenceKeypoint(0, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(0.25, Color3.new(0.5, 0, 0.5)), ColorSequenceKeypoint.new(0.50, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(0.75, Color3.new(0.5, 0, 0.5)), ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))}),
					guns = {
						['[Revolver]'] = {
							location = meshes.CandyCane.PrestigeRev,
							equipped = false,
							shoot_sound = 'rbxassetid://134944277318607',
							C0 = newCFrame(0.3, -0.0479719043, -0.00115966797, -1.00000405, 1.15596135e-16, 1.64267286e-30, -1.15596135e-16, 1, 2.99751983e-14, 1.66683049e-30, -2.99751983e-14, -1.00000405)
						},
					}
				},
			['Cat'] = {
				color = newColorSequence(Color3fromRGB(247, 129, 255)),
				guns = {
					['[Revolver]'] = {
						location = meshes.Cat.Rev,
						equipped = false,
						shoot_sound = 'rbxassetid://18544605344',
						C0 = newCFrame(-0.0353851318, 0.0917409062, -0.001953125, 1, 0, 0, 0, 1, -3.25059848e-30, 0, -3.25059848e-30, 1)
					},
					['[Double-Barrel SG]'] = {
						location = meshes.Cat.db,
						equipped = false,
						shoot_sound = 'rbxassetid://18544603790',
						C0 = newCFrame(-0.321357727, -0.021577239, -0.000366210938, -1, 0, 0, 0, 1, -3.25059773e-30, 0, 3.25059773e-30, -1)
					},
					['[Drum-Shotgun]'] = {
						location = meshes.Cat.drum,
						equipped = false,
						shoot_sound = 'rbxassetid://18544602257',
						C0 = newCFrame(-0.0637664795, 0.164270639, 0.00408935547, -1, 1.62920685e-07, 1.79568244e-22, 1.62920685e-07, 1, -2.44927253e-16, 1.99519584e-23, -2.44929794e-16, -1)
					},
					['RPG'] = {
						location = meshes.Cat.rpg,
						equipped = false,
						shoot_sound = 'rbxassetid://18544610124',
						C0 = newCFrame(-0.0182495117, 0.288909316, -0.0680465698, -4.37113883e-08, 4.54747351e-13, -1, 0.00000192143443, 1, -5.3873594e-13, 1, 0.00000192143443, -4.37113883e-08)
					}
				}
			},
			['Hoodmas'] = {
				guns = {
					['Revolver'] = {
						location = meshes.Hoodmas.revolver,
						equipped = false,
						C0 = newCFrame(0.00862121582, -0.000740110874, -0.0009765625, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					}
				}
			},
			['Ice'] = {
				guns = {
					['Revolver'] = {
						location = meshes.Ice.rev,
						equipped = false,
						C0 = newCFrame(-0.0299072266, 0.0293902755, -0.0108032227, 1, 0, 0, 0, 0, 1, 0, -1, 0)
					}
				}
			},
			['Iced Out'] = {
				guns = {
					['Revolver'] = {
						location = meshes.IcedOut.rev,
						equipped = false,
						C0 = newCFrame(-0.0419578552, -0.0496253371, -0.0009765625, 0, 0, -1, 0, 1, 0, 1, 0, 0)
					}
				}
			},
			['Cupid'] = {
				color = newColorSequence(Color3fromRGB(255, 187, 239)),
				guns = {
					['Revolver'] = {
					location = meshes.Cupid.rev,
					equipped = false,
					shoot_sound = 'rbxassetid://16288431925',
					C0 = newCFrame(0.0240020752, 0.229963183, -0.0170898438, 0, 0, -1, 0, 1, 0, 1, 0, 0)
					},
					['Double-Barrel SG'] = {
						location = meshes.Cupid.db,
						equipped = false,
						shoot_sound = 'rbxassetid://16288431925',
						C0 = newCFrame(-0.0375976562, 0.048615396, 0.00555419922, 0, 0, 1, 0, 0.999998212, 0, -1, 0, 0)
					}
				}
			},
			['Emerald'] = {
				color = newColorSequence(Color3fromRGB(0, 255, 0)),
				guns = {
					['Revolver'] = {
						location = meshes.Emerald.Rev,
						equipped = false,
						shoot_sound = 'rbxassetid://119530007559356',
						C0 = newCFrame(0.200012207, -0.0815875828, 0.0110473633, 0, 0, -1, 0, 1, 0, 1, 0, 0)
					},
				}
			},
			['Etheral'] = {
				color = newColorSequence(Color3fromRGB(255, 0, 255)),
				guns = {
					['Revolver'] = {
						location = meshes.Etheral.Rev,
						equipped = false,
						shoot_sound = 'rbxassetid://15399809021',
						C0 = newCFrame(0.0255432129, -0.0427106023, 0.0140380859, -1, 0, 0, 0, 1, 0, 0, 0, -1)
					},
				}
			},
			['Grumpy'] = {
				color = newColorSequence(Color3fromRGB(0, 255, 42)),
				guns = {
					['Revolver'] = {
						location = meshes.Grumpy.rev,
						equipped = false,
						shoot_sound = 'rbxassetid://78903650873779',
						C0 = newCFrame(0.083902359, -0.000752657652, -0.00531005859, 0, 0, -1, 0, 1, 0, 1, 0, 0)
					},
				}
			},
			['Web-Hero'] = {
				color = newColorSequence(Color3fromRGB(255, 255, 255)),
				guns = {
					['Revolver'] = {
						location = meshes.HERO.HeroWeb,
						equipped = false,
						shoot_sound = 'rbxassetid://13814390550',
						C0 = newCFrame(-0.0891418457, -0.0215809345, -0.0041809082, -1.99520325e-23, -1.62920685e-07, 1, 2.44929371e-16, 1, 1.62920685e-07, -1, 2.44929371e-16, 1.99520294e-23)
					}
				}
			},
			
			['Mystical'] = {
				color = newColorSequence(Color3fromRGB(255, 39, 24)),
				guns = {
					['[Revolver]'] = {
						location = meshes.Mystical.Revolver,
						equipped = false,
						shoot_sound = 'rbxassetid://14489866118',
						C0 = newCFrame(-0.015838623, -0.0802496076, 0.00772094727, 1, 0, 4.37113883e-08, 0, 1, 0, -4.37113883e-08, 0, 1)
					},
				}
			},
			['CyanPack'] = {
				mesh_location = meshes.CyanPack,
				guns = {
					['[TacticalShotgun]'] = {
						location = meshes.CyanPack.Cloud,
						equipped = false,
						shoot_sound = 'rbxassetid://14056055126',
						C0 = newCFrame(0.0441589355, -0.0269355774, -0.000701904297, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[Double-Barrel SG]'] = {
						location = meshes.CyanPack.DB,
						equipped = false,
						shoot_sound = 'rbxassetid://14056053588',
						C0 = newCFrame(-0.00828552246, 0.417651355, -0.00537109375, 4.18358377e-06, -1.62920685e-07, 1, 3.4104116e-13, 1, 1.62920685e-07, -1, 3.41041052e-13, -4.18358377e-06)
					},
					['[Revolver]'] = {
						location = meshes.CyanPack.Devil,
						equipped = false,
						shoot_sound = 'rbxassetid://14056056444',
						C0 = newCFrame(0.0185699463, 0.293397784, -0.00256347656, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					}
				}
			},
			['Cartoon'] = {
				color = newColorSequence(Color3fromRGB(99, 234, 255)),            
				guns = {
					['[Flamethrower]'] = {
						location = meshes.Cartoon.CartoonFT,
						equipped = false,
						C0 = newCFrame(-0.272186279, 0.197086751, 0.0440063477, -1, 4.8018768e-07, 8.7078952e-08, 4.80187623e-07, 1, -3.54779985e-07, -8.70791226e-08, -3.54779957e-07, -1)
					},
					['[Revolver]'] = {
						location = meshes.Cartoon.CartoonRev,
						equipped = false,
						shoot_sound = 'rbxassetid://14221101923',
						C0 = newCFrame(-0.015411377, 0.0135096312, 0.00338745117, 1.00000095, 3.41326549e-13, 2.84217399e-14, 3.41326549e-13, 1.00000191, -9.89490712e-10, 2.84217399e-14, -9.89490712e-10, 1.00000191)
					},
					['[Double-Barrel SG]'] = {
						location = meshes.Cartoon.DBCartoon,
						equipped = false,
						shoot_sound = 'rbxassetid://14220912852',
						C0 = newCFrame(0.00927734375, -0.00691050291, 0.000732421875, -1, -2.79396772e-08, -9.31322797e-10, -2.79396772e-08, 1, 1.42607872e-08, 9.31322575e-10, 1.42607872e-08, -1)
					},
					['[RPG]'] = {
						location = meshes.Cartoon.RPGCartoon,
						equipped = false,
						C0 = newCFrame(-0.0201721191, 0.289476752, -0.0727844238, 4.37113883e-08, 6.58276836e-37, 1, -5.72632016e-14, 1, 2.50305399e-21, -1, 5.72632016e-14, 4.37113883e-08)
					},
				}
			},
			['Dragon'] = {
				color = newColorSequence(Color3.new(1, 0, 0)),
				guns = {
					['[Revolver]'] = {
						location = meshes.Dragon.DragonRev,
						equipped = false,
						shoot_sound = 'rbxassetid://14217797127',
						C0 = newCFrame(0.0384216309, 0.0450432301, -0.000671386719, 1.87045402e-31, 4.21188801e-16, -0.99999994, 1.77635684e-15, 1, -4.21188827e-16, 1, 1.77635684e-15, -1.87045413e-31)
					},
					['[Double-Barrel SG]'] = {
						location = meshes.Dragon.DBDragon,
						equipped = false,
						C0 = newCFrame(-0.123794556, 0.0481165648, 0.00048828125, 7.14693442e-07, 3.13283705e-10, 1, -4.56658222e-09, 1, -3.13281678e-10, -1, -4.56658533e-09, 7.14693442e-07)
					}
				}
			},
			['Tact'] = {
				color = newColorSequence(Color3.new(1, 0.3725490196, 0.3725490196)),
				guns = {
					['[Revolver]'] = {
						location = meshes.Tact.Rev,
						equipped = false,
						shoot_sound = 'rbxassetid://13850086195',
						C0 = newCFrame(-0.318634033, -0.055095911, 0.00491333008, 0, 0, 1, 0, 1, 0, -1, 0, 0)
					},
					['[Double-Barrel SG]'] = {
						location = meshes.Tact.DB,
						equipped = false,
						shoot_sound = 'rbxassetid://13988900457',
						C0 = newCFrame(-0.0701141357, -0.0506889224, -0.0826416016, 0, 0, 1, 0, 1, 0, -1, 0, 0)
					},
					['[TacticalShotgun]'] = {
						location = meshes.Tact.Tact,
						equipped = false,
						shoot_sound = 'rbxassetid://13850091297',
						C0 = newCFrame(-0.0687713623, -0.0684046745, 0.12701416, 0, 0, 1, 0, 1, 0, -1, 0, 0)
					},
					['[SMG]'] = {
						location = meshes.Tact.Uzi,
						equipped = false,
						shoot_sound = 'rbxassetid://13850089197',
						C0 = newCFrame(0.0408782959, 0.0827783346, -0.0423583984, -1, 0, 0, 0, 1, 0, 0, 0, -1)
					},
					['[Shotgun]'] = {
						location = meshes.Tact.Shotgun,
						equipped = false,
						shoot_sound = 'rbxassetid://13988901716',
						C0 = newCFrame(-0.0610046387, 0.171100497, -0.00495910645, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[Silencer]'] = {
						location = meshes.Tact.Silencer,
						equipped = false,
						shoot_sound = 'rbxassetid://13850087044',
						C0 = newCFrame(0.0766601562, -0.0350288749, -0.648864746, 1, 0, -4.37113883e-08, 0, 1, 0, 4.37113883e-08, 0, 1)
					}
				}
			},
			['Shadow'] = {
				color = newColorSequence(Color3.new(0.560784, 0.470588, 1), Color3.new(0.576471, 0.380392, 1)),
				guns = {
					['[Revolver]'] = {
						location = meshes.Shadow.RevolverGhost,
						equipped = false,
						C0 = newCFrame(1.52587891e-05, 0, 0, 1, 0, 8.74227766e-08, 0, 1, 0, -8.74227766e-08, 0, 1)
					},
					['[Double-Barrel SG]'] = {
						location = meshes.Shadow.DoubleBGhost,
						equipped = false,
						C0 = newCFrame(0.0250015259, -0.077037394, 0, 1, 0, 0, 0, 0.999998331, 0, 0, 0, 1)
					},
					['[AK47]'] = {
						location = meshes.Shadow.AK47Ghost,
						equipped = false,
						C0 = newCFrame(-0.750015259, 4.76837158e-07, -3.05175781e-05, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[SilencerAR]'] = {
						location = meshes.Shadow.ARGhost,
						equipped = false,
						C0 = newCFrame(0.116256714, 0.0750004649, 6.10351562e-05, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[AUG]'] = {
						location = meshes.Shadow.AUGGhost,
						equipped = false,
						C0 = newCFrame(-7.62939453e-06, 0.0499991775, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[DrumGun]'] = {
						location = meshes.Shadow.DrumgunGhost,
						equipped = false,
						C0 = newCFrame(1.14440918e-05, 0, 0, 1, 0, 8.74227766e-08, 0, 1, 0, -8.74227766e-08, 0, 1)
					},
					['[Flamethrower]'] = {
						location = meshes.Shadow.FlamethrowerGhost,
						equipped = false,
						C0 = newCFrame(-0.219947815, 0.339559376, 0.000274658203, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[Glock]'] = {
						location = meshes.Shadow.GlockGhost,
						equipped = false,
						C0 = newCFrame(0, 0, -0.200004578, 1, 0, 4.37113883e-08, 0, 1, 0, -4.37113883e-08, 0, 1)
					},
					['[LMG]'] = {
						location = meshes.Shadow.LMGGhost,
						equipped = false,
						C0 = newCFrame(0.374502182, -0.25, -0.25, -1, 0, -1.31134158e-07, 0, 1, 0, 1.31134158e-07, 0, -1)
					},
					['[P90]'] = {
						location = meshes.Shadow.P90Ghost,
						equipped = false,
						C0 = newCFrame(6.86645508e-05, 0.000218153, 3.05175781e-05, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[RPG]'] = {
						location = meshes.Shadow.RPGGhost,
						equipped = false,
						C0 = newCFrame(0.000122070312, 0.0625389814, 0.00672149658, 1, 0, -8.74227766e-08, 5.00610797e-21, 1, 5.72632016e-14, 8.74227766e-08, 5.72632016e-14, 1)
					},
					['[Rifle]'] = {
						location = meshes.Shadow.RifleGhost,
						equipped = false,
						C0 = newCFrame(0.000244140625, -0.100267321, -9.15527344e-05, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[SMG]'] = {
						location = meshes.Shadow.SMGGhost,
						equipped = false,
						C0 = newCFrame(-1.14440918e-05, 1.78813934e-07, -0.0263671875, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[Shotgun]'] = {
						location = meshes.Shadow.ShotgunGhost,
						equipped = false,
						C0 = newCFrame(3.05175781e-05, 0.199999928, 3.81469727e-06, -1, 0, -4.37113883e-08, 0, 1, 0, 4.37113883e-08, 0, -1)
					},
					['[TacticalShotgun]'] = {
						location = meshes.Shadow.TacticalShotgunGhost,
						equipped = false,
						C0 = newCFrame(-0.148262024, 0, 0, 1, 0, 8.74227766e-08, 0, 1, 0, -8.74227766e-08, 0, 1)
					}
				}
			},
			['Golden Age'] = {
				color = newColorSequence(Color3.fromHSV(0.89166666666, 0.24, 1)),
				guns = {
					['[Revolver]'] = {
						location = meshes.GoldenAge.Revolver,
						equipped = false,
						C0 = newCFrame(0.0295257568, 0.0725820661, -0.000946044922, 1, -4.89858741e-16, -7.98081238e-23, 4.89858741e-16, 1, 3.2584137e-07, -7.98081238e-23, -3.2584137e-07, 1),
						shoot_sound = 'rbxassetid://1898322396'
					},
					['[Double-Barrel SG]'] = {
						location = meshes.GoldenAge['Double Barrel'],
						equipped = false,
						shoot_sound = 'rbxassetid://4915503055',
						C0 = newCFrame(-0.00664520264, 0.0538104773, 0.0124816895, -1, 4.89858741e-16, 7.98081238e-23, 4.89858741e-16, 1, 3.2584137e-07, 7.98081238e-23, 3.2584137e-07, -1)
					}
				}
			},
			['Red Skull'] = {
				color = newColorSequence({newColorSequenceKeypoint(0, Color3.new(1, 0, 0)), ColorSequenceKeypoint.new(0.25, Color3.new(1, 0, 0)), ColorSequenceKeypoint.new(0.50, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(0.75, Color3.new(1, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(1, 0, 0))}),
				guns = {
					['[Revolver]'] = {
						location = meshes.RedSkull.RedSkullRev,
						equipped = false,
						shoot_sound = 'rbxassetid://13487882844',
						C0 = newCFrame(-0.0043258667, 0.0084195137, -0.00238037109, 0, 0, -1, 0, 1, 0, 1, 0, 0)
					},
					['[Shotgun]'] = {
						location = meshes.RedSkull.RedSkullShotgun,
						equipped = false,
						C0 = newCFrame(-0.00326538086, 0.0239292979, -0.039352417, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08)
					},
					['[Double-Barrel SG]'] = {
						location = meshes.RedSkull.RedSkullDB,
						equipped = false,
						C0 = newCFrame(-0.0143432617, -0.151709318, 0.00820922852, -1, 0, 0, 0, 1, 0, 0, 0, -1)
					},
					['[RPG]'] = {
						location = meshes.RedSkull.RedSkullRPG,
						equipped = false,
						shoot_sound = 'rbxassetid://12222095',
						C0 = newCFrame(-0.00149536133, 0.254377961, 0.804840088, -1, 0, 4.37113883e-08, -2.50305399e-21, 1, -5.72632016e-14, -4.37113883e-08, 5.72632016e-14, -1)
					}
				}
			},
			--[[['Galaxy'] = {
				border_color = newColorSequence(Color3.new(0, 0, 1)),
				particle = {
					properties = {
						Color = ColorSequence.new({
							ColorSequenceKeypoint.new(0, Color3.new(0.419608, 0.376471, 1)),
							ColorSequenceKeypoint.new(1, Color3.new(0.419608, 0.376471, 1))
						}),
						Name = 'Galaxy',
						Size = NumberSequence.new({
							NumberSequenceKeypoint.new(0, 0.5),
							NumberSequenceKeypoint.new(0.496, 1.2),
							NumberSequenceKeypoint.new(1, 0.5)
						}),
						Squash = NumberSequence.new({
							NumberSequenceKeypoint.new(0, 0),
							NumberSequenceKeypoint.new(0.173364, 0.525),
							NumberSequenceKeypoint.new(0.584386, -1.7625),
							NumberSequenceKeypoint.new(0.98163, 0.0749998),
							NumberSequenceKeypoint.new(1, 0)
						}),
						Transparency = NumberSequence.new({
							NumberSequenceKeypoint.new(0, 0),
							NumberSequenceKeypoint.new(0.107922, 1),
							NumberSequenceKeypoint.new(0.391504, 0.25),
							NumberSequenceKeypoint.new(0.670494, 0.78125),
							NumberSequenceKeypoint.new(0.845006, 0),
							NumberSequenceKeypoint.new(1, 1)
						}),
						Texture = 'rbxassetid://7422600824',
						ZOffset = 1,
						LightEmission = 0.7,
						Lifetime = NumberRange.new(1, 1),
						Rate = 3,
						Rotation = NumberRange.new(0, 360),
						RotSpeed = NumberRange.new(0, 15),
						Speed = NumberRange.new(1, 1),
						SpreadAngle = Vector2.new(-45, 45)
					}
				},
				guns = {
					['[Revolver]'] = {
						texture = 'rbxassetid://9370936730'
					},
					['[TacticalShotgun]'] = {
						texture = 'rbxassetid://9402279010'
					}
				}
			},]]
			['Kitty'] = {
				color = newColorSequence(Color3.new(1, 0.690196, 0.882353), Color3.new(1, 0.929412, 0.964706)),
				guns = {
					['[Revolver]'] = {
						location = meshes.Kitty.KittyRevolver,
						equipped = false,
						shoot_sound = 'rbxassetid://13483022860',
						C0 = newCFrame(0.0310440063, 0.0737591386, 0.0226745605, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[Flamethrower]'] = {
						location = meshes.Kitty.KittyFT,
						equipped = false,
						C0 = newCFrame(-0.265670776, 0.115545571, 0.00997924805, -1, 9.74078034e-21, 5.47124086e-13, 9.74092898e-21, 1, 3.12638804e-13, -5.47126309e-13, 3.12638804e-13, -1)
					},
					['[RPG]'] = {
						location = meshes.Kitty.KittyRPG,
						equipped = false,
						C0 = newCFrame(0.0268554688, 0.0252066851, 0.117408752, -1, 2.51111284e-40, 4.37113883e-08, -3.7545812e-20, 1, -8.58948004e-13, -4.37113883e-08, 8.58948004e-13, -1)
					},
					['[Shotgun]'] = {
						location = meshes.Kitty.KittyShotgun,
						equipped = false,
						shoot_sound = 'rbxassetid://13483035672',
						C0 = newCFrame(0.0233459473, 0.223892093, -0.0213623047, 4.37118963e-08, -6.53699317e-13, 1, 3.47284736e-20, 1, 7.38964445e-13, -0.999997139, 8.69506734e-21, 4.37119354e-08)
					}
				}
			},
			['Toy'] = {
				mesh_location = meshes.Toy,
				color = newColorSequence({newColorSequenceKeypoint(0, Color3.new(0, 1, 0)), ColorSequenceKeypoint.new(0.5, Color3.new(0.666667, 0.333333, 1)), ColorSequenceKeypoint.new(1, Color3.new(1, 0.666667, 0))}),
				guns = {
					['[Revolver]'] = {
						location = meshes.Toy.RevolverTOY,
						equipped = false,
						shoot_sound = 'rbxassetid://13613387797',
						C0 = newCFrame(-0.0250854492, -0.144362092, -0.00266647339, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[LMG]'] = {
						location = meshes.Toy.LMGTOY,
						equipped = false,
						shoot_sound = 'rbxassetid://13613391426',
						C0 = newCFrame(-0.285247803, -0.0942560434, -0.270412445, 1, 0, 4.37113883e-08, 0, 1, 0, -4.37113883e-08, 0, 1)
					},
					['[Double-Barrel SG]'] = {
						location = meshes.Toy.DBToy,
						equipped = false,
						shoot_sound = 'rbxassetid://13613388954',
						C0 = newCFrame(-0.0484313965, -0.00164616108, -0.0190467834, -1, 0, 0, 0, 1, 0, 0, 0, -1)
					},
					['[RPG]'] = {
						location = meshes.Toy.RPGToy,
						equipped = false,
						shoot_sound = 'rbxassetid://13613389876',
						C0 = newCFrame(0.00121307373, 0.261434197, -0.318969727, 1, 2.5768439e-12, -4.37113883e-08, 2.57684412e-12, 1, 6.29895225e-12, 4.37113883e-08, 6.29895225e-12, 1)
					}
				}
			},
			['Galactic'] = {
				color = newColorSequence(Color3fromRGB(255, 0, 0)),
				guns = {
					['[Revolver]'] = {
						location = meshes.Galactic.galacticRev,
						equipped = false,
						shoot_sound = 'rbxassetid://13633362452',
						C0 = newCFrame(-0.049041748, 0.0399398208, -0.00772094727, 0, 0, 1, 0, 1, 0, -1, 0, 0)
					},
					['[TacticalShotgun]'] = {
						location = meshes.Galactic.TacticalGalactic,
						equipped = false,
						C0 = newCFrame(-0.0411682129, -0.0281000137, 0.00103759766, 0, 5.68434189e-14, 1, -1.91456822e-13, 1, 5.68434189e-14, -1, 1.91456822e-13, 0)
					}
				}
			},
			['Water'] = {
				color = newColorSequence(Color3.new(0, 1, 1), Color3.new(0.666667, 1, 1)),
				guns = {
					['[Revolver]'] = {
						location = meshes.Water.WaterGunRevolver,
						equipped = false,
						shoot_sound = 'rbxassetid://13814989290',
						C0 = newCFrame(-0.0440063477, 0.028675437, -0.00469970703, 0, 0, -1, 0, 1, 0, 1, 0, 0)
					},
					['[TacticalShotgun]'] = {
						location = meshes.Water.TactWater,
						equipped = false,
						shoot_sound = 'rbxassetid://13814991449',
						C0 = newCFrame(0.0238037109, -0.00912904739, 0.00485229492, 0, 0, 1, 0, 1, 0, -1, 0, 0)
					},
					['[Double-Barrel SG]'] = {
						location = meshes.Water.DBWater,
						equipped = false,
						shoot_sound = 'rbxassetid://13814990235',
						C0 = newCFrame(-0.0710754395, 0.00169920921, -0.0888671875, 0, 0, 1, 0, 1, 0, -1, 0, 0)
					},
					['[Flamethrower]'] = {
						location = meshes.Water.FTWater,
						equipped = false,
						C0 = newCFrame(0.0941314697, 0.593509138, 0.0191040039, -1, 0, 0, 0, 1, 0, 0, 0, -1)
					}
				}
			},
			['GPO'] = {
				color = newColorSequence(Color3.new(1, 0.666667, 0)),
				guns = {
					['[RPG]'] = {
						location = meshes.GPO.Bazooka,
						equipped = false,
						C0 = newCFrame(-0.0184631348, 0.0707798004, 0.219360352, 4.37113883e-08, 1.07062025e-23, 1, -5.75081297e-14, 1, 1.14251725e-36, -1, 5.70182736e-14, 4.37113883e-08)
					},
					['[TacticalShotgun]'] = {
						location = meshes.GPO.MaguTact,
						equipped = false,
						shoot_sound = 'rbxassetid://13998711419',
						C0 = newCFrame(-0.282501221, 0.0472121239, -0.0065612793, -6.60624482e-06, 1.5649757e-08, -1, -5.68434189e-14, 1, -1.56486806e-08, 1, 5.68434189e-14, -6.60624482e-06)
					},
					['[Rifle]'] = {
						location = meshes.GPO.Rifle,
						equipped = false,
						C0 = newCFrame(-0.208007812, 0.185256913, 0.000610351562, -3.37081539e-14, 1.62803403e-07, -1.00000012, -8.74227695e-08, 0.999999881, 1.63036205e-07, 1, 8.74227766e-08, -1.94552524e-14)
					}
				}
			},
			['GPOII'] = {
				color = newColorSequence(Color3.new(0.0, 0.502, 1.0), Color3.new(1, 1, 1)),
				guns = {
					['[Double-Barrel SG]'] = {
						location = meshes.GPOII.DB,
						equipped = false,
						shoot_sound = 'rbxassetid://98362382710844',
						C0 = newCFrame(0.15, -0.0815875828, 0.0110473633, 1, 0, 0, 0, 1, 0, 0, 0, -1)
					},            
				}
			},

			['BIT8'] = {
				color = newColorSequence(Color3.fromHSV(0.5, 0.9, 1)),
				guns = {
					['[Revolver]'] = {
						location = meshes.BIT8.RPixel,
						equipped = false,
						shoot_sound = 'rbxassetid://13326584088',
						C0 = newCFrame(0.0261230469, -0.042888701, 0.00260925293, -1, 1.355249e-20, -3.55271071e-15, 1.355249e-20, 1, -1.81903294e-27, 3.55271071e-15, -1.81903294e-27, -1)
					},
					['[Flamethrower]'] = {
						location = meshes.BIT8.FTPixel,
						equipped = false,
						C0 = newCFrame(-0.0906066895, -0.0161985159, -0.0117645264, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[Double-Barrel SG]'] = {
						location = meshes.BIT8.DBPixel,
						equipped = false,
						shoot_sound = 'rbxassetid://13326578563',
						C0 = newCFrame(-0.240386963, -0.127295256, -0.00776672363, 0, 0, -1, 0, 1, 0, 1, 0, 0)
					},
					['[RPG]'] = {
						location = meshes.BIT8.RPGPixel,
						equipped = false,
						C0 = newCFrame(0.0102081299, 0.0659624338, 0.362945557, 4.37113883e-08, 0, 1, -5.72632016e-14, 1, 2.50305399e-21, -1, 5.72632016e-14, 4.37113883e-08)
					}
				}
			},
			['Electric'] = {
				color = newColorSequence(Color3fromRGB(0, 234, 255)),
				guns = {
					['[Revolver]'] = {
						location = meshes.Electric.ElectricRevolver,
						equipped = false,
						C0 = newCFrame(0.185462952, 0.0312761068, 0.000610351562, 0, 0, -1, 0, 1, 0, 1, 0, 0)
					},
					['[DrumGun]'] = {
						location = meshes.Electric.ElectricDrum,
						equipped = false,
						C0 = newCFrame(-0.471969604, 0.184426308, 0.075378418, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[SMG]'] = {
						location = meshes.Electric.ElectricSMG,
						equipped = false,
						C0 = newCFrame(-0.0620956421, 0.109580457, 0.00729370117, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[Shotgun]'] = {
						location = meshes.Electric.ElectricShotgun,
						equipped = false,
						C0 = newCFrame(6.10351562e-05, 0.180232108, -0.624732971, 1, 0, -4.37113883e-08, 0, 1, 0, 4.37113883e-08, 0, 1)
					},
					['[Rifle]'] = {
						location = meshes.Electric.ElectricRifle,
						equipped = false,
						C0 = newCFrame(0.181793213, -0.0415201783, 0.00421142578, 1.8189894e-12, 6.6174449e-24, 1, 7.27595761e-12, 1, 6.6174449e-24, -1, -7.27595761e-12, -1.8189894e-12)
					},
					['[P90]'] = {
						location = meshes.Electric.ElectricP90,
						equipped = false,
						C0 = newCFrame(0.166191101, -0.225557804, -0.0075378418, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[LMG]'] = {
						location = meshes.Electric.ElectricLMG,
						equipped = false,
						C0 = newCFrame(0.142379761, 0.104723871, -0.303771973, -1, 0, -4.37113883e-08, 0, 1, 0, 4.37113883e-08, 0, -1)
					},
					['[Flamethrower]'] = {
						location = meshes.Electric.ElectricFT,
						equipped = false,
						C0 = newCFrame(-0.158782959, 0.173444271, 0.00640869141, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[Double-Barrel SG]'] = {
						location = meshes.Electric.ElectricDB,
						equipped = false,
						C0 = newCFrame(0.0755996704, -0.0420352221, 0.00543212891, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[Glock]'] = {
						location = meshes.Electric.ElectricGlock,
						equipped = false,
						C0 = newCFrame(-0.00207519531, 0.0318723917, 0.0401077271, 0, 0, -1, 0, 1, 0, 1, 0, 0)
					},
					['[AUG]'] = {
						location = meshes.Electric.ElectricAUG,
						equipped = false,
						C0 = newCFrame(0.331085205, -0.0117390156, 0.00155639648, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[SilencerAR]'] = {
						location = meshes.Electric.ElectricAR,
						equipped = false,
						C0 = newCFrame(-0.16942215, 0.0508521795, 0.0669250488, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[AK47]'] = {
						location = meshes.Electric.ElectricAK,
						equipped = false,
						C0 = newCFrame(0.155792236, 0.18423444, 0.00140380859, 0, 0, -1, 0, 1, 0, 1, 0, 0)
					}
				}
			},
			['Halloween23'] = {
				color = newColorSequence(Color3fromRGB(255, 85, 88)),
				guns = {
					['[Revolver]'] = {
						equipped = false,
						location = meshes.Halloween.Rev,
						shoot_sound = 'rbxassetid://14924285721',
						C0 = newCFrame(-0.0257873535, -0.0117108226, -0.00671386719, -1, 0, 0, 0, 1, 0, 0, 0, -1)
					},
					['[Double-Barrel SG]'] = {
						equipped = false,
						location = meshes.Halloween.DB,
						shoot_sound = 'rbxassetid://14924282919',
						C0 = newCFrame(-0.00271606445, -0.0485508144, 0.000732421875, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					},
					['[Shotgun]'] = {
						equipped = false,
						location = meshes.Halloween.SG,
						shoot_sound = 'rbxassetid://14924268000',
						C0 = newCFrame(0.00573730469, 0.294590235, -0.115814209, 0, 0, -1, 0, 1, 0, 1, 0, 0)
					},
					['[TacticalShotgun]'] = {
						equipped = false,
						location = meshes.Halloween.Tact,
						shoot_sound = 'rbxassetid://14924256223',
						C0 = newCFrame(-0.0715637207, -0.0843618512, 0.00582885742, -1, 0, 0, 0, 1, 0, 0, 0, -1)
					}
				}
			},
			['Soul'] = {
			color = newColorSequence({newColorSequenceKeypoint(0, Color3.new(1, 0, 0)), ColorSequenceKeypoint.new(0.5, Color3.new(0.7, 0.3, 0.1)), ColorSequenceKeypoint.new(1, Color3.new(1, 0, 0))}),
				guns = {
					['[Revolver]'] = {
						equipped = false,
						location = meshes.Soul.rev,
						shoot_sound = 'rbxassetid://14909152822',
						C0 = CFrame.new(-0.0646362305, 0.2725088, -0.00242614746, 0, 0, -1, 0, 1, 0, 1, 0, 0)
					},
					['[Double-Barrel SG]'] = {
						equipped = false,
						location = meshes.Soul.db,
						shoot_sound = 'rbxassetid://14909164664',
						C0 = CFrame.new(0.405822754, 0.0975035429, -0.00506591797, -1, 0, 0, 0, 1, 0, 0, 0, -1)
					},
					['[TacticalShotgun]'] = {
						equipped = false,
						location = meshes.Soul.tact,
						shoot_sound = 'rbxassetid://14918188609',
						C0 = CFrame.new(-0.347473145, 0.0268714428, 0.00553894043, 1, 0, 0, 0, 1, 0, 0, 0, 1)
					}
				}
			},        
			['Heaven'] = {
				color = newColorSequence(Color3.new(1, 1, 1)),
				guns = {
					['[Revolver]'] = {
						equipped = false,
						location = meshes.Heaven.Revolver,
						shoot_sound = 'rbxassetid://14489857436',
						C0 = newCFrame(-0.0829315186, -0.0831851959, -0.00296020508, -0.999999881, 2.94089277e-17, 8.27179774e-25, -2.94089277e-17, 0.999999881, 6.85215614e-16, 8.27179922e-25, -6.85215667e-16, -1)
					},
					['[Double-Barrel SG]'] = {
						equipped = false,
						location = meshes.Heaven.DB,
						shoot_sound = 'rbxassetid://14489852879',
						C0 = newCFrame(-0.0303955078, 0.022110641, 0.00296020508, -0.999997139, -7.05812226e-16, 7.85568618e-30, 7.05812226e-16, 0.999997139, -2.06501178e-14, 6.44518474e-30, 2.06501042e-14, -0.999999046)
					}
				}
			},
			['Void'] = {
				color = newColorSequence(Color3fromRGB(93, 0, 255)),
				guns = {
					['[Revolver]'] = {
						equipped = false,
						location = meshes.Void.rev,
						shoot_sound = 'rbxassetid://14756584250',
						C0 = newCFrame(-0.00503540039, 0.0082899332, -0.00164794922, 0, 0, -1, 0, 1, 0, 1, 0, 0)
					},
					['[TacticalShotgun]'] = {
						equipped = false,
						location = meshes.Void.tact,
						C0 = newCFrame(0.0505371094, -0.0487936139, 0.00158691406, 0, 0, 1, 0, 1, 0, -1, 0, 0)
					}
				}
			},
			['DH-Stars II'] = {
				color = newColorSequence(Color3.new(1, 0.749, 0), Color3.new(0.9843, 1, 0)),
				guns = {
					['[Revolver]'] = {
						equipped = false,
						location = meshes.Popular.STARSREV,
						shoot_sound ='rbxassetid://14489869355',
						C0 = newCFrame(0.0578613281, -0.0479719043, -0.00115966797, -1.00000405, 1.15596135e-16, 1.64267286e-30, -1.15596135e-16, 1, 2.99751983e-14, 1.66683049e-30, -2.99751983e-14, -1.00000405)
					}
				}
			},
			['DH-Verified'] = {
				color = newColorSequence(Color3.new(0, 0.2157, 1), Color3.new(0, 0.4314, 1)),
				guns = {
					['[Revolver]'] = {
						equipped = false,
						location = meshes.Popular.VERIFIEDREV,
						shoot_sound =  'rbxassetid://14489870949',
						C0 = newCFrame(0.049407959, -0.0454721451, 0.00158691406, -1, 0, 0, 0, 1, 2.22044605e-15, 0, -2.22044605e-15, -1)
					}
				}
			},
			['Candy'] = {
				color = newColorSequence(Color3fromRGB(210, 160, 255)),
				guns = {
					['[Revolver]'] = {
						equipped = false,
						location = meshes.Candy.RevolverCandy,
						shoot_sound = 'rbxassetid://14723119555',
						C0 = newCFrame(-0.106658936, -0.0681198835, 0.00198364258, 0, 0, -1, 0, 1, 0, 1, 0, 0)
					},
					['[Double-Barrel SG]'] = {
						equipped = false,
						location = meshes.Candy.DBCandy,
						shoot_sound = 'rbxassetid://14723117395',
						C0 = newCFrame(0.0430603027, -0.0375298262, -0.00198364258, 0, 0, 1, 0, 1, 0, -1, 0, 0)
					},
					['LMG'] = {
						equipped = false,
						location = meshes.Candy.LMG,
						shoot_sound = 'rbxassetid://14748185495',
						C0 = newCFrame (0.125213623, -0.30771935, -0.0625305176, -4.37113883e-08, 0, 1, 0, 1, 0, -1, 0, -4.37113883e-08)
					}
				}
			}
		};

		mkelement = function(class, parent, props)
			local obj = Instance.new(class);

			for i, v in next, props do
				obj[i] = v;
			end;

			obj.Parent = parent;
			return obj;
		end;

		find_gun = (function(gun_name, instance)
			for i, v in next, instance:GetChildren() do
				if v:IsA('Tool') then
					if (v.Name == gun_name) then
						return v
					end
				end
			end
		end);

		InventoryChanger.Functions.GameEquip = function(gun, skin)
			return replicated_storage.MainEvent:FireServer('EquipWeaponSkins', gun, skin);
		end;

		InventoryChanger.Functions.AddOwnedSkins = function()
			for _, v in ipairs(entries:GetChildren()) do
				local ext_name = v.Name:match('%[(.-)%]');
				local skin_name, _ = v.Name:gsub('%[.-%]', '');
				if 
					ext_name 
					and skin_name 
					and InventoryChanger.Skins[skin_name] 
					and InventoryChanger.Skins[skin_name].guns 
					and InventoryChanger.Skins[skin_name].guns['[' .. ext_name .. ']']
				then
					local Preview = v:FindFirstChild('Preview');

					if Preview and Preview:FindFirstChild('Equipped') and Preview.Equipped.Visible then
						table.insert(InventoryChanger.Owned, { frame = v, gun = '[' .. ext_name .. ']' })
					end;
				end;
			end;
		end;

		InventoryChanger.Functions.UnequipGameSkins = function()
			for _, v in ipairs(InventoryChanger.Owned) do
				local SkinInfo = v.frame.SkinInfo;
				local Container = SkinInfo.Container;
				local SkinName = Container.SkinName.Text;

				InventoryChanger.Functions.GameEquip(v.gun, SkinName)
			end;
		end;

		InventoryChanger.Functions.Unload = function()
			return Utilities.Unload();
		end;

		InventoryChanger.Functions.Reload = function()
			local function wait_for_child(parent, child)
				local child = parent:WaitForChild(child);
				while not child do
					child = parent:WaitForChild(child);
				end;
				return child;
			end;
			
			client = players.LocalPlayer;
			player_gui = client.PlayerGui;

			repeat task.wait() until player_gui;

			main_gui = wait_for_child(player_gui, 'MainScreenGui');
			crew = wait_for_child(main_gui, 'Crew');

			bottom_left = wait_for_child(crew, 'BottomLeft');
			bottom_left = bottom_left.Frame;

			skins_button = wait_for_child(bottom_left, 'Skins');

			weapon_skins_gui = wait_for_child(main_gui, 'WeaponSkinsGUI');
			
			gui_body_wrapper = wait_for_child(weapon_skins_gui, 'Body');
			body_wrapper = wait_for_child(gui_body_wrapper, 'Wrapper');
			
			skin_view = wait_for_child(body_wrapper, 'SkinView');
			skin_view_frame = wait_for_child(skin_view, 'Frame');

			guns = wait_for_child(skin_view_frame, 'Guns').Contents;
			entries = wait_for_child(skin_view_frame, 'Skins').Contents.Entries;

			InventoryChanger.Functions.Unload();

			print ('Skins Loaded');

			wait_for_child(entries, '[Revolver]Golden Age');
			InventoryChanger.Functions.AddOwnedSkins();
			InventoryChanger.Functions.UnequipGameSkins();

			for i, v in next, guns:GetChildren() do
				if v:IsA('Frame') and v.Name ~= 'GunEntry' and v.Name ~= 'Trading' and v.Name ~= '[Mask]' then
					Utilities.AddConnection(v.Button.MouseButton1Click, function()
						local extracted_name = v.Name:match(regex);
						if extracted_name then
							InventoryChanger.Functions.Start(extracted_name);
						end;
					end);
				end;
			end;
		end;

		InventoryChanger.Functions.Equip = function(gun_name, skin_name)
			print('[DEBUG]', 'Equip function has been invoked.', gun_name, skin_name or 'Default')
			local gun = find_gun(gun_name, client.Backpack) or find_gun(gun_name, client.Character);
			if not skin_name then
				if gun and gun.Name == gun_name then
					for _, v in next, gun.Default:GetChildren() do v:Destroy() end;
					
					gun.Default.Transparency = 0;
					--if InventoryChanger.Selected[gun.Name] and not InventoryChanger.Skins[InventoryChanger.Selected[gun.Name]].Location then
						--gun.Default.TextureID = 'rbxassetid://8117372147';
					--end;
					
					if gun.Name == '[Silencer]' or gun.Name == '[SilencerAR]' then
						gun:FindFirstChild('Part').Transparency = 0;
					end;

					local skin_name = InventoryChanger.Selected[gun.Name];

					if skin_name and InventoryChanger.Skins[skin_name] and InventoryChanger.Skins[skin_name].guns and InventoryChanger.Skins[skin_name].guns[gun.Name] then
						if InventoryChanger.Skins[skin_name].guns[gun.Name].TracerLoop then
							InventoryChanger.Skins[skin_name].guns[gun.Name].TracerLoop:Disconnect();
							InventoryChanger.Skins[skin_name].guns[gun.Name].TracerLoop = nil;
						end;

						if InventoryChanger.Skins[skin_name].guns[gun.Name].shoot_sound_loop then
							InventoryChanger.Skins[skin_name].guns[gun.Name].shoot_sound_loop:Disconnect();
							InventoryChanger.Skins[skin_name].guns[gun.Name].shoot_sound_loop = nil;
						end;
					end;
				end;

				return;
			end;
			
			if gun and gun.Name == gun_name and skin_name then
				local skin_pack = InventoryChanger.Skins[skin_name];
				local guns = skin_pack.guns;
				if skin_pack and guns and not skin_pack.texture then
					for _, x in next, gun.Default:GetChildren() do x:Destroy() end;
					
					local clone = guns[gun_name].location:Clone();
					clone.Name = 'Mesh';
					clone.Parent = gun.Default;
					
					local weld = Instance.new('Weld', clone);
					weld.Part0 = gun.Default;
					weld.Part1 = clone;
					weld.C0 = guns[gun_name].C0;
					
					gun.Default.Transparency = 1;

					if guns[gun_name].shoot_sound then
						if guns[gun_name].shoot_sound_loop then
							guns[gun_name].shoot_sound_loop:Disconnect();
							guns[gun_name].shoot_sound_loop = nil;
						end;
						gun.Handle.ShootSound.SoundId = guns[gun_name].shoot_sound;
						guns[gun_name].shoot_sound_loop = gun.Handle.ChildAdded:Connect(function(child)
							if child:IsA('Sound') and child.Name == 'ShootSound' then
								child.SoundId = guns[gun_name].shoot_sound;
							end;
						end);
					end;
				end;
			end;
		end;

		InventoryChanger.Functions.Start = function(name)
			for i, v in next, entries:GetChildren() do
				local skin_name, _ = v.Name:gsub('%[.-%]', '');

				if string.find(v.Name, name, 1, true) and InventoryChanger.Skins[skin_name] and InventoryChanger.Skins[skin_name].guns and InventoryChanger.Skins[skin_name].guns['['..name..']'] and InventoryChanger.Skins[skin_name].guns['['..name..']'].location then
					local Preview = v:FindFirstChild('Preview');
					local Button = v:FindFirstChild('Button');
					local skinInfo = v:FindFirstChild('SkinInfo');

					if Preview and Button and skinInfo then
						local Label = Preview:FindFirstChild('LockImageLabel');
						local AmountValue = Preview:FindFirstChild('AmountValue');
						local Equipped = Preview:FindFirstChild('Equipped');
						local container = skinInfo:FindFirstChild('Container');

						local extracted_name = v.Name:match(regex);

						if Equipped and extracted_name then
							Equipped.Visible = InventoryChanger.Skins[skin_name] and InventoryChanger.Skins[skin_name].guns['['..extracted_name..']'] and InventoryChanger.Skins[skin_name].guns['['..extracted_name..']'].equipped or false;
							InventoryChanger.Functions.Equip('['..extracted_name..']', InventoryChanger.Selected['['..extracted_name..']'])

							if Label then
								Label.Visible = false;
							end;

							if container and container.SellButton then
								container.SellButton.Visible = true;
							end;
						
							if AmountValue then
								AmountValue.Visible = true;
								AmountValue.Text = 'x1';
							end;
						
							if getgenv().InventoryConnections[v.Name] then
								getgenv().InventoryConnections[v.Name]:Disconnect();
								getgenv().InventoryConnections[v.Name] = nil;
							end;

							v.Button:Destroy();
							local props = { Text = '',BackgroundTransparency = 1,Size = UDim2.new(1, 0, 0.7, 0),ZIndex = 5,Name = 'Button',Position = UDim2.new(0, 0, 0, 0)};
							local new_btn = mkelement('TextButton', v, props);

							getgenv().InventoryConnections[v.Name] = new_btn.MouseButton1Click:Connect(function()
								InventoryChanger.Skins[skin_name].guns['['..extracted_name..']'].equipped = not InventoryChanger.Skins[skin_name].guns['['..extracted_name..']'].equipped;
								InventoryChanger.Selected['['..extracted_name..']'] = InventoryChanger.Skins[skin_name].guns['['..extracted_name..']'].equipped and skin_name or nil;
								Equipped.Visible = InventoryChanger.Skins[skin_name].guns['['..extracted_name..']'].equipped;

								for k, x in ipairs(entries:GetChildren()) do
									if x.Name:match(regex) == extracted_name and x ~= v then
										x.Preview.Equipped.Visible = false;

										for _, l in next, InventoryChanger.Skins do
											if _ ~= skin_name and l['['..extracted_name..']'] and l['['..extracted_name..']'].equipped then
												l[extracted_name].equipped = false
											end;
										end;
									end;
									
									if x ~= v and string.find(x.Name, name, 1, true) and InventoryChanger.Skins[skin_name] and InventoryChanger.Skins[skin_name].guns and InventoryChanger.Skins[skin_name].guns['['..name..']'] and InventoryChanger.Skins[skin_name].guns['['..name..']'].location then
										local Preview = v:FindFirstChild('Preview');
										local Button = v:FindFirstChild('Button');
										local skinInfo = v:FindFirstChild('SkinInfo');
										
										if Preview and Button and skinInfo then
											local Label = Preview:FindFirstChild('LockImageLabel');
											local AmountValue = Preview:FindFirstChild('AmountValue');
											local Equipped = Preview:FindFirstChild('Equipped');
											local container = skinInfo:FindFirstChild('Container');
											
											if Label then
												Label.Visible = false;
											end;
							
											if container and container.SellButton then
												container.SellButton.Visible = true;
											end;
											
											if AmountValue then
												AmountValue.Visible = true;
												AmountValue.Text = 'x1';
											end;
										end;

										InventoryChanger.Owned = {};
										InventoryChanger.Functions.AddOwnedSkins();
										InventoryChanger.Functions.UnequipGameSkins();
									end;
								end;
							end);
						end;
					end;
				end;
			end;
		end;

		InventoryChanger.Functions.CharacterAdded = function(character)
			if getgenv().InventoryConnections.ChildAdded then
				getgenv().InventoryConnections.ChildAdded:Disconnect();
				getgenv().InventoryConnections.ChildAdded = nil;
			end;

			if getgenv().InventoryConnections.ChildRemoved then
				getgenv().InventoryConnections.ChildRemoved:Disconnect();
				getgenv().InventoryConnections.ChildRemoved = nil;
			end;

			getgenv().InventoryConnections.ChildAdded = character.ChildAdded:Connect(function(child)
				if child:IsA('Tool') and child:FindFirstChild('GunScript') then
					InventoryChanger.Functions.Equip(child.Name, InventoryChanger.Selected[child.Name]);
					local skin_name = InventoryChanger.Selected[child.Name];
					
					if skin_name then
						if InventoryChanger.Skins[skin_name].color and InventoryChanger.Skins[skin_name].guns[child.Name].equipped then
							if InventoryChanger.Skins[skin_name].guns[child.Name].TracerLoop then
								InventoryChanger.Skins[skin_name].guns[child.Name].TracerLoop:Disconnect();
								InventoryChanger.Skins[skin_name].guns[child.Name].TracerLoop = nil;
							end;

							InventoryChanger.Skins[skin_name].guns[child.Name].TracerLoop = Ignored.DescendantAdded:Connect(function(descendant)
								local gun = find_gun(child.Name, client.Character) or nil;

								if gun and descendant:IsDescendantOf(siren) and descendant:IsA('Beam') then
									local pos1 = (descendant.Attachment0.WorldCFrame.Position.X > gun.Handle.CFrame.Position.X) and descendant.Attachment0.WorldCFrame.Position or gun.Handle.CFrame.Position;
									local pos2 = (descendant.Attachment0.WorldCFrame.Position.X < gun.Handle.CFrame.Position.X) and descendant.Attachment0.WorldCFrame.Position or gun.Handle.CFrame.Position;

									if math.abs(client.Character.HumanoidRootPart.Velocity.X) < 22 and (pos1 - pos2).Magnitude < 5 or (pos1 - pos2).Magnitude < 20 then
										local skin_pack = InventoryChanger.Skins[skin_name];
										local guns = skin_pack and skin_pack.guns or nil
										local tween_duration = skin_pack and (skin_pack.tween_duration or guns and guns[gun.Name] and guns[gun.Name].tween_duration) or nil;
										local width = skin_pack and (skin_pack.beam_width or guns and guns[gun.Name] and guns[gun.Name].beam_width) or nil;
										local color = skin_pack and (skin_pack.color or guns and guns[gun.Name] and guns[gun.Name].color) or nil;
										local easing_direction = skin_pack and (skin_pack.easing_direction or guns and guns[gun.Name] and guns[gun.Name].easing_direction) or nil;
										local easing_style = skin_pack and (skin_pack.easing_stye or guns and guns[gun.Name] and guns[gun.Name].easing_style) or nil;

										if skin_pack and tween_duration and color then
											local clonedParent = descendant.Parent:Clone();

											clonedParent.Parent = workspace.Vehicles;
											descendant.Parent:Destroy();
											if width then
												clonedParent:FindFirstChild('GunBeam').Width1 = width;
											end;
											clonedParent:FindFirstChild('GunBeam').Color = color;
											Utilities.Tween({
												object = clonedParent:FindFirstChild('GunBeam'),
												info = { tween_duration, easing_style, easing_direction },
												properties = { Width1 = 0 },
												callback = function()
													clonedParent:Destroy();
												end
											})
										elseif color then
											descendant.Color = color;
										end;
									end;
								end;
							end);
						else
							if InventoryChanger.Skins[skin_name].guns[child.Name].TracerLoop then
								InventoryChanger.Skins[skin_name].guns[child.Name].TracerLoop:Disconnect();
								InventoryChanger.Skins[skin_name].guns[child.Name].TracerLoop = nil;
							end;
						end;
					end;
				end;
			end);

			getgenv().InventoryConnections.ChildRemoved = character.ChildRemoved:Connect(function(child)
				if child:IsA('Tool') and child:FindFirstChild('GunScript') then
					InventoryChanger.Functions.Equip(child.Name, false);

					local skin_name = InventoryChanger.Selected[child.Name];

					if skin_name then
						if InventoryChanger.Skins[skin_name].guns[child.Name].TracerLoop then
							InventoryChanger.Skins[skin_name].guns[child.Name].TracerLoop:Disconnect();
							InventoryChanger.Skins[skin_name].guns[child.Name].TracerLoop = nil;
						end;
					end;
				end;
			end);
			
			InventoryChanger.Functions.Reload();
		end;

		if getgenv().InventoryConnections.CharacterAdded then
			getgenv().InventoryConnections.CharacterAdded:Disconnect();
			getgenv().InventoryConnections.CharacterAdded = nil;
		end;
		getgenv().InventoryConnections.CharacterAdded = client.CharacterAdded:Connect(InventoryChanger.Functions.CharacterAdded);    InventoryChanger.Functions.CharacterAdded(client.Character);end;
    end,
    DoubleClick = false,
    Tooltip = 'Gives you skins in your inventory'
})

LeftGroupBox = Tabs.Misc:AddLeftGroupbox('Auto Stomp')

    _G.autoStomp = _G.autoStomp or false  -- Default is false if not already set

    if _G.autoStompReady == nil then
    -- Ensures this part only runs once to save resources
    _G.autoStompReady = true

    -- Variables
    local stompRemote = game.ReplicatedStorage.MainEvent -- The event you're firing
    local player = game.Players.LocalPlayer
    local stompInterval = 0.10 -- seconds between each stomp (default)
    local isLooping = false -- Start with stomping disabled
    local stompKey = Enum.KeyCode.F -- Default hotkey

    -- Cache frequently used objects
    local userInputService = game:GetService("UserInputService")
    local runService = game:GetService("RunService")
    local debrisService = game:GetService("Debris")
    
    -- Store common references once and reuse
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    
    -- Store Enum values for reusability
    local keyEnum = Enum.KeyCode.F

    -- Function to display notifications
    local function showNotification(title, text, duration)
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = title,
            Text = text,
            Duration = duration or 2 -- Default duration of 2 seconds
        })
    end

    -- Function to start stomping with precise timing
    local function startStomping()
        local lastStompTime = tick()  -- Store the current time at the start
        local stompConnection
        stompConnection = runService.Heartbeat:Connect(function()
            if isLooping then
                local currentTime = tick()
                if currentTime - lastStompTime >= stompInterval then
                    if humanoid and humanoid.Parent then
                        stompRemote:FireServer("Stomp")
                        lastStompTime = currentTime  -- Update the last stomp time
                    end
                end
            end
        end)
        _G.stompConnection = stompConnection
    end

    -- Function to stop stomping
    local function stopStomping()
        if _G.stompConnection then
            _G.stompConnection:Disconnect()
            _G.stompConnection = nil
        end
    end

    -- Function to toggle stomping with the F key or any configured key
    local function onKeyPress(input, gameProcessed)
        if not gameProcessed then
            if _G.autoStomp and input.KeyCode == stompKey then
                isLooping = not isLooping
                if isLooping then
                    showNotification("Auto Stomp Enabled", "Vilant Exploit", 3)
                    startStomping()  -- Now calling startStomping properly
                else
                    showNotification("Auto Stomp Disabled", "Vilant Exploit", 3)
                    stopStomping()
                end
            end
        end
    end

    -- UI Integration
    LeftGroupBox:AddToggle('MyToggle', {
        Text = 'Toggle Auto Stomp',
        Default = false, -- Default value (true / false)
        Tooltip = 'Toggles Stomps when walking over players', -- Information shown when you hover over the toggle
        Callback = function(Value)
            print('[cb] MyToggle changed to:', Value)
            _G.autoStomp = Value
            if _G.autoStomp then
                showNotification("Auto Stomp Enabled", "Vilant Exploit", 3)
            else
                showNotification("Auto Stomp Disabled", "Vilant Exploit", 3)
            end
        end
    })

    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
        Default = 'F', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
        SyncToggleState = false,
        Mode = 'Toggle', -- Modes: Always, Toggle, Hold
        Text = 'Auto Stomp', -- Text to display in the keybind menu
        NoUI = false, -- Set to true if you want to hide from the Keybind menu
        Callback = function(Value)
            print('[cb] Keybind clicked!', Value)
        end,
        ChangedCallback = function(New)
            print('[cb] Keybind changed!', New)
            stompKey = New -- Update the hotkey dynamically when changed
        end
    })

    LeftGroupBox:AddSlider('MySlider', {
        Text = 'Time between stomps',
        Default = stompInterval,
        Min = 0,
        Max = 1,
        Rounding = 1,
        Compact = false,
        Callback = function(Value)
            print('[cb] MySlider was changed! New value:', Value)
            stompInterval = Value -- Update stomp interval value dynamically

            -- Restart the stomping loop if it's running
            if isLooping then
                stopStomping()  -- Stop the current stomping loop
                startStomping() -- Restart it with the new interval
            end
        end
    })

    -- Connect key press event if autoStomp is true
    _G.autoStompKeyConnection = userInputService.InputBegan:Connect(onKeyPress)

    else
    -- Ensure the key press event is only active if autoStomp is true
    if _G.autoStomp then
        -- Disconnect the key press event
        if _G.autoStompKeyConnection then
            _G.autoStompKeyConnection:Disconnect()
            _G.autoStompKeyConnection = nil
        end

        -- Reset the stomp loop
        _G.autoStomp = false
    end
    _G.autoStompReady = nil
    end

  LeftGroupBox = Tabs.Misc:AddLeftGroupbox('Tp Stomp')

    -- Predefine commonly used services
    local gameReplicatedStorage = game:GetService("ReplicatedStorage")
    local userInputService = game:GetService("UserInputService")
    local starterGui = game:GetService("StarterGui")
    local runService = game:GetService("RunService")

    -- Optimize FindFirstChild usage
    local function findChild(parent, name)
    return parent:FindFirstChild(name)
    end

    -- Object Pooling for Repeatedly Used Instances (e.g., BodyEffects)
    local function getBodyEffects(player)
    return findChild(player.Character, "BodyEffects")
    end

    -- UI Setup for Tp Stomp Toggle
    LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Toggle Tp Stomp',
    Default = false,
    Tooltip = 'Toggle Teleporting to players and stomping',
    Callback = function(Value)
        _G.autoTP = Value
        if Value then
        end
        print('[cb] MyToggle changed to:', Value)
    end
    })

    -- UI Setup for Tp Back Toggle
    LeftGroupBox:AddToggle('TpBackToggle', {
    Text = 'Tp back to original position',
    Default = false,
    Tooltip = 'This makes it so after each stomp it tps back to your original position',
    Callback = function(Value)
        _G.tpBackToOriginal = Value
        print('[cb] Tp Back Toggle changed to:', Value)
    end
    })

    -- Keybind for Tp Stomp
    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
    Default = 'F',
    SyncToggleState = false,
    Mode = 'Hold',
    Text = 'Tp Stomp Keybind',
    NoUI = false,
    Callback = function(Value)
        print('[cb] Keybind clicked!', Value)
    end,
    ChangedCallback = function(New)
        _G.tpStompKey = New
        print('[cb] Keybind changed to:', New)
    end
    })

    -- Slider to change teleport range (studs)
    LeftGroupBox:AddSlider('MySlider', {
    Text = 'Teleport Range',
    Default = 100,
    Min = 0,
    Max = 5000,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        _G.teleportRange = Value
        print('[cb] MySlider was changed! New value:', Value)
    end
    })

    -- Script for teleportation functionality
    if _G.autoTP == nil then
    _G.autoTP = false
    end

    if _G.autoTPReady == nil then
    _G.autoTPReady = true

    -- Variables
    local player = game.Players.LocalPlayer
    _G.teleportRange = _G.teleportRange or 100 -- Set default range if not set
    _G.tpStompKey = _G.tpStompKey or Enum.KeyCode.F -- Default key for teleport stomp
    _G.tpBackToOriginal = _G.tpBackToOriginal == nil and false or _G.tpBackToOriginal

    -- Function to display notifications
    local function showNotification(title, text, duration)
        starterGui:SetCore("SendNotification", {
            Title = title,
            Text = text,
            Duration = duration or 2 -- Default duration of 2 seconds
        })
    end

    -- Function to find the nearest knocked player within range
    local function findNearestKnockedPlayer()
        local nearestPlayer = nil
        local shortestDistance = _G.teleportRange

        for _, otherPlayer in pairs(game.Players:GetPlayers()) do
            if otherPlayer ~= player and otherPlayer.Character then
                local bodyEffects = getBodyEffects(otherPlayer)
                local isKnocked = bodyEffects and findChild(bodyEffects, "K.O") and bodyEffects["K.O"].Value == true
                if isKnocked then
                    local torso = findChild(otherPlayer.Character, "UpperTorso") or findChild(otherPlayer.Character, "LowerTorso")
                    local playerRoot = findChild(player.Character, "HumanoidRootPart")
                    if torso and playerRoot then
                        local distance = (playerRoot.Position - torso.Position).Magnitude
                        if distance <= _G.teleportRange and distance < shortestDistance then
                            shortestDistance = distance
                            nearestPlayer = otherPlayer
                        end
                    end
                end
            end
        end
        return nearestPlayer
    end

    -- Function to teleport above a knocked player's torso, stomp, and teleport back (based on Tp Back toggle)
    local function teleportAndStomp(targetPlayer)
        if targetPlayer and targetPlayer.Character then
            local targetHumanoid = findChild(targetPlayer.Character, "Humanoid")
            local torso = findChild(targetPlayer.Character, "UpperTorso") or findChild(targetPlayer.Character, "LowerTorso")
            local playerRoot = findChild(player.Character, "HumanoidRootPart")

            if targetHumanoid and torso and playerRoot then
                -- Save the original position
                local originalPosition = playerRoot.CFrame

                -- Teleport above the player's torso (3 studs above)
                playerRoot.CFrame = CFrame.new(torso.Position + Vector3.new(0, 3, 0))

                -- Wait 0.35 seconds before stomping
                wait(0.35)

                -- Trigger the stomp action
                gameReplicatedStorage.MainEvent:FireServer("Stomp")

                -- Notify about the stomp
                showNotification("Stomping", "Vilant Exploit", 3)

                -- Wait 0.10 seconds before teleporting back (if TpBack is enabled)
                wait(0.20)

                if _G.tpBackToOriginal then
                    -- Teleport back to the original position
                    playerRoot.CFrame = originalPosition
                end
            end
        else
            showNotification("No Target Found", "Vilant Exploit", 3)
        end
    end

    -- Function to handle key press
    local function onKeyPress(input)
        if _G.autoTP and input.KeyCode == _G.tpStompKey then
            local targetPlayer = findNearestKnockedPlayer()
            teleportAndStomp(targetPlayer)
        end
    end

    -- Connect key press event
    _G.autoTPKeyConnection = userInputService.InputBegan:Connect(onKeyPress)
    else
    -- Disconnect the key press event
    if _G.autoTPKeyConnection then
        _G.autoTPKeyConnection:Disconnect()
        _G.autoTPKeyConnection = nil
    end

    -- Reset the script state
    _G.autoTP = false
    _G.autoTPReady = nil
    end

LeftGroupBox = Tabs.Misc:AddLeftGroupbox('Anti Stomp')

local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local debris = game:GetService("Debris")  -- For cleanup

-- Assuming LeftGroupBox and other UI elements are set up previously
local antiStompEnabled = false  -- Default value for anti-stomp toggle

-- Cache Enum values that are used frequently
local HumanoidStateType = Enum.HumanoidStateType
local KOD = "K.O"
local GRABBING_CONSTRAINT = "GRABBING_CONSTRAINT"

-- Add the Anti Stomp toggle
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Anti Stomp',
    Default = false, -- Default value (true / false)
    Tooltip = 'Destroys character when knocked preventing stomps',
    
    Callback = function(Value)
        antiStompEnabled = Value  -- Update the toggle value
    end
})

-- RunService heartbeat to monitor character state
RunService.Heartbeat:Connect(function()
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")

    -- Check if the character and humanoid exist
    if character and humanoid then
        -- Use a variable for BodyEffects and K.O state to avoid repeated calls
        local bodyEffects = character:FindFirstChild("BodyEffects")
        local KOd = bodyEffects and bodyEffects[KOD] and bodyEffects[KOD].Value
        local Grabbed = character:FindFirstChild(GRABBING_CONSTRAINT) ~= nil

        -- Only execute if Anti Stomp is enabled
        if antiStompEnabled and (KOd or Grabbed) then
            -- Prevent interaction by disabling humanoid interactions
            humanoid.PlatformStand = true  -- Disable normal character movements
            humanoid.WalkSpeed = 0  -- Prevent walking
            humanoid.JumpHeight = 0  -- Prevent jumping
            humanoid.Health = 0  -- Force kill the character immediately

            -- Disable collision to make it untouchable by other players
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false  -- Disable collision with other players
                end
            end

            -- Disable unnecessary humanoid states
            humanoid:SetStateEnabled(HumanoidStateType.Physics, false)
            humanoid:SetStateEnabled(HumanoidStateType.Seated, false)
            humanoid:SetStateEnabled(HumanoidStateType.Climbing, false)
            humanoid:SetStateEnabled(HumanoidStateType.Freefall, false)
            humanoid:SetStateEnabled(HumanoidStateType.Ragdoll, false)

            -- Prevent health changes from other players
            humanoid.MaxHealth = humanoid.Health

            -- Clean up BodyEffects to remove any effects causing interaction
            if bodyEffects then
                bodyEffects:ClearAllChildren()
            end

            -- Prevent stomping or any other interaction from players
            local collisionParts = character:GetChildren()
            for _, part in pairs(collisionParts) do
                if part:IsA("BasePart") then
                    part.CanCollide = false  -- Fully prevent collision interactions
                end
            end

            -- Immediately reset the character to remove any potential interaction
            player:LoadCharacter()  -- Reload the character to reset the player
        end
    end
end)

LeftGroupBox = Tabs.Misc:AddLeftGroupbox('Spin Bot')

--[[ 
Controls:
- Use the toggle in the UI to enable or disable SpinBot.
- Use the slider to adjust the SpinBot speed.
]]

-- Ensure proper initialization
if _G.spinBotInitialized == nil then
    _G.spinBotInitialized = false
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local plr = Players.LocalPlayer
local humRoot, humanoid

-- Function to apply SpinBot
local function applySpinBot()
    if _G.spinBotActive and humRoot and humanoid then
        humanoid.AutoRotate = false
        local velocity = Instance.new("AngularVelocity")
        velocity.Attachment0 = humRoot:FindFirstChild("RootAttachment")
        velocity.MaxTorque = math.huge
        velocity.AngularVelocity = Vector3.new(0, _G.spinBotSpeed or 50, 0)
        velocity.Parent = humRoot
        velocity.Name = "Spinbot"
    end
end

-- Function to update character references
local function updateCharacterReferences()
    local character = plr.Character or plr.CharacterAdded:Wait()
    humRoot = character:WaitForChild("HumanoidRootPart")
    humanoid = character:FindFirstChildOfClass("Humanoid")
    
    -- Restore SpinBot after respawn if it was active
    task.wait(0.5)
    applySpinBot()
end

updateCharacterReferences()
plr.CharacterAdded:Connect(updateCharacterReferences)

-- UI Toggle for SpinBot
LeftGroupBox:AddToggle('SpinBotToggle', {
    Text = 'Spin Bot',
    Default = false,
    Tooltip = 'Makes you spin',
    Callback = function(Value)
        if Value then
            _G.spinBotActive = true
            _G.spinBotInitialized = true
            applySpinBot()
        else
            _G.spinBotActive = false
            _G.spinBotInitialized = false
            
            if humRoot and humanoid then
                humRoot.CFrame = CFrame.new(humRoot.Position)
                humanoid.AutoRotate = true
            end
            
            local velocity = humRoot and humRoot:FindFirstChild("Spinbot")
            if velocity then
                velocity:Destroy()
            end
        end
    end
})

-- UI Slider for SpinBot Speed
LeftGroupBox:AddSlider('SpinBotSpeed', {
    Text = 'SpinBot Speed',
    Default = 50,
    Min = 1,
    Max = 150,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        _G.spinBotSpeed = Value
        if _G.spinBotActive and humRoot then
            local velocity = humRoot:FindFirstChild("Spinbot")
            if velocity then
                velocity.AngularVelocity = Vector3.new(0, Value, 0)
            end
        end
    end
})

LeftGroupBox = Tabs.Misc:AddLeftGroupbox('Avatar Forcefield')

    -- References to services and default settings
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local player = Players.LocalPlayer

    -- Constants for materials and default values
    local FORCEFIELD_MATERIAL = Enum.Material.ForceField
    local DEFAULT_MATERIAL = Enum.Material.Plastic
    local DEFAULT_COLOR = Color3.fromRGB(255, 255, 255)
    local currentColor = Color3.fromRGB(108, 59, 170) -- Default forcefield color
    local forcefieldEnabled = false -- Tracks whether the forcefield effect is enabled

    -- Function to customize character parts
    local function customizeCharacter(character, newColor)
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            if forcefieldEnabled then
                part.Color = newColor -- Apply the new color
                part.Material = FORCEFIELD_MATERIAL -- Apply ForceField material
            else
                part.Material = DEFAULT_MATERIAL -- Default material
                part.Color = DEFAULT_COLOR -- Default white color
            end
        end
    end
    end

    -- Function to handle player character updates
    local function onCharacterAdded(character)
    if forcefieldEnabled then
        customizeCharacter(character, currentColor)
    end
    end

    -- Connection to handle new character spawns
    player.CharacterAdded:Connect(onCharacterAdded)

    -- UI Integration
    LeftGroupBox:AddToggle('ForcefieldToggle', {
    Text = 'Enable Forcefield',
    Default = false, -- Default value (disabled)
    Tooltip = 'Toggle the forcefield effect on your character.',

    Callback = function(Value)
        forcefieldEnabled = Value
        print('[cb] Forcefield toggled:', Value)

        -- Apply or remove forcefield effect immediately
        local character = player.Character
        if character then
            customizeCharacter(character, currentColor)
        end
    end
    })

    LeftGroupBox:AddLabel('Forcefield Color'):AddColorPicker('ForcefieldColorPicker', {
    Default = currentColor, -- Default color
    Title = 'Select Forcefield Color',
    Transparency = 0, -- Disable transparency changing

    Callback = function(Value)
        print('[cb] Forcefield color changed:', Value)

        -- Update current color and apply the new color if the forcefield is enabled
        currentColor = Value
        local character = player.Character
        if forcefieldEnabled and character then
            customizeCharacter(character, currentColor)
        end
    end
    })

    -- Use RunService to update forcefield effect efficiently
    RunService.Heartbeat:Connect(function()
    if forcefieldEnabled then
        local character = player.Character
        if character then
            customizeCharacter(character, currentColor)
        end
    end
    end)

watermarkVisible = true  -- Boolean to track watermark visibility
Library:SetWatermarkVisibility(watermarkVisible)  -- Set initial visibility to true

-- Function to toggle the watermark visibility
function toggleWatermarkVisibility(Value)
    watermarkVisible = Value  -- Update the visibility state
    Library:SetWatermarkVisibility(watermarkVisible)  -- Apply the new visibility
end

-- FPS and Ping display update
FrameTimer = tick()
FrameCounter = 0
FPS = 60

-- Corrected FPS and Ping update inside RenderStepped
WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    if not watermarkVisible then return end  -- Skip updating if watermark is hidden

    FrameCounter += 1

    -- Update FPS every second
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end

    -- Update watermark with FPS and Ping
    local ping = math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    Library:SetWatermark(('Vilant v1.7 | %s fps | %s ms'):format(
        math.floor(FPS),
        ping
    ))
end)
