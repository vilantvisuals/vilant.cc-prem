 Library = loadstring(game:HttpGet('https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/refs/heads/main/Library.lua'))()

    Window = Library:CreateWindow({

    Title = 'Vilant Exploit | v1.8 | by @fazefr0',
    Center = true,
    AutoShow = true,
    TabPadding = 9
    })

    Tabs = {
    Main = Window:AddTab('Main'),
    Visuals = Window:AddTab('Visuals'),
    Movement = Window:AddTab('Movement'),
    Misc = Window:AddTab('Misc'),
    Teleport = Window:AddTab('Teleport'),
    }

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Aimbot')

    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Camera = workspace.CurrentCamera
    local Workspace = game:GetService("Workspace")
    
    local LocalPlayer = Players.LocalPlayer
    
    local cursorLocked = false
    local targetHead = nil
    local targetPlayer = nil
    local previewHighlight = nil
    local lockedHighlight = nil
    local predictionLevel = 0 -- Default prediction level, can be changed (higher value = more prediction)
    local currentKeybind = Enum.KeyCode.C
    local previewColor = Color3.fromRGB(0, 0, 255) -- Default preview color
    local lockedHighlightColor = Color3.fromRGB(255, 0, 0) -- Default locked highlight color
    local smoothness = 0 -- Default smoothness value
    local highlightsEnabled = false -- Default value for highlights toggle
    
    local ragelock = false  -- Default value for ragelock
    local orbitActive = false  -- Flag for orbit feature
    local orbitSpeed = 10 -- Orbit speed
    local radius = 8 -- Orbit size
    local rotation = CFrame.Angles(0, 0, 0) -- Rotation angles
    
    if _G.aimlock == nil then
        _G.aimlock = false  -- Default value if not previously set
    end
    
    local function IsPlayerKnockedOrGrabbed(player)
        local character = player.Character
        if character then
            local bodyEffects = character:FindFirstChild("BodyEffects")
            local grabbingConstraint = character:FindFirstChild("GRABBING_CONSTRAINT")
            if bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value or grabbingConstraint then
                return true
            end
        end
        return false
    end
    
    -- Function to calculate the predicted position based on velocity
    local function GetPredictedPosition(player)
        local character = player.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            local head = character:FindFirstChild("Head")
            if humanoid and head then
                local velocity = humanoid.RootPart.AssemblyLinearVelocity
                return head.Position + velocity * predictionLevel
            end
        end
        return nil
    end
    
    local function FindClosestPlayerHead()
        local closestPlayer = nil
        local closestDistance = math.huge
        local mousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
    
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
                local character = player.Character
                local humanoid = character:FindFirstChild("Humanoid")
    
                if humanoid and humanoid.Health > 0 then
                    if IsPlayerKnockedOrGrabbed(player) then continue end  -- Skip locked/knocked/grabbed players
                    local head = character.Head
                    local predictedHeadPosition = GetPredictedPosition(player) or head.Position
                    local screenPoint = Camera:WorldToScreenPoint(predictedHeadPosition)
                    local distance = (mousePosition - Vector2.new(screenPoint.X, screenPoint.Y)).Magnitude
                    local playerDistance = (Camera.CFrame.Position - predictedHeadPosition).Magnitude
    
                    local ray = Ray.new(Camera.CFrame.Position, predictedHeadPosition - Camera.CFrame.Position)
                    local hitPart, hitPosition = Workspace:FindPartOnRay(ray, LocalPlayer.Character)
    
                    if playerDistance <= 100 or (not hitPart or hitPart.Parent == character) then
                        if distance < closestDistance then
                            closestDistance = distance
                            closestPlayer = player
                        end
                    end
                end
            end
        end
    
        if closestPlayer then
            return closestPlayer.Character.Head, closestPlayer
        end
        return nil, nil
    end
    
    local function AddPreviewHighlight(player)
        if not highlightsEnabled then return end -- Skip if highlights are disabled
    
        if previewHighlight and previewHighlight.Parent == player.Character then
            previewHighlight.FillColor = previewColor
            return
        end
    
        if previewHighlight then
            previewHighlight:Destroy()
        end
    
        if player and player.Character then
            previewHighlight = Instance.new("Highlight")
            previewHighlight.Parent = player.Character
            previewHighlight.FillTransparency = 0.5
            previewHighlight.FillColor = previewColor
        end
    end
    
    local function AddLockedHighlight(player)
        if not highlightsEnabled then return end -- Skip if highlights are disabled
    
        if lockedHighlight and lockedHighlight.Parent == player.Character then
            lockedHighlight.FillColor = lockedHighlightColor
            return
        end
    
        if lockedHighlight then
            lockedHighlight:Destroy()
        end
    
        if player and player.Character then
            lockedHighlight = Instance.new("Highlight")
            lockedHighlight.Parent = player.Character
            lockedHighlight.FillTransparency = 0.5
            lockedHighlight.FillColor = lockedHighlightColor
        end
    end
    
    local function LockCursorToHead()
        targetHead, targetPlayer = FindClosestPlayerHead()
        if targetHead then
            AddLockedHighlight(targetPlayer)  -- Add highlight to locked player
            if previewHighlight then previewHighlight:Destroy() end  -- Destroy preview highlight if it exists
            UserInputService.MouseIconEnabled = false
        end
    end
    
    local function UnlockCursor()
        UserInputService.MouseIconEnabled = true
        targetHead = nil
        targetPlayer = nil
        if lockedHighlight then lockedHighlight:Destroy() end
    end
    
    local function ActivateOrbit(player)
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            targetPlayer = player
        end
    end
    
    -- Function to deactivate orbiting
    local function DeactivateOrbit()
        targetPlayer = nil
    end
    
    -- Function to handle automatic targeting for RageLock
    local function HandleRageLock()
        -- Ensure RageLock only locks onto the target if it's valid
        if ragelock then
            -- Check if targetPlayer is invalid or knocked
            if targetPlayer and IsPlayerKnockedOrGrabbed(targetPlayer) then
                -- If the locked target is knocked or grabbed, unlock and search for the next target
                cursorLocked = false
                UnlockCursor()
                DeactivateOrbit()
                print("[RageLock] Target is knocked/grabbed, unlocking and searching for next target.")
                targetHead, targetPlayer = FindClosestPlayerHead()
                if targetPlayer then
                    cursorLocked = true
                    LockCursorToHead()
                    AddLockedHighlight(targetPlayer)  -- Add highlight to new target
                end
                return
            end
    
            -- If no valid target is locked, search for a new one
            if not targetPlayer then
                targetHead, targetPlayer = FindClosestPlayerHead()
                if targetPlayer then
                    cursorLocked = true
                    LockCursorToHead()
                    AddLockedHighlight(targetPlayer)  -- Add highlight to new target
                end
            end
        end
    end
    
    -- Orbit update loop (only runs when orbit toggle is true)
    RunService.Stepped:Connect(function(_, dt)
        if orbitActive then
            -- Only update orbit if the toggle is true and the player is locked onto a valid target
            if cursorLocked and targetPlayer then
                -- Only update orbit if the target is locked (Aimlock or RageLock)
                local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if targetHumanoidRootPart then
                    local rot = tick() * orbitSpeed
                    local lpr = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if lpr then
                        -- Orbit calculation (only orbits if locked onto target)
                        lpr.CFrame = CFrame.new(
                            targetHumanoidRootPart.Position + Vector3.new(math.sin(rot) * radius, 0, math.cos(rot) * radius)
                        )
                    end
                end
            end
        end
    
        -- Update loop to continuously follow the locked target for aimlock
        if cursorLocked and _G.aimlock and targetHead then
            -- Handle ragelock to auto lock onto next target if necessary
            if ragelock then
                HandleRageLock()  -- Call the function to handle RageLock auto-targeting
            end
    
            -- Check if the locked player is knocked or grabbed and unlock if necessary
            if IsPlayerKnockedOrGrabbed(targetPlayer) then
                cursorLocked = false
                UnlockCursor()
                DeactivateOrbit()
                print("[Auto Unlock] Target player is knocked or grabbed, unlocking cursor.")
            else
                        -- Proceed with the normal aimlock and orbit
        local predictedHeadPosition = GetPredictedPosition(targetPlayer) or targetHead.Position
        -- Smoothly interpolate the camera's CFrame
        local alpha = 1 - smoothness
        alpha = math.max(alpha, 0.01)  -- Ensure alpha is never 0
        Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, predictedHeadPosition), alpha)
            end
        elseif not cursorLocked and _G.aimlock then
            local closestHead, closestPlayer = FindClosestPlayerHead()
            if closestPlayer ~= targetPlayer then
                AddPreviewHighlight(closestPlayer)
            end
        end
    end)
    
    -- Handle key press (C) for locking the cursor
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == currentKeybind then
            if _G.aimlock then
                cursorLocked = not cursorLocked
                if cursorLocked then
                    LockCursorToHead()
                    if orbitActive then
                        ActivateOrbit(targetPlayer)  -- Activate orbit when locking onto a player and orbiting is enabled
                    end
                else
                    UnlockCursor()
                    DeactivateOrbit()  -- Deactivate orbit when unlocking
                end
            end
        end
    end)
    
    -- UI Controls for setting various values like keybinds and highlight colors
    LeftGroupBox:AddToggle('Aimbot', {
        Text = 'Aimbot',
        Default = false,
        Tooltip = 'Locks your aim onto players heads',
        Callback = function(Value)
            _G.aimlock = Value
            print('[cb] Aimlock changed to:', Value)
            if _G.aimlock then
                cursorLocked = false  -- Ensure cursor is not locked when aimlock is turned on
            end
        end
    })
    
    LeftGroupBox:AddToggle('RageLock', {
        Text = 'RageLock',
        Default = false,
        Tooltip = 'Automatically locks onto the next available player',
        Callback = function(Value)
            ragelock = Value
            print('[cb] RageLock changed to:', Value)
        end
    })
    
    LeftGroupBox:AddToggle('OrbitFeature', {
        Text = 'Orbit Around Target',
        Default = false,
        Tooltip = 'Toggle to start orbiting around the player you lock onto.',
        Callback = function(value)
            orbitActive = value  -- Directly set orbitActive based on toggle state
            if orbitActive and cursorLocked then
                ActivateOrbit(targetPlayer) -- Activate orbit only if locked onto a player
            else
                DeactivateOrbit()  -- Deactivate orbit when the toggle is off
            end
        end
    })
    
    -- Add Toggle for Highlights
    LeftGroupBox:AddToggle('HighlightsToggle', {
        Text = 'Highlights',
        Default = highlightsEnabled,
        Tooltip = 'Toggle to enable or disable highlights',
        Callback = function(Value)
            highlightsEnabled = Value
            print('[cb] Highlights toggled:', Value)
            if not Value then
                -- Destroy highlights if they exist
                if previewHighlight then
                    previewHighlight:Destroy()
                    previewHighlight = nil
                end
                if lockedHighlight then
                    lockedHighlight:Destroy()
                    lockedHighlight = nil
                end
            end
        end
    })
    
    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
        Default = 'C',
        SyncToggleState = false,
        Mode = 'Toggle',
        Text = 'Aimlock',
        ChangedCallback = function(New)
            print('[cb] Keybind changed!', New)
            currentKeybind = New
        end
    })
    
    LeftGroupBox:AddLabel('Preview Color'):AddColorPicker('PreviewColorPicker', {
        Default = previewColor,
        Title = 'Preview Color',
        Transparency = 0,
        Callback = function(Value)
            print('[cb] Preview Color changed!', Value)
            previewColor = Value
            if previewHighlight then
                previewHighlight.FillColor = Value
            end
        end
    })
    
    LeftGroupBox:AddLabel('Locked Highlight Color'):AddColorPicker('LockedColorPicker', {
        Default = lockedHighlightColor,
        Title = 'Locked Player Highlight Color',
        Transparency = 0,
        Callback = function(Value)
            print('[cb] Locked Highlight Color changed!', Value)
            lockedHighlightColor = Value
            if lockedHighlight then
                lockedHighlight.FillColor = Value
            end
        end
    })
    
    -- Add Smoothness Slider
    LeftGroupBox:AddSlider('SmoothnessSlider', {
        Text = 'Smoothness',
        Default = smoothness,
        Min = 0,
        Max = 1,
        Rounding = 2,
        Callback = function(Value)
            print('[cb] Smoothness changed!', Value)
            smoothness = Value
        end
    })
    
    LeftGroupBox:AddSlider('Orbit Speed', {
        Text = 'Orbit Speed',
        Default = orbitSpeed,
        Min = 0,
        Max = 100,
        Rounding = 1,
        Callback = function(Value)
            print('[cb] Orbit Speed changed!', Value)
            orbitSpeed = Value
        end
    })
    
    LeftGroupBox:AddSlider('PredictionSlider', {
        Text = 'Prediction',
        Default = predictionLevel,
        Min = 0,
        Max = 1,
        Rounding = 1,
        Callback = function(Value)
            print('[cb] Prediction changed!', Value)
            predictionLevel = Value
        end
    })

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Triggerbot')

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local lp = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer"):Wait() and Players.LocalPlayer
local mouse = lp:GetMouse()

local EnumKeyCode = Enum.KeyCode -- Store Enum values for reuse
local EnumUserInputType = Enum.UserInputType

local Script = {
    Functions = {},
    Table = {
        Start = {
            TriggerBot = {
                Keybind = "Z", -- Default keybind, can be changed via UI
                Delay = 0.1, -- Default delay, can be changed via UI
                Blacklisted = {} -- Add blacklisted tool names here
            }
        }
    },
    Connections = {}
}

-- Use Object Pooling for frequently accessed properties like BodyEffects
Script.Functions.isDead = function(player)
    local character = player.Character
    if not character then return false end

    local bodyEffects = character:FindFirstChild("BodyEffects")
    if not bodyEffects then return false end

    local ko = bodyEffects:FindFirstChild("K.O") or bodyEffects:FindFirstChild("KO")
    return ko and ko.Value or false
end

Script.Functions.getTarget = function(instance)
    if not instance then return false end

    for _, player in next, Players:GetPlayers() do
        if player.Character and (instance == player.Character or instance:IsDescendantOf(player.Character)) then
            if not Script.Functions.isDead(player) then
                return player
            end
        end
    end

    return false
end

Script.Functions.isToolBlacklisted = function(tool)
    for _, toolName in ipairs(Script.Table.Start.TriggerBot.Blacklisted) do
        if tool.Name == toolName then
            return true
        end
    end
    return false
end

-- Flag to toggle triggerbot state
local JAIROUGH = false
local hotkeyEnabled = false -- Flag to control if the hotkey is enabled or not

-- Update delay when slider is changed
Script.Functions.updateDelay = function(Value)
    Script.Table.Start.TriggerBot.Delay = Value
end

-- Toggle triggerbot state on keypress, but only if hotkey is enabled
Script.Functions.onKeyPress = function(input, gameProcessed)
    if gameProcessed then return end

    -- Only allow the hotkey to toggle triggerbot if the hotkey is enabled
    if hotkeyEnabled and input.UserInputType == EnumUserInputType.Keyboard and input.KeyCode == EnumKeyCode[Script.Table.Start.TriggerBot.Keybind] then
        JAIROUGH = not JAIROUGH
    end
end

-- Keybind handler to change keybind via UI
Script.Functions.updateKeybind = function(NewKey)
    Script.Table.Start.TriggerBot.Keybind = NewKey.Name
    print('[cb] Keybind changed!', NewKey.Name)
end

UserInputService.InputBegan:Connect(Script.Functions.onKeyPress)

-- TriggerBot activation logic
Script.Functions.triggerBot = function()
    local con
    con = RunService.Heartbeat:Connect(function()
        if JAIROUGH then
            local target = mouse.Target
            if target and Script.Functions.getTarget(target) then
                if lp.Character then
                    local tool = lp.Character:FindFirstChildWhichIsA('Tool')
                    if tool and not Script.Functions.isToolBlacklisted(tool) then
                        task.wait(Script.Table.Start.TriggerBot.Delay)
                        tool:Activate()
                    end
                end
            end
        end
    end)

    Script.Connections.triggerBot = con
end

Script.Functions.triggerBot()

-- Disable function to disconnect triggerbot and cleanup
getgenv().disable = function()
    getgenv().disable = nil
    if Script.Connections.triggerBot then
        Script.Connections.triggerBot:Disconnect()
    end
end

-- UI Integration
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Enable Hotkey',
    Default = false, -- Default value (true / false)
    Tooltip = 'Enable or Disable the hotkey for TriggerBot', -- Information shown when you hover over the toggle
    Callback = function(Value)
        -- Enable or disable hotkey based on toggle state
        hotkeyEnabled = Value
        
        -- If hotkey is disabled, immediately disable the TriggerBot as well
        if not hotkeyEnabled then
            JAIROUGH = false
        end
    end
})

LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
    Default = Script.Table.Start.TriggerBot.Keybind, -- Default keybind value
    SyncToggleState = false, -- Keybind is independent of toggle state
    Mode = 'Toggle', -- Modes: Always, Toggle, Hold
    Text = 'Triggerbot Keybind', -- Text to display in the keybind menu
    NoUI = false, -- Set to true if you want to hide from the Keybind menu,
    ChangedCallback = function(New)
        Script.Functions.updateKeybind(New)
    end
})

LeftGroupBox:AddSlider('MySlider', {
    Text = 'Delay Slider',
    Default = Script.Table.Start.TriggerBot.Delay, -- Default delay value
    Min = 0,
    Max = 1,
    Rounding = 3,
    Compact = false,
    Callback = function(Value)
        Script.Functions.updateDelay(Value)
    end
})

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Rapid Fire')

    LeftGroupBox:AddToggle('MyToggle', {
        Text = 'Rapid Fire',
        Default = false, -- Default value (true / false)
        Tooltip = 'Rapid Fire v2 is better for some', -- Information shown when you hover over the toggle
    
        Callback = function(Value)
    
            -- Ensure script state is toggled correctly on each execution
            if _G.gunActivation == nil then
                _G.gunActivation = false  -- Default value if not previously set
            end
    
            -- Toggle script state
            _G.gunActivation = not _G.gunActivation
    
            -- Store frequently used Enum values in variables
            local UserInputType = Enum.UserInputType
            local MouseButton1 = UserInputType.MouseButton1
    
            if _G.gunActivation then
                local player = game.Players.LocalPlayer
                local userInputService = game:GetService("UserInputService")
                local runService = game:GetService("RunService")
                local isActive = false  -- Tracks whether the gun activation is enabled or not
    
                -- Function to continuously activate the held item (gun) at the fastest rate possible
                local function continuouslyActivateHeldItem()
                    while _G.gunActivation and runService.Heartbeat:Wait() do
                        if isActive then
                            local character = player.Character
                            if character then
                                local gunTool = character:FindFirstChildOfClass("Tool")
                                if gunTool then
                                    gunTool:Activate()
                                end
                            end
                        end
                    end
                end
    
                local function onMouseClick(input, gameProcessedEvent)
                    if gameProcessedEvent then return end
    
                    if input.UserInputType == MouseButton1 then
                        isActive = true
                    end
                end
    
                local function onMouseRelease(input, gameProcessedEvent)
                    if gameProcessedEvent then return end
    
                    if input.UserInputType == MouseButton1 then
                        isActive = false
                    end
                end
    
                _G.mouseClickConnection = userInputService.InputBegan:Connect(onMouseClick)
                _G.mouseReleaseConnection = userInputService.InputEnded:Connect(onMouseRelease)
                spawn(continuouslyActivateHeldItem)
            else
                if _G.mouseClickConnection then
                    _G.mouseClickConnection:Disconnect()
                    _G.mouseClickConnection = nil
                end
                if _G.mouseReleaseConnection then
                    _G.mouseReleaseConnection:Disconnect()
                    _G.mouseReleaseConnection = nil
                end
            end
        end
    })    

LeftGroupBox = Tabs.Main:AddRightGroupbox('Hitbox Expander')

    repeat wait() until game:IsLoaded()

Players = game:GetService('Players')
RunService = game:GetService('RunService')
EnumMaterial = Enum.Material.Neon  -- Enum value for Material

-- Initialize global state
_G.ToggleState = _G.ToggleState or false -- Default state
_G.HITBOX_SIZE = Vector3.new(16, 16, 16)  -- Default hitbox size
_G.HitboxColor = Color3.fromRGB(0, 0, 0)  -- Default hitbox color Black
_G.HitboxTransparency = 0.8  -- Default transparency
_G.OutlineColor = Color3.fromRGB(108, 59, 170) -- Default outline color Royal Purple
_G.OutlineTransparency = 0  -- Default outline transparency
_G.Disabled = not _G.ToggleState

-- UI setup (skip UI references here)
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Hitbox Expander',
    Default = false,
    Tooltip = 'Increases size of player Hitboxes for easier targeting',
    Callback = function(Value)
        _G.ToggleState = Value
        _G.Disabled = not Value
    end
})

-- Color Pickers and Sliders for customization
LeftGroupBox:AddLabel('Outline Color'):AddColorPicker('OutlineColorPicker', {
    Default = Color3.new(0.4235, 0.2314, 0.6667), -- Royal Purple
    Title = 'Outline Color',
    Callback = function(Value) _G.OutlineColor = Value end
})

LeftGroupBox:AddLabel('Hitbox Color'):AddColorPicker('HitboxColorPicker', {
    Default = Color3.new(0, 0, 0), -- Default Black
    Title = 'Hitbox Color',
    Callback = function(Value) _G.HitboxColor = Value end
})

LeftGroupBox:AddSlider('HitboxSizeSlider', {
    Text = 'Size of the hitbox',
    Default = 16,
    Min = 5,
    Max = 37.5,
    Rounding = 1,
    Callback = function(Value) _G.HITBOX_SIZE = Vector3.new(Value, Value, Value) end
})

LeftGroupBox:AddSlider('TransparencySlider', {
    Text = 'Transparency of the hitbox',
    Default = _G.HitboxTransparency,
    Min = 0,
    Max = 1,
    Rounding = 1,
    Callback = function(Value) _G.HitboxTransparency = Value end
})

LeftGroupBox:AddSlider('OutlineTransparencySlider', {
    Text = 'Transparency of the outline',
    Default = _G.OutlineTransparency,
    Min = 0,
    Max = 1,
    Rounding = 1,
    Callback = function(Value) _G.OutlineTransparency = Value end
})

-- Object pooling for outlines
outlinePool = {}

-- Function to get the outline or create it
getOutline = function(part)
    local outline = part:FindFirstChild("Outline")
    if not outline then
        outline = #outlinePool > 0 and table.remove(outlinePool) or Instance.new("SelectionBox")
        outline.LineThickness = 0.05
        outline.Color3 = _G.OutlineColor
        outline.Name = "Outline"
    end
    outline.Adornee = part
    outline.Parent = part
    outline.Transparency = _G.OutlineTransparency
    return outline
end

-- Function to release the outline
releaseOutline = function(outline)
    outline.Adornee = nil
    outline.Parent = nil
    table.insert(outlinePool, outline)
end

-- Throttle updates
local lastUpdate = tick()

-- Function to batch and optimize updates
updateHitboxes = function()
    local now = tick()
    if now - lastUpdate < 0.2 then -- Update every 0.2 seconds (5 times per second)
        return
    end
    lastUpdate = now

    -- Loop through players and update hitboxes
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            local character = player.Character
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    local bodyEffects = character:FindFirstChild("BodyEffects")
                    local isKOd = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
                    local isGrabbed = character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil

                    -- Only modify the hitbox if not KO'd or grabbed
                    if isKOd or isGrabbed then
                        if humanoidRootPart.Size ~= Vector3.new(0, 0, 0) then
                            humanoidRootPart.Size = Vector3.new(0, 0, 0)
                            humanoidRootPart.Transparency = 1
                            local outline = humanoidRootPart:FindFirstChild("Outline")
                            if outline then releaseOutline(outline) end
                        end
                    else
                        -- Update size, color, transparency, and outline dynamically
                        if humanoidRootPart.Size ~= _G.HITBOX_SIZE then
                            humanoidRootPart.Size = _G.HITBOX_SIZE
                            humanoidRootPart.Transparency = _G.HitboxTransparency
                            humanoidRootPart.BrickColor = BrickColor.new(_G.HitboxColor)
                            humanoidRootPart.Material = EnumMaterial
                            humanoidRootPart.CanCollide = false
                            getOutline(humanoidRootPart)
                        else
                            -- Dynamically update color and transparency based on the UI changes
                            humanoidRootPart.BrickColor = BrickColor.new(_G.HitboxColor)
                            humanoidRootPart.Transparency = _G.HitboxTransparency
                        end
                        
                        -- Update outline color and transparency dynamically based on the selected Outline settings
                        local outline = humanoidRootPart:FindFirstChild("Outline")
                        if outline then
                            outline.Color3 = _G.OutlineColor
                            outline.Transparency = _G.OutlineTransparency
                        end
                    end
                end
            end
        end
    end
end

-- Use Heartbeat for smoother updates
RunService.Heartbeat:Connect(function()
    if not _G.Disabled then
        updateHitboxes()
    else
        -- Reset the hitboxes if disabled
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= Players.LocalPlayer then
                local character = player.Character
                if character then
                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        humanoidRootPart.Size = Vector3.new(2, 2, 1)
                        humanoidRootPart.Transparency = 1
                        local outline = humanoidRootPart:FindFirstChild("Outline")
                        if outline then releaseOutline(outline) end
                    end
                end
            end
        end
    end
end)

LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('Cham Esp')

-- The actual cham effect
Players = game:GetService("Players")
RunService = game:GetService("RunService")
LocalPlayer = Players.LocalPlayer
highlightColor = Color3.fromRGB(255, 255, 255)  -- Default color for chams

-- Function to create a cham (highlight) effect for a player
function CreateCham(player)
    local character = player.Character or player.CharacterAdded:Wait()
    if not character:FindFirstChild("HumanoidRootPart") then return end

    -- Create the highlight object for the player's character
    local highlight = Instance.new("Highlight")
    highlight.Name = "ChamHighlight"
    highlight.Parent = character
    highlight.Adornee = character  -- Set the highlight target to the entire character
    highlight.FillColor = highlightColor  -- Set color to chosen value
    highlight.FillTransparency = 0.5  -- Make the highlight semi-transparent
    highlight.OutlineTransparency = 1  -- Fully transparent outline (no outline)

    -- Clean up when the character is removed
    character:WaitForChild("HumanoidRootPart").AncestryChanged:Connect(function()
        highlight:Destroy()  -- Remove the highlight when the player leaves or the character is destroyed
    end)
end

-- UI Toggle for Chams
LeftGroupBox:AddToggle('ChamsToggle', {
    Text = 'Chams',
    Default = false, -- Default value (true / false)
    Tooltip = 'Toggles cham effect for players',

    Callback = function(Value)
        _G.chams = Value
        -- Apply or remove the cham effect based on the toggle state
        if _G.chams then
            -- Apply cham effect for players when enabled
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    CreateCham(player)
                end
            end
        else
            -- Remove cham effect for players when disabled
            for _, player in pairs(Players:GetPlayers()) do
                local character = player.Character
                if character then
                    local highlight = character:FindFirstChild("ChamHighlight")
                    if highlight then
                        highlight:Destroy()
                    end
                end
            end
        end
    end
})

-- Add color picker UI for Chams
LeftGroupBox:AddLabel('Color'):AddColorPicker('ColorPicker', {
    Default = Color3.fromRGB(255, 255, 255), -- White color (default)
    Title = 'Cham Color', -- Title of the color picker
    Transparency = 0, -- Disables transparency changing for this color picker

    Callback = function(Value)
        highlightColor = Value  -- Update the highlight color when the user picks a color
        -- Update the cham color for existing players
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local highlight = player.Character:FindFirstChild("ChamHighlight")
                if highlight then
                    highlight.FillColor = highlightColor  -- Apply the new color to the existing highlight
                end
            end
        end
    end
})

-- Handle player join to ensure chams are applied
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        -- Wait until the character's root part is available before applying chams
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        if _G.chams and player ~= LocalPlayer then
            CreateCham(player)  -- Apply cham if enabled and not the local player
        end
    end)
end)

Players.PlayerRemoving:Connect(function(player)
    -- Remove cham when player leaves
    if player.Character then
        local highlight = player.Character:FindFirstChild("ChamHighlight")
        if highlight then
            highlight:Destroy()
        end
    end
end)

-- Periodically update chams for players when enabled using RunService.Heartbeat
RunService.Heartbeat:Connect(function()
    if _G.chams then
        -- Loop through all players and ensure chams are applied
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                -- Create cham if it doesn't exist for the player
                local character = player.Character
                if not character:FindFirstChild("ChamHighlight") then
                    CreateCham(player)
                end
            end
        end
    else
        -- Disable the cham effect if _G.chams is false
        for _, player in pairs(Players:GetPlayers()) do
            local character = player.Character
            if character then
                local highlight = character:FindFirstChild("ChamHighlight")
                if highlight then
                    highlight:Destroy()
                end
            end
        end
    end
end)

-- Ensure chams are applied to players who have respawned
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        -- In case a player respawns
        if _G.chams and player ~= LocalPlayer then
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            CreateCham(player)
        end
    end)
end)

-- Execute the toggle when the script is first run
if _G.chams then
    -- Enable the cham effect for players (not including local player)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            CreateCham(player)
        end
    end
else
    -- Disable the cham effect for all players
    for _, player in pairs(Players:GetPlayers()) do
        local character = player.Character
        if character then
            local highlight = character:FindFirstChild("ChamHighlight")
            if highlight then
                highlight:Destroy()
            end
        end
    end
end

LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('Name Esp')

Players = game:GetService("Players")
RunService = game:GetService("RunService")
Debris = game:GetService("Debris")  -- For cleanup
LocalPlayer = Players.LocalPlayer

displayOption = 'Username'  -- Default display option
nameTagESPEnabled = false  -- Default for the name tag ESP toggle

-- Function to create a name tag for a player
function CreateNameTag(player)
    -- Skip the local player
    if player == LocalPlayer then return end

    local character = player.Character or player.CharacterAdded:Wait()
    local head = character:WaitForChild("Head")

    -- Create BillboardGui and TextLabel for the name tag
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Parent = character
    billboardGui.Size = UDim2.new(0, 100, 0, 30)  -- Adjust the size for the name tag
    billboardGui.AlwaysOnTop = true
    billboardGui.Adornee = head
    billboardGui.StudsOffset = Vector3.new(0, 6, 0)  -- Adjust position

    local nameTag = Instance.new("TextLabel")
    nameTag.Parent = billboardGui
    nameTag.Size = UDim2.new(1, 0, 1, 0)  -- Full size of the BillboardGui
    nameTag.BackgroundTransparency = 1
    nameTag.TextColor3 = Color3.new(1, 1, 1)  -- White text color
    nameTag.TextStrokeTransparency = 0.6  -- Adjust outline visibility
    nameTag.TextStrokeColor3 = Color3.new(0, 0, 0)  -- Black stroke for visibility
    nameTag.TextSize = 10  -- Smaller base text size

    -- Set the name text based on the selected option
    if displayOption == "Username" then
        nameTag.Text = player.Name  -- Display the player's username
    else
        nameTag.Text = player.DisplayName  -- Display the player's display name
    end

    -- Cleanup when the player leaves
    Debris:AddItem(billboardGui, 5)  -- Automatically cleanup after 5 seconds
end

-- Function to remove name tags
function RemoveNameTags()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character then
            local character = player.Character
            local billboardGui = character:FindFirstChildOfClass("BillboardGui")
            if billboardGui then
                -- Cleanup with Debris service
                Debris:AddItem(billboardGui, 0)
            end
        end
    end
end

-- Add the toggle to enable or disable the Name Tag ESP
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Enable Name Tag ESP',
    Default = false,  -- Default value (true / false)
    Tooltip = 'Toggles the name tag ESP visibility.',
    Callback = function(Value)
        nameTagESPEnabled = Value
        if nameTagESPEnabled then
            -- Update name tags immediately if ESP is enabled
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    CreateNameTag(player)
                end
            end
        else
            -- If ESP is disabled, remove all name tags
            RemoveNameTags()
        end
    end
})

-- Add the dropdown for selecting between Username or DisplayName
LeftGroupBox:AddDropdown('NameDisplayOption', {
    Values = { 'DisplayName', 'Username' },
    Default = 1,  -- Default to "Username"
    Multi = false, -- Single selection only
    Text = 'Name Display Option',
    Tooltip = 'Choose whether to display the player\'s Username or DisplayName',
    Callback = function(Value)
        displayOption = Value  -- Update the display option based on dropdown selection
        if nameTagESPEnabled then
            -- Reapply name tags immediately when the dropdown value changes
            RemoveNameTags()  -- Remove existing name tags
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    CreateNameTag(player)
                end
            end
        end
    end
})

-- Periodically update name tags every heartbeat (for new players)
RunService.Heartbeat:Connect(function()
    if nameTagESPEnabled then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and not player.Character:FindFirstChildOfClass("BillboardGui") then
                CreateNameTag(player)
            end
        end
    end
end)

LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('Cash Esp')

cashESPEnabled = false
textSize = 20

-- Caching frequently used Enum values
Workspace = game:GetService("Workspace")
Ignored = Workspace:WaitForChild("Ignored")
Drop = Ignored:WaitForChild("Drop")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")

-- Function to create or update BillboardGui for MoneyDrop
function cham(object)
    if object.Name == "MoneyDrop" then
        local bill = object:FindFirstChild("BillboardGui")
        
        if bill then
            if cashESPEnabled then
                bill.AlwaysOnTop = true
                bill.Size = UDim2.new(textSize, 0, textSize / 2, 0)
                bill.Enabled = true
            else
                bill.Enabled = false
            end
        end
    end
end

-- Apply Cash ESP toggle
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Cash Esp',
    Default = false, 
    Tooltip = 'Shows cash through walls', 
    Callback = function(Value)
        cashESPEnabled = Value
    end
})

-- Apply Text Size slider functionality
LeftGroupBox:AddSlider('MySlider', {
    Text = 'Text size slider',
    Default = 20,
    Min = 5,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        textSize = Value
    end
})

-- Function to check and update ESP for all Money Drops
function updateCashESP()
    for _, v in pairs(Drop:GetChildren()) do
        cham(v)
    end
end

-- Initial check for existing Money Drops on script load
updateCashESP()

-- Connect ChildAdded event to efficiently handle new Money Drops
Drop.ChildAdded:Connect(function(child)
    -- Debris cleanup for objects not needed anymore
    Debris:AddItem(child, 60)  -- Set a lifetime for ESP objects if necessary
    cham(child)
end)

-- Use RunService.Heartbeat to periodically check and update ESP for existing Money Drops
RunService.Heartbeat:Connect(function()
    if cashESPEnabled then
        updateCashESP()  -- Continually apply the Cash ESP effect
    end
end)

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Silent Aim HvH')

getgenv().TracerEnabled = true
getgenv().AutoShootEnabled = true
getgenv().shootCooldown = 0.1
getgenv().ScriptEnabled = false
getgenv().LockKey = Enum.KeyCode.T

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Camera = game.Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local MainEvent = ReplicatedStorage:FindFirstChild("MainEvent")
local selectedPlayer = nil
local lockedPlayer = nil

local tracer = Drawing.new("Line")
tracer.Thickness = 2
tracer.Visible = false
tracer.Color = Color3.fromRGB(128, 0, 128)

if not MainEvent then
    return
end

local function isKnocked(player)
    if player and player.Character then
        local KO = player.Character:FindFirstChild("BodyEffects") and player.Character.BodyEffects:FindFirstChild("K.O")
        return KO and KO.Value == true
    end
    return false
end

local function getClosestPlayerToMouse()
    local closestPlayer = nil
    local shortestDistance = math.huge
    local mousePos = UserInputService:GetMouseLocation()

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") and not isKnocked(player) then
            local head = player.Character.Head
            local headScreenPos, onScreen = Camera:WorldToViewportPoint(head.Position)

            if onScreen then
                local distance = (Vector2.new(headScreenPos.X, headScreenPos.Y) - mousePos).Magnitude
                if distance < shortestDistance then
                    closestPlayer = player
                    shortestDistance = distance
                end
            end
        end
    end

    return closestPlayer
end

local function updateTracer()
    if getgenv().TracerEnabled and getgenv().ScriptEnabled then
        local targetPlayer = lockedPlayer or getClosestPlayerToMouse()

        if targetPlayer then
            local head = targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head")
            if head then
                local headScreenPos, onScreen = Camera:WorldToViewportPoint(head.Position)

                if onScreen then
                    selectedPlayer = targetPlayer
                    tracer.Visible = true
                    tracer.To = Vector2.new(headScreenPos.X, headScreenPos.Y)
                    tracer.From = UserInputService:GetMouseLocation()
                end
            end
        else
            tracer.Visible = false
        end
    end
end

local function shoot()
    if lockedPlayer and lockedPlayer.Character and not isKnocked(lockedPlayer) and getgenv().ScriptEnabled then
        local targetHead = lockedPlayer.Character:FindFirstChild("Head")
        local Tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")

        if Tool and Tool:FindFirstChild("Handle") and targetHead then
            MainEvent:FireServer(
                "ShootGun",
                Tool.Handle,
                Tool.Handle.Position,
                targetHead.Position,
                targetHead,
                Vector3.new(0, 0, 0)
            )
        end
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == getgenv().LockKey and not gameProcessed then
        if getgenv().ScriptEnabled then
            if lockedPlayer then
                lockedPlayer = nil
            else
                lockedPlayer = getClosestPlayerToMouse()
            end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if getgenv().ScriptEnabled then
        updateTracer()

        if lockedPlayer then
            shoot()
        end
    else
        tracer.Visible = false
    end
end)

LeftGroupBox:AddToggle('ScriptToggle', {
    Text = 'Toggle Silent Aim',
    Default = false,

    Callback = function(Value)
        if Value then
            getgenv().ScriptEnabled = true
        else
            getgenv().ScriptEnabled = false
            tracer.Visible = false
        end
    end
})

LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
    Default = 'T',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Silent Aim Keybind',
    NoUI = false,

    Callback = function(Value)
    end,

    ChangedCallback = function(New)
        getgenv().LockKey = New
    end
})

RightGroupBox = Tabs.Main:AddRightGroupbox('Kill Aura')

RightGroupBox:AddToggle('MyToggle', {
    Text = 'Toggle KillAura',
    Default = false,
    Tooltip = 'Enables The KillAura Feature',
    Callback = function(Value)
        if Value then
        player = game:GetService("Players").LocalPlayer
        runService = game:GetService("RunService")
        workspace = game:GetService("Workspace")

        range = 100
        killAuraEnabled = true

        local lastDamagedPlayer = nil

        function isGunEquipped()
            local character = player.Character
            if character then
                local tool = character:FindFirstChildWhichIsA("Tool")
                return tool and tool:FindFirstChild("Handle") ~= nil
            end
            return false
        end

        function isTargetValid(targetCharacter)
            if targetCharacter then
                local bodyEffects = targetCharacter:FindFirstChild("BodyEffects")
                local KOd = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
                local Grabbed = targetCharacter:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
                return not KOd and not Grabbed
            end
            return false
        end

        function getNearestPlayer()
            local character = player.Character
            local rootPart = character and character:FindFirstChild("HumanoidRootPart")
            local nearestPlayer = nil
            local shortestDistance = range

            if rootPart then
                for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
                    if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and isTargetValid(plr.Character) then
                        local targetRootPart = plr.Character:FindFirstChild("HumanoidRootPart")
                        local distance = (targetRootPart.Position - rootPart.Position).Magnitude

                        if distance <= shortestDistance then
                            nearestPlayer = plr
                            shortestDistance = distance
                        end
                    end
                end
            end
            return nearestPlayer
        end

        function shootNearestPlayer()
            if not killAuraEnabled or not isGunEquipped() then
                return
            end

            local character = player.Character
            local rootPart = character and character:FindFirstChild("HumanoidRootPart")
            local tool = character and character:FindFirstChildWhichIsA("Tool") or player.Backpack:FindFirstChildWhichIsA("Tool")
            local targetPlayer = getNearestPlayer()

            if tool and tool:FindFirstChild("Handle") and rootPart and targetPlayer and targetPlayer.Character then
                local targetHead = targetPlayer.Character:FindFirstChild("Head")
                if targetHead then
                    local direction = (targetHead.Position - rootPart.Position).unit
                    game:GetService("ReplicatedStorage"):WaitForChild("MainEvent"):FireServer("ShootGun", tool.Handle, rootPart.Position, targetHead.Position, targetHead, direction)
                end
            end
        end

        runService.Heartbeat:Connect(function()
            if killAuraEnabled then
                shootNearestPlayer()
            end
        end)  
        else
            killAuraEnabled = false
        end
    end
})

local ESPSection = Tabs.Visuals:AddLeftGroupbox('ESP Settings')

local ESPEnabled = false
local ESPConnections = {}
local ESPObjects = {}
local DisplayOption = "Username"

local function ToggleESP(Value)
    ESPEnabled = Value
    if not Value then
        for _, connection in ipairs(ESPConnections) do
            connection:Disconnect()
        end
        ESPConnections = {}
        for _, obj in pairs(ESPObjects) do
            if obj then
                obj:Destroy()
            end
        end
        ESPObjects = {}
    else
        for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
            if not ESPObjects[player] then
                CreateESP(player)
            end
        end
    end
end

local Settings = {
    Box_Color = Color3.fromRGB(255, 255, 255), -- Set box outline to white
    Box_Thickness = 2,
    Team_Check = false,
    Team_Color = false,
    Autothickness = true,
    ESP_Active = false, -- To control ESP activation
}

ESPSection:AddToggle('ESP_Toggle', {
    Text = 'Corner Boxes',
    Default = false, -- ESP is inactive by default
    Tooltip = 'Toggle the visibility of the corner ESP boxes.',
    Callback = function(Value)
        Settings.ESP_Active = Value -- Set the global setting to the toggle value
    end
})

local Space = game:GetService("Workspace")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Camera = Space.CurrentCamera
local RunService = game:GetService("RunService")

local function NewLine(color, thickness)
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = color
    line.Thickness = thickness
    line.Transparency = 1
    return line
end

local function Vis(lib, state)
    for i, v in pairs(lib) do
        v.Visible = state
    end
end

local function Colorize(lib, color)
    for i, v in pairs(lib) do
        v.Color = color
    end
end

local function Main(plr)
    repeat wait() until plr.Character and plr.Character:FindFirstChild("Humanoid")
    
    local R15 = plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R15
    local Library = {
        TL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness)
    }

    local oripart = Instance.new("Part")
    oripart.Parent = Space
    oripart.Transparency = 1
    oripart.CanCollide = false
    oripart.Size = Vector3.new(1, 1, 1)
    oripart.Position = Vector3.new(0, 0, 0)

        local function Updater()
        local c
        c = RunService.RenderStepped:Connect(function()
            if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") then
                local Hum = plr.Character
                local HumPos, vis = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position)

                if vis then
                    oripart.Size = Vector3.new(Hum.HumanoidRootPart.Size.X, Hum.HumanoidRootPart.Size.Y * 1.5, Hum.HumanoidRootPart.Size.Z)
                    oripart.CFrame = CFrame.new(Hum.HumanoidRootPart.CFrame.Position, Camera.CFrame.Position)
                    local SizeX = oripart.Size.X
                    local SizeY = oripart.Size.Y
                    local TL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(SizeX, SizeY, 0)).p)
                    local TR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-SizeX, SizeY, 0)).p)
                    local BL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(SizeX, -SizeY, 0)).p)
                    local BR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-SizeX, -SizeY, 0)).p)

                    if Settings.Team_Check then
                        if plr.TeamColor == Player.TeamColor then
                            Colorize(Library, Color3.fromRGB(0, 255, 0))
                        else
                            Colorize(Library, Color3.fromRGB(255, 0, 0))
                        end
                    end

                    if Settings.Team_Color then
                        Colorize(Library, plr.TeamColor.Color)
                    end

                    local ratio = (Camera.CFrame.p - Hum.HumanoidRootPart.Position).magnitude
                    local offset = math.clamp(1 / ratio * 750, 2, 300)

                    Library.TL1.From = Vector2.new(TL.X, TL.Y)
                    Library.TL1.To = Vector2.new(TL.X + offset, TL.Y)
                    Library.TL2.From = Vector2.new(TL.X, TL.Y)
                    Library.TL2.To = Vector2.new(TL.X, TL.Y + offset)

                    Library.TR1.From = Vector2.new(TR.X, TR.Y)
                    Library.TR1.To = Vector2.new(TR.X - offset, TR.Y)
                    Library.TR2.From = Vector2.new(TR.X, TR.Y)
                    Library.TR2.To = Vector2.new(TR.X, TR.Y + offset)

                    Library.BL1.From = Vector2.new(BL.X, BL.Y)
                    Library.BL1.To = Vector2.new(BL.X + offset, BL.Y)
                    Library.BL2.From = Vector2.new(BL.X, BL.Y)
                    Library.BL2.To = Vector2.new(BL.X, BL.Y - offset)

                    Library.BR1.From = Vector2.new(BR.X, BR.Y)
                    Library.BR1.To = Vector2.new(BR.X - offset, BR.Y)
                    Library.BR2.From = Vector2.new(BR.X, BR.Y)
                    Library.BR2.To = Vector2.new(BR.X, BR.Y - offset)

                    Vis(Library, Settings.ESP_Active)

                    if Settings.Autothickness then
                        local distance = (Player.Character.HumanoidRootPart.Position - oripart.Position).magnitude
                        local value = math.clamp(1 / distance * 100, 1, 4) --0.1 is min thickness, 6 is max
                        for u, x in pairs(Library) do
                            x.Thickness = value
                        end
                    else
                        for u, x in pairs(Library) do
                            x.Thickness = Settings.Box_Thickness
                        end
                    end
                else
                    Vis(Library, false)
                end
            else
                Vis(Library, false)
                if not Players:FindFirstChild(plr.Name) then
                    for i, v in pairs(Library) do
                        v:Remove()
                    end
                    oripart:Destroy()
                    c:Disconnect()
                end
            end
        end)
    end
    coroutine.wrap(Updater)()
end

for _, v in pairs(Players:GetPlayers()) do
    if v.Name ~= Player.Name then
        coroutine.wrap(Main)(v)
    end
end

Players.PlayerAdded:Connect(function(newplr)
    coroutine.wrap(Main)(newplr)
end)

local LeftGroupBox = Tabs.Misc:AddLeftGroupbox('anti-void')

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

local teleportHeight = 500
local antiVoidEnabled = false

LeftGroupBox:AddToggle('AntiVoidToggle', {
    Text = 'Enable Anti-Void',
    Default = false,
    Tooltip = 'Prevents falling into the void by teleporting up',

    Callback = function(Value)
        antiVoidEnabled = Value
        print('[cb] AntiVoidToggle changed to:', Value)
    end
})

LeftGroupBox:AddSlider('TeleportHeightSlider', {
    Text = 'Studs it teleports up', 
    Default = 500,
    Min = 100,
    Max = 1000,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        teleportHeight = Value
        print('[cb] Teleport height changed to:', Value)
    end
})

local function antiVoidCheck()
    if antiVoidEnabled and rootPart and rootPart.Position.Y <= -150 then
        rootPart.CFrame = rootPart.CFrame + Vector3.new(0, teleportHeight, 0)
    end
end

local connection
connection = RunService.Heartbeat:Connect(antiVoidCheck)

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    rootPart = character:WaitForChild("HumanoidRootPart")
end)

 LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('No Fog')

    local lighting = game:GetService("Lighting")
    local StarterGui = game:GetService("StarterGui")
    local debris = game:GetService("Debris")

    -- Store common values in variables to minimize repetitive calls
    local fogEnd = lighting.FogEnd
    local fogStart = lighting.FogStart

    -- Create the toggle button (integrated from your provided example)
    LeftGroupBox:AddToggle('MyToggle', {
    Text = 'No Fog',
    Default = false, -- Default value (true / false)
    Tooltip = 'This removes any kind of Fog from the game', -- Information shown when you hover over the toggle

    Callback = function(Value)
        if Value then
            -- Check if the fog removal has been executed before
            if not _G.FogRemovalExecuted then
                -- Store original fog settings
                _G.OriginalFogSettings = {
                    FogEnd = fogEnd,
                    FogStart = fogStart,
                }

                lighting.FogEnd = 100000  -- Set this to a high value to push fog far away
                lighting.FogStart = 0     -- Set this to 0 to ensure fog doesn't start close

                local atmosphere = lighting:FindFirstChildOfClass("Atmosphere")
                if atmosphere then
                    atmosphere:Destroy()
                end

                _G.FogRemovalExecuted = true
            end
        else
            if _G.FogRemovalExecuted then
                lighting.FogEnd = _G.OriginalFogSettings.FogEnd
                lighting.FogStart = _G.OriginalFogSettings.FogStart

                _G.FogRemovalExecuted = false
            end
        end

        print('[cb] MyToggle changed to:', Value)
    end
    })

    LeftGroupBox = Tabs.Visuals:AddRightGroupbox('Fullbright')

    LeftGroupBox:AddToggle('MyToggle', {
        Text = 'Fullbright',
        Default = false, -- Default value (true / false)
        Tooltip = 'Removes shadows and increases brightness', -- Information shown when you hover over the toggle
    
        Callback = function(Value)
            if not _G.FullBrightExecuted then
                _G.FullBrightEnabled = false
    
                local Lighting = game:GetService("Lighting")
                
                -- Store default settings in a table
                _G.NormalLightingSettings = {
                    Brightness = Lighting.Brightness,
                    ClockTime = Lighting.ClockTime,
                    GlobalShadows = Lighting.GlobalShadows,
                    Ambient = Lighting.Ambient
                }
    
                -- Full Bright settings
                local FullBrightSettings = {
                    Brightness = 1,
                    ClockTime = 12,
                    GlobalShadows = false,
                    Ambient = Color3.fromRGB(178, 178, 178)
                }
    
                -- Set lighting properties
                local function setLightingProperties(properties)
                    for property, value in pairs(properties) do
                        Lighting[property] = value
                    end
                end
    
                -- Initial setup
                setLightingProperties(FullBrightSettings)
    
                -- Create a single function to handle property changes
                local function createPropertyChangeListener(property, defaultValue, newValue)
                    Lighting:GetPropertyChangedSignal(property):Connect(function()
                        if Lighting[property] ~= defaultValue and Lighting[property] ~= _G.NormalLightingSettings[property] then
                            _G.NormalLightingSettings[property] = Lighting[property]
                            if not _G.FullBrightEnabled then
                                repeat wait() until _G.FullBrightEnabled
                            end
                            Lighting[property] = newValue
                        end
                    end)
                end
    
                -- Set up property listeners
                for property, newValue in pairs(FullBrightSettings) do
                    createPropertyChangeListener(property, newValue, newValue)
                end
    
                -- Periodically toggle FullBright settings
                local LatestValue = true
                spawn(function()
                    while wait() do
                        if _G.FullBrightEnabled ~= LatestValue then
                            if not _G.FullBrightEnabled then
                                setLightingProperties(_G.NormalLightingSettings)
                            else
                                setLightingProperties(FullBrightSettings)
                            end
                            LatestValue = not LatestValue
                        end
                    end
                end)
            end
    
            -- Toggle full bright state
            _G.FullBrightExecuted = true
            _G.FullBrightEnabled = Value -- directly using Value here to toggle the state
        end
    })    

LeftGroupBox = Tabs.Visuals:AddRightGroupbox('Ambience')

local lighting = game:GetService("Lighting")
local StarterGui = game:GetService("StarterGui")
local runService = game:GetService("RunService")
local debris = game:GetService("Debris")

if not _G.OriginalLightingSettings then
    _G.OriginalLightingSettings = {
        Ambient = lighting.Ambient,
        OutdoorAmbient = lighting.OutdoorAmbient,
        Brightness = lighting.Brightness,
        ColorShift_Bottom = lighting.ColorShift_Bottom,
        ColorShift_Top = lighting.ColorShift_Top,
        FogColor = lighting.FogColor,
        FogStart = lighting.FogStart,
        FogEnd = lighting.FogEnd,
        TimeOfDay = lighting.TimeOfDay,
        Skybox = lighting:FindFirstChildOfClass("Sky"), -- Ensure no errors if skybox doesn't exist
        ClockTime = lighting.ClockTime
    }
end

local selectedAmbientColor = _G.OriginalLightingSettings.Ambient
local selectedOutdoorAmbientColor = _G.OriginalLightingSettings.OutdoorAmbient
local selectedColorShiftBottom = _G.OriginalLightingSettings.ColorShift_Bottom
local selectedColorShiftTop = _G.OriginalLightingSettings.ColorShift_Top
local selectedFogColor = _G.OriginalLightingSettings.FogColor

local skyboxAssetID = "rbxassetid://1294489738"

-- Add the toggle for the royal purple ambience
LeftGroupBox:AddToggle('AmbienceToggle', {
    Text = 'Enable Custom Ambient Lighting',
    Default = false, -- Default value (true / false)
    Tooltip = 'Toggle to switch between original and custom ambient lighting',

    Callback = function(Value)
        if Value then
            -- Apply the altered custom ambient lighting settings
            lighting.Ambient = selectedAmbientColor
            lighting.OutdoorAmbient = selectedOutdoorAmbientColor
            lighting.Brightness = 2
            lighting.ColorShift_Bottom = selectedColorShiftBottom
            lighting.ColorShift_Top = selectedColorShiftTop
            lighting.FogColor = selectedFogColor
            lighting.FogStart = 0
            lighting.FogEnd = 500
            lighting.TimeOfDay = "18:00:00"

            -- Set a custom skybox for the custom ambience
            local skybox = lighting:FindFirstChildOfClass("Sky")
            if not skybox then
                skybox = Instance.new("Sky")
                skybox.Parent = lighting
            end
            skybox.SkyboxBk = skyboxAssetID
            skybox.SkyboxDn = skyboxAssetID
            skybox.SkyboxFt = skyboxAssetID
            skybox.SkyboxLf = skyboxAssetID
            skybox.SkyboxRt = skyboxAssetID
            skybox.SkyboxUp = skyboxAssetID

            -- Set the flag to indicate that the lighting has been altered
            _G.AmbienceToggled = true

            -- Immediately set the time of day to the current slider value when toggle is enabled
            lighting.ClockTime = _G.ClockTimeOverride or 17 -- Default to the slider value if set
        else
            -- Reset the lighting back to the original settings
            lighting.Ambient = _G.OriginalLightingSettings.Ambient
            lighting.OutdoorAmbient = _G.OriginalLightingSettings.OutdoorAmbient
            lighting.Brightness = _G.OriginalLightingSettings.Brightness
            lighting.ColorShift_Bottom = _G.OriginalLightingSettings.ColorShift_Bottom
            lighting.ColorShift_Top = _G.OriginalLightingSettings.ColorShift_Top
            lighting.FogColor = _G.OriginalLightingSettings.FogColor
            lighting.FogStart = _G.OriginalLightingSettings.FogStart
            lighting.FogEnd = _G.OriginalLightingSettings.FogEnd
            lighting.TimeOfDay = _G.OriginalLightingSettings.TimeOfDay

            local sky = lighting:FindFirstChildOfClass("Sky")
            if sky then
                debris:AddItem(sky, 1) -- Use debris to clean up skybox instance
            end

            if _G.OriginalLightingSettings.Skybox then
                local originalSkybox = _G.OriginalLightingSettings.Skybox:Clone()
                originalSkybox.Parent = lighting
            end

            _G.AmbienceToggled = false
        end
    end
})

LeftGroupBox:AddSlider('BrightnessSlider', { 
    Text = 'Brightness Control',
    Default = 10,  -- Set initial brightness to 2 (adjust if needed)
    Min = 0,
    Max = 20,  -- Max brightness set to 20
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        -- Immediately change the lighting brightness live based on slider value
        lighting.Brightness = Value
    end
})

-- Add the slider to control fog end with max value set to 1000
LeftGroupBox:AddSlider('FogEndSlider', { 
    Text = 'Fog End Control',
    Default = 500,  -- Set initial fog end to 500 (adjust if needed)
    Min = 100,
    Max = 10000,  -- Max fog end set to 100000
    Rounding = 0,
    Compact = false,

    Callback = function(Value)
        lighting.FogEnd = Value
    end
})

LeftGroupBox:AddSlider('TimeOfDaySlider', { 
    Text = 'Time of Day Control',
    Default = 17,  -- Set initial time to 12:00 (adjust if needed)
    Min = 0,
    Max = 24,  -- 24-hour format for time of day
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        -- Lock the time of day client-side by setting it
        if _G.AmbienceToggled then
            lighting.ClockTime = Value
            -- Save the desired value so it stays fixed
            _G.ClockTimeOverride = Value
        end
    end
})

runService.Heartbeat:Connect(function()
    if _G.AmbienceToggled and _G.ClockTimeOverride then
        lighting.ClockTime = _G.ClockTimeOverride
    end
end)

LeftGroupBox:AddLabel('Ambient Color Picker'):AddColorPicker('AmbientColorPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default royal purple
    Title = 'Select Ambient Color',
    Transparency = 0,  -- Optional

    Callback = function(Value)
        selectedAmbientColor = Value
        if _G.AmbienceToggled then
            lighting.Ambient = selectedAmbientColor
        end
    end
})

LeftGroupBox:AddLabel('Outdoor Ambient Color Picker'):AddColorPicker('OutdoorAmbientColorPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default color
    Title = 'Select Outdoor Ambient Color',

    Callback = function(Value)
        selectedOutdoorAmbientColor = Value
        if _G.AmbienceToggled then
            lighting.OutdoorAmbient = selectedOutdoorAmbientColor
        end
    end
})

LeftGroupBox:AddLabel('Color Shift Bottom Picker'):AddColorPicker('ColorShiftBottomPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default color
    Title = 'Select Color Shift Bottom',

    Callback = function(Value)
        selectedColorShiftBottom = Value
        if _G.AmbienceToggled then
            lighting.ColorShift_Bottom = selectedColorShiftBottom
        end
    end
})

LeftGroupBox:AddLabel('Color Shift Top Picker'):AddColorPicker('ColorShiftTopPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default color
    Title = 'Select Color Shift Top',

    Callback = function(Value)
        selectedColorShiftTop = Value
        if _G.AmbienceToggled then
            lighting.ColorShift_Top = selectedColorShiftTop
        end
    end
})

LeftGroupBox:AddLabel('Fog Color Picker'):AddColorPicker('FogColorPicker', {
    Default = Color3.fromRGB(120, 81, 169),  -- Default color
    Title = 'Select Fog Color',

    Callback = function(Value)
        selectedFogColor = Value
        if _G.AmbienceToggled then
            lighting.FogColor = selectedFogColor
        end
    end
})

LeftGroupBox = Tabs.Movement:AddLeftGroupbox('Speed')

    --// Required Services and Variables
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local KeyCode = Enum.KeyCode -- Store Enum for repeated use

    -- Utility Functions
    local Utility = {
    hasCharacter = function(player)
        local character = player and player.Character
        return character and character:FindFirstChild("HumanoidRootPart", true) and character:FindFirstChild("Humanoid", true)
    end,
    newConnection = function(event, callback)
        return event:Connect(callback)
    end
    }

    -- Configuration Flags
    local Flags = {
    cframeSpeedEnabled = false, -- Initially off
    cframeSpeedToggleAllowed = false, -- Toggle must be enabled via UI
    cframeSpeedKeybind = KeyCode.V, -- Default toggle key set to V
    cframeSpeedAmount = 150 -- Default speed
    }

    -- CFrame Speed Functionality
    local function updateCframeSpeed(deltaTime)
    if Flags.cframeSpeedEnabled and Utility.hasCharacter(LocalPlayer) then
        local character = LocalPlayer.Character
        local hrp = character:FindFirstChild("HumanoidRootPart", true)
        local humanoid = character:FindFirstChild("Humanoid", true)
        local moveDirection = humanoid and humanoid.MoveDirection

        if hrp and moveDirection then
            local movement = moveDirection.Unit * Flags.cframeSpeedAmount * deltaTime
            if movement.Magnitude > 0 then
                hrp.CFrame = hrp.CFrame + movement
            end
        end
    end
    end

    -- UI Integration
    LeftGroupBox:AddToggle('CframeSpeedToggle', {
    Text = 'Toggle CFrame Speed',
    Default = false,
    Tooltip = 'Toggles speed using CFrames',
    Callback = function(value)
        Flags.cframeSpeedToggleAllowed = value
        if not value then
            Flags.cframeSpeedEnabled = false
        end
    end
    })

    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('CframeSpeedKeybind', {
    Default = 'V',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Toggle CFrame Speed',
    NoUI = false,
    Callback = function(value)
        if value and typeof(value) == "EnumItem" then
            Flags.cframeSpeedKeybind = KeyCode[value.Name]
        end
    end,
    ChangedCallback = function(newValue)
        if newValue and typeof(newValue) == "EnumItem" then
            Flags.cframeSpeedKeybind = KeyCode[newValue.Name]
        end
    end
    })

    LeftGroupBox:AddSlider('CframeSpeedSlider', {
    Text = 'CFrame Speed Amount',
    Default = 150,
    Min = 16,
    Max = 1000,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        Flags.cframeSpeedAmount = value
    end
    })

    -- RenderStepped Connection for CFrame Speed
    if _G.cframeSpeedRenderSteppedConnection then
    _G.cframeSpeedRenderSteppedConnection:Disconnect()
    end
    _G.cframeSpeedRenderSteppedConnection = RunService.Heartbeat:Connect(updateCframeSpeed)

    -- Input Listener for Keybind
    if _G.cframeSpeedToggleListener then
    _G.cframeSpeedToggleListener:Disconnect()
    end
    _G.cframeSpeedToggleListener = Utility.newConnection(UserInputService.InputBegan, function(input, gameProcessed)
    if gameProcessed then return end

    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Flags.cframeSpeedKeybind then
        if Flags.cframeSpeedToggleAllowed then
            Flags.cframeSpeedEnabled = not Flags.cframeSpeedEnabled
        end
    end
    end)

    LeftGroupBox = Tabs.Movement:AddLeftGroupbox('Fly')

    --// Required Services and Variables
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local KeyCode = Enum.KeyCode -- Store Enum for repeated use

    -- Utility Functions
    local Utility = {
    hasCharacter = function(player)
        local character = player and player.Character
        return character and character:FindFirstChild("HumanoidRootPart", true) and character:FindFirstChild("Humanoid", true)
    end,
    newConnection = function(event, callback)
        return event:Connect(callback)
    end
    }

    -- Configuration Flags
    local Flags = {
    rageCFrameFlyEnabled = false, -- Initially off
    rageCFrameFlyToggleAllowed = false, -- Toggle must be enabled via UI
    rageCFrameFlyKeybind = KeyCode.B, -- Default toggle key set to B
    rageCFrameFlyAmount = 250 -- Default fly speed
    }

    -- Fly Functionality
    local function updateFly(deltaTime)
    if Flags.rageCFrameFlyEnabled and Utility.hasCharacter(LocalPlayer) then
        local character = LocalPlayer.Character
        local hrp = character:FindFirstChild("HumanoidRootPart", true)
        local moveDirection = character:FindFirstChild("Humanoid", true).MoveDirection

        -- Vertical movement based on key input
        local verticalSpeed = (UserInputService:IsKeyDown(KeyCode.Space) and 1 or UserInputService:IsKeyDown(KeyCode.LeftShift) and -1 or 0)
        local verticalMovement = Vector3.new(0, verticalSpeed, 0)

        -- Combine horizontal and vertical movement for consistent speed
        local movement = (moveDirection + verticalMovement).Unit * Flags.rageCFrameFlyAmount * deltaTime

        -- Update position using CFrame
        if movement.Magnitude > 0 then
            hrp.CFrame = hrp.CFrame + movement
        end

        -- Adjust velocity to prevent conflicts
        hrp.Velocity = Vector3.zero
    end
    end

    -- UI Integration
    LeftGroupBox:AddToggle('CframeFlightToggle', {
    Text = 'Toggle Cframe Flight',
    Default = false,
    Tooltip = 'Toggles flight using CFrames',
    Callback = function(value)
        Flags.rageCFrameFlyToggleAllowed = value
        if not value then
            Flags.rageCFrameFlyEnabled = false
        end
    end
    })

    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('FlightKeybind', {
    Default = 'B',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Toggle Cframe Flight',
    NoUI = false,

    Callback = function(value)
        if value and typeof(value) == "EnumItem" then
            Flags.rageCFrameFlyKeybind = KeyCode[value.Name]
        end
    end,

    ChangedCallback = function(newValue)
        if newValue and typeof(newValue) == "EnumItem" then
            Flags.rageCFrameFlyKeybind = KeyCode[newValue.Name]
        end
    end
    })

    LeftGroupBox:AddSlider('CframeFlightSpeed', {
    Text = 'CFrame Flight Speed',
    Default = 250,
    Min = 16,
    Max = 2000,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        Flags.rageCFrameFlyAmount = value
    end
    })

    -- RenderStepped Connection for Flight
    if _G.flyRenderSteppedConnection then
    _G.flyRenderSteppedConnection:Disconnect()
    end
    _G.flyRenderSteppedConnection = RunService.Heartbeat:Connect(updateFly)

    -- Input Listener for Keybind
    if _G.flyToggleListener then
    _G.flyToggleListener:Disconnect()
    end
    _G.flyToggleListener = Utility.newConnection(UserInputService.InputBegan, function(input, gameProcessed)
    if gameProcessed then return end

    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Flags.rageCFrameFlyKeybind then
        if Flags.rageCFrameFlyToggleAllowed then
            Flags.rageCFrameFlyEnabled = not Flags.rageCFrameFlyEnabled
        end
    end
    end)

 LeftGroupBox = Tabs.Movement:AddLeftGroupbox('Fake Macro')

    LeftGroupBox:AddToggle('MyToggle', {
        Text = 'Fake Macro',
        Default = false,
        Tooltip = 'Activates fake macro!',
    
        Callback = function(Value)
            print('[cb] MyToggle changed to:', Value)
            
            -- Toggle the speed feature based on the toggle value
            if Value then
                _G.ScriptEnabled = true
                resetCharacter()
            else
                _G.ScriptEnabled = false
            end
        end
    })
    
    player = game.Players.LocalPlayer
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    emoteId = "rbxassetid://3189777795"
    
    -- Speed variables
    maxSpeed = 300
    baseSpeed = 16
    speedIncrement = 1.75
    emoteDuration = 1.6 -- Default emote duration
    
    -- Variables to track speed and state
    currentSpeed = baseSpeed
    isSpeedEnabled = false
    emoteTrack = nil
    isSpeedReady = false
    
    -- Cache the hotkey (Q) for reuse
    Keybind = Enum.KeyCode.Q
    
    -- Efficient use of services and enum values
    UserInputService = game:GetService("UserInputService")
    RunService = game:GetService("RunService")
    
    -- Function to initialize the character and humanoid
    function initializeCharacter(newCharacter)
        character = newCharacter or player.Character
        humanoid = character:WaitForChild("Humanoid")
        currentSpeed = baseSpeed
        humanoid.WalkSpeed = baseSpeed
        isSpeedEnabled = false
        isSpeedReady = false
    end
    
    -- Function to forcefully reset the character
    function resetCharacter()
        if humanoid then
            humanoid.Health = 0
        end
    end
    
    -- Function to play the emote
    function playEmote()
        animation = Instance.new("Animation")
        animation.AnimationId = emoteId
        emoteTrack = humanoid:LoadAnimation(animation)
        emoteTrack:Play()
    
        -- Stop the emote after the duration from the slider
        task.wait(emoteDuration)
        if emoteTrack and emoteTrack.IsPlaying then
            emoteTrack:Stop()
        end
    
        -- After the emote ends, set isSpeedReady to true to start gradual speed increase
        isSpeedReady = true
    end
    
    -- Function to manage speed (gradual increase)
    function updateSpeed()
        if _G.ScriptEnabled and isSpeedEnabled then
            if isSpeedReady then
                currentSpeed = math.min(currentSpeed + speedIncrement, maxSpeed)
                humanoid.WalkSpeed = currentSpeed
            else
                humanoid.WalkSpeed = baseSpeed
            end
        elseif not isSpeedEnabled or not _G.ScriptEnabled then
            humanoid.WalkSpeed = baseSpeed
            currentSpeed = baseSpeed
        end
    end
    
    -- Toggle the speed feature
    function toggleSpeedFeature()
        if not _G.ScriptEnabled then return end
        isSpeedEnabled = not isSpeedEnabled
        if isSpeedEnabled then
            currentSpeed = baseSpeed
            humanoid.WalkSpeed = baseSpeed
            isSpeedReady = false
            playEmote()
        else
            currentSpeed = baseSpeed
            humanoid.WalkSpeed = baseSpeed
            isSpeedReady = false
        end
    end
    
    -- Reinitialize the script on character respawn
    player.CharacterAdded:Connect(initializeCharacter)
    
    -- Bind the hotkey (Q) to toggle the feature
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if _G.ScriptEnabled and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Keybind then
            toggleSpeedFeature()
        end
    end)
    
    -- Do not reset character immediately on script load, only when toggle is true
    if _G.ScriptEnabled then
        resetCharacter()
    end
    
    -- Bind RunService Heartbeat to continuously update speed
    RunService.Heartbeat:Connect(updateSpeed)
    
    -- Initialize the script for the current character
    initializeCharacter(character)
    
    -- Add KeyPicker for dynamic hotkey
    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', { 
        Default = 'Q', -- Initial keybind (can be changed)
        SyncToggleState = false,
        Mode = 'Toggle', -- Modes: Always, Toggle, Hold
        Text = 'Speed Toggle Keybind',
    
        Callback = function(Value)
            print('[cb] Keybind clicked!', Value)
        end,
    
        ChangedCallback = function(New)
            print('[cb] Keybind changed!', New)
            -- Update the hotkey to the new key selected
            Keybind = New
        end
    })
    
    -- Add Slider for emote duration
    LeftGroupBox:AddSlider('EmoteDuration', {
        Text = 'Emote Duration (Seconds)',
        Default = 1.6,
        Min = 0,
        Max = 2.5,
        Rounding = 2,
        Compact = false,
    
        Callback = function(Value)
            print('[cb] Emote Duration changed! New value:', Value)
            emoteDuration = Value
        end
    })
    
    -- Add Slider for max speed
    LeftGroupBox:AddSlider('MaxSpeed', {
        Text = 'Max Speed',
        Default = 300,
        Min = 16,
        Max = 1000, -- Adjust max limit as needed
        Rounding = 0,
        Compact = false,
    
        Callback = function(Value)
            print('[cb] Max Speed changed! New value:', Value)
            maxSpeed = Value
        end
    })
    
    -- Add Slider for speed increment
    LeftGroupBox:AddSlider('SpeedIncrement', {
        Text = 'Speed Increment',
        Default = 1.75,
        Min = 0.1,
        Max = 10,
        Rounding = 2,
        Compact = false,
    
        Callback = function(Value)
            print('[cb] Speed Increment changed! New value:', Value)
            speedIncrement = Value
        end
    })    

 LeftGroupBox = Tabs.Movement:AddLeftGroupbox('Jump settings') 

    -- Function to handle enabling/disabling the no jump cooldown feature
    local function toggleNoJumpCooldown(enabled)
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")

    -- Helper function to update the humanoid's jump settings
    local function updateJumpSettings(humanoid, state)
        humanoid.UseJumpPower = not state -- Disable cooldown when `enabled` is true
        print("Jump cooldown " .. (state and "disabled!" or "enabled!"))
    end

    -- Apply the setting to the current humanoid
    updateJumpSettings(humanoid, enabled)

    -- Monitor for respawn and reapply the no jump cooldown setting if enabled
    player.CharacterAdded:Connect(function(newCharacter)
        local newHumanoid = newCharacter:WaitForChild("Humanoid")
        updateJumpSettings(newHumanoid, enabled)
    end)
    end

    -- Add a toggle to the UI
    LeftGroupBox:AddToggle('NoJumpCooldownToggle', {
    Text = 'Toggle No Jump Cooldown',
    Default = false, -- Default value (true / false)
    Tooltip = 'Toggles the jump cooldown on or off', -- Information shown when you hover over the toggle

    Callback = function(value)
        -- Update the global state and toggle the feature
        _G.noJumpCooldownEnabled = value
        toggleNoJumpCooldown(value)
        print('[cb] NoJumpCooldownToggle changed to:', value)
    end
    })

    -- Optimized example: Instead of repeatedly using :FindFirstChild, store the result in a variable
    local part = workspace:FindFirstChild("MyPart")
    if part then
    -- Perform actions with the part
    print("Found part:", part.Name)
    end

    LeftGroupBox = Tabs.Movement:AddLeftGroupbox('Anti Slow')

    local gh = false -- Set to true to enable Anti-Slow, false to disable it.
    local debris = game:GetService("Debris") -- Access Debris service for cleanup
    local player = game.Players.LocalPlayer
    local toggleValue = false -- Store the current state of the toggle

    -- Replace the print statements with your NotifyLibrary.Notify call once it's defined
    local function notify(title, description)
    print(title .. ": " .. description)
    end

    -- Anti-slow logic that gets activated based on the toggle value
    local function antiSlowToggle(value)
    if value == true then
        gh = true

        -- Use RunService once and bind the logic only when enabled
        game:GetService('RunService'):BindToRenderStep("Anti-Slow", 0 , function()
            if player.Character then
                local bodyEffects = player.Character:WaitForChild("BodyEffects", 10)
                local movement = bodyEffects and bodyEffects:WaitForChild("Movement", 10)
                
                if movement then
                    -- Only check for the existence of these once and remove them if found
                    local noWalkSpeed = movement:FindFirstChild("NoWalkSpeed")
                    if noWalkSpeed then
                        noWalkSpeed:Destroy()
                    end
                    
                    local reduceWalk = movement:FindFirstChild("ReduceWalk")
                    if reduceWalk then
                        reduceWalk:Destroy()
                    end
                    
                    local noJumping = movement:FindFirstChild("NoJumping")
                    if noJumping then
                        noJumping:Destroy()
                    end
                end

                -- Use a more efficient way to check and modify the reload value
                if bodyEffects and bodyEffects.Reload and bodyEffects.Reload.Value == true then
                    bodyEffects.Reload.Value = false
                end
            end
        end)
    else
        gh = false

        -- Cleanup properly and unbind RunService
        game:GetService('RunService'):UnbindFromRenderStep("Anti-Slow")
    end
    end

    -- Integrate with the UI toggle, add it only once
    if not _G.AntiSlowToggle then
    LeftGroupBox:AddToggle('MyToggle', {
        Text = 'Anti Slow',
        Default = false, -- Default value (true / false)
        Tooltip = 'Removes any kind of slowness', -- Information shown when you hover over the toggle

        Callback = function(Value)
            toggleValue = Value
            antiSlowToggle(Value)  -- Call the anti-slow function based on the toggle's value
        end
    })

    _G.AntiSlowToggle = true
    end

    -- Listen for character respawn and reapply the anti-slow system
    player.CharacterAdded:Connect(function()
    antiSlowToggle(toggleValue)  -- Reapply the toggle value after respawn
    end)

    -- Initial setup on first load
    if player.Character then
    antiSlowToggle(toggleValue)  -- Apply the anti-slow based on the current toggle state
    end

LeftGroupBox = Tabs.Misc:AddLeftGroupbox('Auto Stomp')

    _G.autoStomp = _G.autoStomp or false  -- Default is false if not already set

    if _G.autoStompReady == nil then
    -- Ensures this part only runs once to save resources
    _G.autoStompReady = true

    -- Variables
    local stompRemote = game.ReplicatedStorage.MainEvent -- The event you're firing
    local player = game.Players.LocalPlayer
    local stompInterval = 0.10 -- seconds between each stomp (default)
    local isLooping = false -- Start with stomping disabled
    local stompKey = Enum.KeyCode.F -- Default hotkey

    -- Cache frequently used objects
    local userInputService = game:GetService("UserInputService")
    local runService = game:GetService("RunService")
    local debrisService = game:GetService("Debris")
    
    -- Store common references once and reuse
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    
    -- Store Enum values for reusability
    local keyEnum = Enum.KeyCode.F

    -- Function to display notifications
    local function showNotification(title, text, duration)
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = title,
            Text = text,
            Duration = duration or 2 -- Default duration of 2 seconds
        })
    end

    -- Function to start stomping with precise timing
    local function startStomping()
        local lastStompTime = tick()  -- Store the current time at the start
        local stompConnection
        stompConnection = runService.Heartbeat:Connect(function()
            if isLooping then
                local currentTime = tick()
                if currentTime - lastStompTime >= stompInterval then
                    if humanoid and humanoid.Parent then
                        stompRemote:FireServer("Stomp")
                        lastStompTime = currentTime  -- Update the last stomp time
                    end
                end
            end
        end)
        _G.stompConnection = stompConnection
    end

    -- Function to stop stomping
    local function stopStomping()
        if _G.stompConnection then
            _G.stompConnection:Disconnect()
            _G.stompConnection = nil
        end
    end

    -- Function to toggle stomping with the F key or any configured key
    local function onKeyPress(input, gameProcessed)
        if not gameProcessed then
            if _G.autoStomp and input.KeyCode == stompKey then
                isLooping = not isLooping
                if isLooping then
                    showNotification("Auto Stomp Enabled", "Vilant Exploit", 3)
                    startStomping()  -- Now calling startStomping properly
                else
                    showNotification("Auto Stomp Disabled", "Vilant Exploit", 3)
                    stopStomping()
                end
            end
        end
    end

    -- UI Integration
    LeftGroupBox:AddToggle('MyToggle', {
        Text = 'Toggle Auto Stomp',
        Default = false, -- Default value (true / false)
        Tooltip = 'Toggles Stomps when walking over players', -- Information shown when you hover over the toggle
        Callback = function(Value)
            print('[cb] MyToggle changed to:', Value)
            _G.autoStomp = Value
            if _G.autoStomp then
                showNotification("Auto Stomp Enabled", "Vilant Exploit", 3)
            else
                showNotification("Auto Stomp Disabled", "Vilant Exploit", 3)
            end
        end
    })

    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
        Default = 'F', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
        SyncToggleState = false,
        Mode = 'Toggle', -- Modes: Always, Toggle, Hold
        Text = 'Auto Stomp', -- Text to display in the keybind menu
        NoUI = false, -- Set to true if you want to hide from the Keybind menu
        Callback = function(Value)
            print('[cb] Keybind clicked!', Value)
        end,
        ChangedCallback = function(New)
            print('[cb] Keybind changed!', New)
            stompKey = New -- Update the hotkey dynamically when changed
        end
    })

    LeftGroupBox:AddSlider('MySlider', {
        Text = 'Time between stomps',
        Default = stompInterval,
        Min = 0,
        Max = 1,
        Rounding = 1,
        Compact = false,
        Callback = function(Value)
            print('[cb] MySlider was changed! New value:', Value)
            stompInterval = Value -- Update stomp interval value dynamically

            -- Restart the stomping loop if it's running
            if isLooping then
                stopStomping()  -- Stop the current stomping loop
                startStomping() -- Restart it with the new interval
            end
        end
    })

    -- Connect key press event if autoStomp is true
    _G.autoStompKeyConnection = userInputService.InputBegan:Connect(onKeyPress)

    else
    -- Ensure the key press event is only active if autoStomp is true
    if _G.autoStomp then
        -- Disconnect the key press event
        if _G.autoStompKeyConnection then
            _G.autoStompKeyConnection:Disconnect()
            _G.autoStompKeyConnection = nil
        end

        -- Reset the stomp loop
        _G.autoStomp = false
    end
    _G.autoStompReady = nil
    end

  LeftGroupBox = Tabs.Misc:AddLeftGroupbox('Tp Stomp')

    -- Predefine commonly used services
    local gameReplicatedStorage = game:GetService("ReplicatedStorage")
    local userInputService = game:GetService("UserInputService")
    local starterGui = game:GetService("StarterGui")
    local runService = game:GetService("RunService")

    -- Optimize FindFirstChild usage
    local function findChild(parent, name)
    return parent:FindFirstChild(name)
    end

    -- Object Pooling for Repeatedly Used Instances (e.g., BodyEffects)
    local function getBodyEffects(player)
    return findChild(player.Character, "BodyEffects")
    end

    -- UI Setup for Tp Stomp Toggle
    LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Toggle Tp Stomp',
    Default = false,
    Tooltip = 'Toggle Teleporting to players and stomping',
    Callback = function(Value)
        _G.autoTP = Value
        if Value then
        end
        print('[cb] MyToggle changed to:', Value)
    end
    })

    -- UI Setup for Tp Back Toggle
    LeftGroupBox:AddToggle('TpBackToggle', {
    Text = 'Tp back to original position',
    Default = false,
    Tooltip = 'This makes it so after each stomp it tps back to your original position',
    Callback = function(Value)
        _G.tpBackToOriginal = Value
        print('[cb] Tp Back Toggle changed to:', Value)
    end
    })

    -- Keybind for Tp Stomp
    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
    Default = 'F',
    SyncToggleState = false,
    Mode = 'Hold',
    Text = 'Tp Stomp Keybind',
    NoUI = false,
    Callback = function(Value)
        print('[cb] Keybind clicked!', Value)
    end,
    ChangedCallback = function(New)
        _G.tpStompKey = New
        print('[cb] Keybind changed to:', New)
    end
    })

    -- Slider to change teleport range (studs)
    LeftGroupBox:AddSlider('MySlider', {
    Text = 'Teleport Range',
    Default = 100,
    Min = 0,
    Max = 5000,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        _G.teleportRange = Value
        print('[cb] MySlider was changed! New value:', Value)
    end
    })

    -- Script for teleportation functionality
    if _G.autoTP == nil then
    _G.autoTP = false
    end

    if _G.autoTPReady == nil then
    _G.autoTPReady = true

    -- Variables
    local player = game.Players.LocalPlayer
    _G.teleportRange = _G.teleportRange or 100 -- Set default range if not set
    _G.tpStompKey = _G.tpStompKey or Enum.KeyCode.F -- Default key for teleport stomp
    _G.tpBackToOriginal = _G.tpBackToOriginal == nil and false or _G.tpBackToOriginal

    -- Function to display notifications
    local function showNotification(title, text, duration)
        starterGui:SetCore("SendNotification", {
            Title = title,
            Text = text,
            Duration = duration or 2 -- Default duration of 2 seconds
        })
    end

    -- Function to find the nearest knocked player within range
    local function findNearestKnockedPlayer()
        local nearestPlayer = nil
        local shortestDistance = _G.teleportRange

        for _, otherPlayer in pairs(game.Players:GetPlayers()) do
            if otherPlayer ~= player and otherPlayer.Character then
                local bodyEffects = getBodyEffects(otherPlayer)
                local isKnocked = bodyEffects and findChild(bodyEffects, "K.O") and bodyEffects["K.O"].Value == true
                if isKnocked then
                    local torso = findChild(otherPlayer.Character, "UpperTorso") or findChild(otherPlayer.Character, "LowerTorso")
                    local playerRoot = findChild(player.Character, "HumanoidRootPart")
                    if torso and playerRoot then
                        local distance = (playerRoot.Position - torso.Position).Magnitude
                        if distance <= _G.teleportRange and distance < shortestDistance then
                            shortestDistance = distance
                            nearestPlayer = otherPlayer
                        end
                    end
                end
            end
        end
        return nearestPlayer
    end

    -- Function to teleport above a knocked player's torso, stomp, and teleport back (based on Tp Back toggle)
    local function teleportAndStomp(targetPlayer)
        if targetPlayer and targetPlayer.Character then
            local targetHumanoid = findChild(targetPlayer.Character, "Humanoid")
            local torso = findChild(targetPlayer.Character, "UpperTorso") or findChild(targetPlayer.Character, "LowerTorso")
            local playerRoot = findChild(player.Character, "HumanoidRootPart")

            if targetHumanoid and torso and playerRoot then
                -- Save the original position
                local originalPosition = playerRoot.CFrame

                -- Teleport above the player's torso (3 studs above)
                playerRoot.CFrame = CFrame.new(torso.Position + Vector3.new(0, 3, 0))

                -- Wait 0.35 seconds before stomping
                wait(0.35)

                -- Trigger the stomp action
                gameReplicatedStorage.MainEvent:FireServer("Stomp")

                -- Notify about the stomp
                showNotification("Stomping", "Vilant Exploit", 3)

                -- Wait 0.10 seconds before teleporting back (if TpBack is enabled)
                wait(0.20)

                if _G.tpBackToOriginal then
                    -- Teleport back to the original position
                    playerRoot.CFrame = originalPosition
                end
            end
        else
            showNotification("No Target Found", "Vilant Exploit", 3)
        end
    end

    -- Function to handle key press
    local function onKeyPress(input)
        if _G.autoTP and input.KeyCode == _G.tpStompKey then
            local targetPlayer = findNearestKnockedPlayer()
            teleportAndStomp(targetPlayer)
        end
    end

    -- Connect key press event
    _G.autoTPKeyConnection = userInputService.InputBegan:Connect(onKeyPress)
    else
    -- Disconnect the key press event
    if _G.autoTPKeyConnection then
        _G.autoTPKeyConnection:Disconnect()
        _G.autoTPKeyConnection = nil
    end

    -- Reset the script state
    _G.autoTP = false
    _G.autoTPReady = nil
    end

LeftGroupBox = Tabs.Misc:AddLeftGroupbox('Anti Stomp')

local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local debris = game:GetService("Debris")  -- For cleanup

-- Assuming LeftGroupBox and other UI elements are set up previously
local antiStompEnabled = false  -- Default value for anti-stomp toggle

-- Cache Enum values that are used frequently
local HumanoidStateType = Enum.HumanoidStateType
local KOD = "K.O"
local GRABBING_CONSTRAINT = "GRABBING_CONSTRAINT"

-- Add the Anti Stomp toggle
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Anti Stomp',
    Default = false, -- Default value (true / false)
    Tooltip = 'Destroys character when knocked preventing stomps',
    
    Callback = function(Value)
        antiStompEnabled = Value  -- Update the toggle value
    end
})

-- RunService heartbeat to monitor character state
RunService.Heartbeat:Connect(function()
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")

    -- Check if the character and humanoid exist
    if character and humanoid then
        -- Use a variable for BodyEffects and K.O state to avoid repeated calls
        local bodyEffects = character:FindFirstChild("BodyEffects")
        local KOd = bodyEffects and bodyEffects[KOD] and bodyEffects[KOD].Value
        local Grabbed = character:FindFirstChild(GRABBING_CONSTRAINT) ~= nil

        -- Only execute if Anti Stomp is enabled
        if antiStompEnabled and (KOd or Grabbed) then
            -- Prevent interaction by disabling humanoid interactions
            humanoid.PlatformStand = true  -- Disable normal character movements
            humanoid.WalkSpeed = 0  -- Prevent walking
            humanoid.JumpHeight = 0  -- Prevent jumping
            humanoid.Health = 0  -- Force kill the character immediately

            -- Disable collision to make it untouchable by other players
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false  -- Disable collision with other players
                end
            end

            -- Disable unnecessary humanoid states
            humanoid:SetStateEnabled(HumanoidStateType.Physics, false)
            humanoid:SetStateEnabled(HumanoidStateType.Seated, false)
            humanoid:SetStateEnabled(HumanoidStateType.Climbing, false)
            humanoid:SetStateEnabled(HumanoidStateType.Freefall, false)
            humanoid:SetStateEnabled(HumanoidStateType.Ragdoll, false)

            -- Prevent health changes from other players
            humanoid.MaxHealth = humanoid.Health

            -- Clean up BodyEffects to remove any effects causing interaction
            if bodyEffects then
                bodyEffects:ClearAllChildren()
            end

            -- Prevent stomping or any other interaction from players
            local collisionParts = character:GetChildren()
            for _, part in pairs(collisionParts) do
                if part:IsA("BasePart") then
                    part.CanCollide = false  -- Fully prevent collision interactions
                end
            end

            -- Immediately reset the character to remove any potential interaction
            player:LoadCharacter()  -- Reload the character to reset the player
        end
    end
end)

LeftGroupBox = Tabs.Misc:AddLeftGroupbox('Spin Bot')

--[[ 
Controls:
- Use the toggle in the UI to enable or disable SpinBot.
- Use the slider to adjust the SpinBot speed.
]]

-- Ensure proper initialization
if _G.spinBotInitialized == nil then
    _G.spinBotInitialized = false
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local plr = Players.LocalPlayer
local humRoot, humanoid

-- Function to apply SpinBot
local function applySpinBot()
    if _G.spinBotActive and humRoot and humanoid then
        humanoid.AutoRotate = false
        local velocity = Instance.new("AngularVelocity")
        velocity.Attachment0 = humRoot:FindFirstChild("RootAttachment")
        velocity.MaxTorque = math.huge
        velocity.AngularVelocity = Vector3.new(0, _G.spinBotSpeed or 50, 0)
        velocity.Parent = humRoot
        velocity.Name = "Spinbot"
    end
end

-- Function to update character references
local function updateCharacterReferences()
    local character = plr.Character or plr.CharacterAdded:Wait()
    humRoot = character:WaitForChild("HumanoidRootPart")
    humanoid = character:FindFirstChildOfClass("Humanoid")
    
    -- Restore SpinBot after respawn if it was active
    task.wait(0.5)
    applySpinBot()
end

updateCharacterReferences()
plr.CharacterAdded:Connect(updateCharacterReferences)

-- UI Toggle for SpinBot
LeftGroupBox:AddToggle('SpinBotToggle', {
    Text = 'Spin Bot',
    Default = false,
    Tooltip = 'Makes you spin',
    Callback = function(Value)
        if Value then
            _G.spinBotActive = true
            _G.spinBotInitialized = true
            applySpinBot()
        else
            _G.spinBotActive = false
            _G.spinBotInitialized = false
            
            if humRoot and humanoid then
                humRoot.CFrame = CFrame.new(humRoot.Position)
                humanoid.AutoRotate = true
            end
            
            local velocity = humRoot and humRoot:FindFirstChild("Spinbot")
            if velocity then
                velocity:Destroy()
            end
        end
    end
})

-- UI Slider for SpinBot Speed
LeftGroupBox:AddSlider('SpinBotSpeed', {
    Text = 'SpinBot Speed',
    Default = 50,
    Min = 1,
    Max = 150,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        _G.spinBotSpeed = Value
        if _G.spinBotActive and humRoot then
            local velocity = humRoot:FindFirstChild("Spinbot")
            if velocity then
                velocity.AngularVelocity = Vector3.new(0, Value, 0)
            end
        end
    end
})

LeftGroupBox = Tabs.Misc:AddLeftGroupbox('Avatar Forcefield')

    -- References to services and default settings
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local player = Players.LocalPlayer

    -- Constants for materials and default values
    local FORCEFIELD_MATERIAL = Enum.Material.ForceField
    local DEFAULT_MATERIAL = Enum.Material.Plastic
    local DEFAULT_COLOR = Color3.fromRGB(255, 255, 255)
    local currentColor = Color3.fromRGB(108, 59, 170) -- Default forcefield color
    local forcefieldEnabled = false -- Tracks whether the forcefield effect is enabled

    -- Function to customize character parts
    local function customizeCharacter(character, newColor)
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            if forcefieldEnabled then
                part.Color = newColor -- Apply the new color
                part.Material = FORCEFIELD_MATERIAL -- Apply ForceField material
            else
                part.Material = DEFAULT_MATERIAL -- Default material
                part.Color = DEFAULT_COLOR -- Default white color
            end
        end
    end
    end

    -- Function to handle player character updates
    local function onCharacterAdded(character)
    if forcefieldEnabled then
        customizeCharacter(character, currentColor)
    end
    end

    -- Connection to handle new character spawns
    player.CharacterAdded:Connect(onCharacterAdded)

    -- UI Integration
    LeftGroupBox:AddToggle('ForcefieldToggle', {
    Text = 'Enable Forcefield',
    Default = false, -- Default value (disabled)
    Tooltip = 'Toggle the forcefield effect on your character.',

    Callback = function(Value)
        forcefieldEnabled = Value
        print('[cb] Forcefield toggled:', Value)

        -- Apply or remove forcefield effect immediately
        local character = player.Character
        if character then
            customizeCharacter(character, currentColor)
        end
    end
    })

    LeftGroupBox:AddLabel('Forcefield Color'):AddColorPicker('ForcefieldColorPicker', {
    Default = currentColor, -- Default color
    Title = 'Select Forcefield Color',
    Transparency = 0, -- Disable transparency changing

    Callback = function(Value)
        print('[cb] Forcefield color changed:', Value)

        -- Update current color and apply the new color if the forcefield is enabled
        currentColor = Value
        local character = player.Character
        if forcefieldEnabled and character then
            customizeCharacter(character, currentColor)
        end
    end
    })

    -- Use RunService to update forcefield effect efficiently
    RunService.Heartbeat:Connect(function()
    if forcefieldEnabled then
        local character = player.Character
        if character then
            customizeCharacter(character, currentColor)
        end
    end
    end)

RightGroupBox = Tabs.Visuals:AddRightGroupbox('Low GFX')

    MyButton = RightGroupBox:AddButton({
    Text = 'Low GFX CANT BE REVERTED',
    Func = function()
        if not _G.Ignore then
            _G.Ignore = {} -- Add Instances to this table to ignore them (e.g. _G.Ignore = {workspace.Map, workspace.Map2})
        end
        if not _G.WaitPerAmount then
            _G.WaitPerAmount = 500 -- Set Higher or Lower depending on your computer's performance
        end
        if _G.SendNotifications == nil then
            _G.SendNotifications = true -- Set to false if you don't want notifications
        end
        if _G.ConsoleLogs == nil then
            _G.ConsoleLogs = false -- Set to true if you want console logs (mainly for debugging)
        end
        
        
        
        if not game:IsLoaded() then
            repeat
                task.wait()
            until game:IsLoaded()
        end
        if not _G.Settings then
            _G.Settings = {
                Players = {
                    ["Ignore Me"] = true,
                    ["Ignore Others"] = true,
                    ["Ignore Tools"] = true
                },
                Meshes = {
                    NoMesh = false,
                    NoTexture = false,
                    Destroy = false
                },
                Images = {
                    Invisible = true,
                    Destroy = false
                },
                Explosions = {
                    Smaller = true,
                    Invisible = false, -- Not recommended for PVP games
                    Destroy = false -- Not recommended for PVP games
                },
                Particles = {
                    Invisible = true,
                    Destroy = false
                },
                TextLabels = {
                    LowerQuality = false,
                    Invisible = false,
                    Destroy = false
                },
                MeshParts = {
                    LowerQuality = true,
                    Invisible = false,
                    NoTexture = false,
                    NoMesh = false,
                    Destroy = false
                },
                Other = {
                    ["FPS Cap"] = true, -- Set this true to uncap FPS
                    ["No Camera Effects"] = true,
                    ["No Clothes"] = true,
                    ["Low Water Graphics"] = true,
                    ["No Shadows"] = true,
                    ["Low Rendering"] = false,
                    ["Low Quality Parts"] = true,
                    ["Low Quality Models"] = true,
                    ["Reset Materials"] = true,
                    ["Lower Quality MeshParts"] = true
                }
            }
        end
        local Players, Lighting, StarterGui, MaterialService = game:GetService("Players"), game:GetService("Lighting"), game:GetService("StarterGui"), game:GetService("MaterialService")
        local ME, CanBeEnabled = Players.LocalPlayer, {"ParticleEmitter", "Trail", "Smoke", "Fire", "Sparkles"}
        local function PartOfCharacter(Instance)
            for i, v in pairs(Players:GetPlayers()) do
                if v ~= ME and v.Character and Instance:IsDescendantOf(v.Character) then
                    return true
                end
            end
            return false
        end
        local function DescendantOfIgnore(Instance)
            for i, v in pairs(_G.Ignore) do
                if Instance:IsDescendantOf(v) then
                    return true
                end
            end
            return false
        end
        local function CheckIfBad(Instance)
            if not Instance:IsDescendantOf(Players) and (_G.Settings.Players["Ignore Others"] and not PartOfCharacter(Instance) or not _G.Settings.Players["Ignore Others"]) and (_G.Settings.Players["Ignore Me"] and ME.Character and not Instance:IsDescendantOf(ME.Character) or not _G.Settings.Players["Ignore Me"]) and (_G.Settings.Players["Ignore Tools"] and not Instance:IsA("BackpackItem") and not Instance:FindFirstAncestorWhichIsA("BackpackItem") or not _G.Settings.Players["Ignore Tools"])--[[not PartOfCharacter(Instance)]] and (_G.Ignore and not table.find(_G.Ignore, Instance) and not DescendantOfIgnore(Instance) or (not _G.Ignore or type(_G.Ignore) ~= "table" or #_G.Ignore <= 0)) then
                if Instance:IsA("DataModelMesh") then
                    if _G.Settings.Meshes.NoMesh and Instance:IsA("SpecialMesh") then
                        Instance.MeshId = ""
                    end
                    if _G.Settings.Meshes.NoTexture and Instance:IsA("SpecialMesh") then
                        Instance.TextureId = ""
                    end
                    if _G.Settings.Meshes.Destroy or _G.Settings["No Meshes"] then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("FaceInstance") then
                    if _G.Settings.Images.Invisible then
                        Instance.Transparency = 1
                        Instance.Shiny = 1
                    end
                    if _G.Settings.Images.LowDetail then
                        Instance.Shiny = 1
                    end
                    if _G.Settings.Images.Destroy then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("ShirtGraphic") then
                    if _G.Settings.Images.Invisible then
                        Instance.Graphic = ""
                    end
                    if _G.Settings.Images.Destroy then
                        Instance:Destroy()
                    end
                elseif table.find(CanBeEnabled, Instance.ClassName) then
                    if _G.Settings["Invisible Particles"] or _G.Settings["No Particles"] or (_G.Settings.Other and _G.Settings.Other["Invisible Particles"]) or (_G.Settings.Particles and _G.Settings.Particles.Invisible) then
                        Instance.Enabled = false
                    end
                    if (_G.Settings.Other and _G.Settings.Other["No Particles"]) or (_G.Settings.Particles and _G.Settings.Particles.Destroy) then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("PostEffect") and (_G.Settings["No Camera Effects"] or (_G.Settings.Other and _G.Settings.Other["No Camera Effects"])) then
                    Instance.Enabled = false
                elseif Instance:IsA("Explosion") then
                    if _G.Settings["Smaller Explosions"] or (_G.Settings.Other and _G.Settings.Other["Smaller Explosions"]) or (_G.Settings.Explosions and _G.Settings.Explosions.Smaller) then
                        Instance.BlastPressure = 1
                        Instance.BlastRadius = 1
                    end
                    if _G.Settings["Invisible Explosions"] or (_G.Settings.Other and _G.Settings.Other["Invisible Explosions"]) or (_G.Settings.Explosions and _G.Settings.Explosions.Invisible) then
                        Instance.BlastPressure = 1
                        Instance.BlastRadius = 1
                        Instance.Visible = false
                    end
                    if _G.Settings["No Explosions"] or (_G.Settings.Other and _G.Settings.Other["No Explosions"]) or (_G.Settings.Explosions and _G.Settings.Explosions.Destroy) then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("Clothing") or Instance:IsA("SurfaceAppearance") or Instance:IsA("BaseWrap") then
                    if _G.Settings["No Clothes"] or (_G.Settings.Other and _G.Settings.Other["No Clothes"]) then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("BasePart") and not Instance:IsA("MeshPart") then
                    if _G.Settings["Low Quality Parts"] or (_G.Settings.Other and _G.Settings.Other["Low Quality Parts"]) then
                        Instance.Material = Enum.Material.Plastic
                        Instance.Reflectance = 0
                    end
                elseif Instance:IsA("TextLabel") and Instance:IsDescendantOf(workspace) then
                    if _G.Settings["Lower Quality TextLabels"] or (_G.Settings.Other and _G.Settings.Other["Lower Quality TextLabels"]) or (_G.Settings.TextLabels and _G.Settings.TextLabels.LowerQuality) then
                        Instance.Font = Enum.Font.SourceSans
                        Instance.TextScaled = false
                        Instance.RichText = false
                        Instance.TextSize = 14
                    end
                    if _G.Settings["Invisible TextLabels"] or (_G.Settings.Other and _G.Settings.Other["Invisible TextLabels"]) or (_G.Settings.TextLabels and _G.Settings.TextLabels.Invisible) then
                        Instance.Visible = false
                    end
                    if _G.Settings["No TextLabels"] or (_G.Settings.Other and _G.Settings.Other["No TextLabels"]) or (_G.Settings.TextLabels and _G.Settings.TextLabels.Destroy) then
                        Instance:Destroy()
                    end
                elseif Instance:IsA("Model") then
                    if _G.Settings["Low Quality Models"] or (_G.Settings.Other and _G.Settings.Other["Low Quality Models"]) then
                        Instance.LevelOfDetail = 1
                    end
                elseif Instance:IsA("MeshPart") then
                    if _G.Settings["Low Quality MeshParts"] or (_G.Settings.Other and _G.Settings.Other["Low Quality MeshParts"]) or (_G.Settings.MeshParts and _G.Settings.MeshParts.LowerQuality) then
                        Instance.RenderFidelity = 2
                        Instance.Reflectance = 0
                        Instance.Material = Enum.Material.Plastic
                    end
                    if _G.Settings["Invisible MeshParts"] or (_G.Settings.Other and _G.Settings.Other["Invisible MeshParts"]) or (_G.Settings.MeshParts and _G.Settings.MeshParts.Invisible) then
                        Instance.Transparency = 1
                        Instance.RenderFidelity = 2
                        Instance.Reflectance = 0
                        Instance.Material = Enum.Material.Plastic
                    end
                    if _G.Settings.MeshParts and _G.Settings.MeshParts.NoTexture then
                        Instance.TextureID = ""
                    end
                    if _G.Settings.MeshParts and _G.Settings.MeshParts.NoMesh then
                        Instance.MeshId = ""
                    end
                    if _G.Settings["No MeshParts"] or (_G.Settings.Other and _G.Settings.Other["No MeshParts"]) or (_G.Settings.MeshParts and _G.Settings.MeshParts.Destroy) then
                        Instance:Destroy()
                    end
                end
            end
        end
        coroutine.wrap(pcall)(function()
            if (_G.Settings["Low Water Graphics"] or (_G.Settings.Other and _G.Settings.Other["Low Water Graphics"])) then
                if not workspace:FindFirstChildOfClass("Terrain") then
                    repeat
                        task.wait()
                    until workspace:FindFirstChildOfClass("Terrain")
                end
                workspace:FindFirstChildOfClass("Terrain").WaterWaveSize = 0
                workspace:FindFirstChildOfClass("Terrain").WaterWaveSpeed = 0
                workspace:FindFirstChildOfClass("Terrain").WaterReflectance = 0
                workspace:FindFirstChildOfClass("Terrain").WaterTransparency = 0
                if sethiddenproperty then
                    sethiddenproperty(workspace:FindFirstChildOfClass("Terrain"), "Decoration", false)
                else
                    warn("Your exploit does not support sethiddenproperty, please use a different exploit.")
                end
                if _G.ConsoleLogs then
                    warn("Low Water Graphics Enabled")
                end
            end
        end)
        coroutine.wrap(function()
            pcall(function()
                if _G.Settings["No Shadows"] or (_G.Settings.Other and _G.Settings.Other["No Shadows"]) then
                    Lighting.GlobalShadows = false
                    Lighting.FogEnd = 9e9
                    Lighting.ShadowSoftness = 0
                    if sethiddenproperty then
                        sethiddenproperty(Lighting, "Technology", 2)
                    end
                    if _G.ConsoleLogs then
                        warn("No Shadows Enabled")
                    end
                end
            end)
        end)()
        
        -- Low Rendering
        coroutine.wrap(function()
            pcall(function()
                if _G.Settings["Low Rendering"] or (_G.Settings.Other and _G.Settings.Other["Low Rendering"]) then
                    settings().Rendering.QualityLevel = 1
                    settings().Rendering.MeshPartDetailLevel = Enum.MeshPartDetailLevel.Level04
                    if _G.ConsoleLogs then
                        warn("Low Rendering Enabled")
                    end
                end
            end)
        end)()
        
        -- Reset Materials
        coroutine.wrap(function()
            pcall(function()
                if _G.Settings["Reset Materials"] or (_G.Settings.Other and _G.Settings.Other["Reset Materials"]) then
                    for i, v in pairs(MaterialService:GetChildren()) do
                        v:Destroy()
                    end
                    if _G.ConsoleLogs then
                        warn("Reset Materials Enabled")
                    end
                end
            end)
        end)()
        coroutine.wrap(function()
            pcall(function()
                if _G.Settings["FPS Cap"] or (_G.Settings.Other and _G.Settings.Other["FPS Cap"]) then
                    local fpsCapSetting = _G.Settings["FPS Cap"] or (_G.Settings.Other and _G.Settings.Other["FPS Cap"])
        
                    if type(fpsCapSetting) == "string" or type(fpsCapSetting) == "number" then
                        if setfpscap then
                            setfpscap(tonumber(fpsCapSetting))
                            if _G.ConsoleLogs then
                                warn("FPS Capped to " .. tostring(fpsCapSetting))
                            end
                        end
                    elseif fpsCapSetting == true then
                        if setfpscap then
                            setfpscap(1e6)
                            if _G.ConsoleLogs then
                                warn("FPS Uncapped")
                            end
                        end
                    end
                else
                    warn("FPS Cap Failed")
                end
            end)
        end)()
        game.DescendantAdded:Connect(function(value)
            wait(_G.LoadedWait or 1)
            CheckIfBad(value)
        end)
        
        local Descendants = game:GetDescendants()
        local StartNumber = _G.WaitPerAmount or 500
        local WaitNumber = _G.WaitPerAmount or 500
        if _G.ConsoleLogs then
            warn("Checking " .. #Descendants .. " Instances...")
        end
        for i, v in pairs(Descendants) do
            CheckIfBad(v)
            if i == WaitNumber then
                task.wait()
                if _G.ConsoleLogs then
                    print("Loaded " .. i .. "/" .. #Descendants)
                end
                WaitNumber = WaitNumber + StartNumber
            end
        end
        
        StarterGui:SetCore("SendNotification", {
            Title = "Fps Booster Loaded",
            Text = "Vilant Exploit",
            Duration = 5,
        })
        
        warn("FPS Booster Loaded!")
        --game.DescendantAdded:Connect(CheckIfBad)
        --[[game.DescendantAdded:Connect(function(value)
            CheckIfBad(value)
        end)]]
    end,
    DoubleClick = true,
    Tooltip = 'Makes your Gfx low CANT BE REVERTED'
    })

LeftGroupBox = Tabs.Teleport:AddLeftGroupbox('Teleports')

MyButton = LeftGroupBox:AddButton({
    Text = 'Bank',
    Func = function()
        teleportCFrame = CFrame.new(-442, 39, -284)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Inside Bank',
    Func = function()
        teleportCFrame = CFrame.new(-443, 23, -284)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})


MyButton = LeftGroupBox:AddButton({
    Text = 'Vault',
    Func = function()
        teleportCFrame = CFrame.new(-658, -30, -285)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Mid Appartment Building',
    Func = function()
        teleportCFrame = CFrame.new(-323, 80, -299)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Revolver',
    Func = function()
        teleportCFrame = CFrame.new(-634, 21, -132)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'LMG',
    Func = function()
        teleportCFrame = CFrame.new(-626, 23, -295)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Swimming Pool',
    Func = function()
        teleportCFrame = CFrame.new(-847, 21, -279)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Broken Fire Station',
    Func = function()
        teleportCFrame = CFrame.new(-1182, 28, -521)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'DownHill',
    Func = function()
        teleportCFrame = CFrame.new(-559, 8, -735)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Military Base',
    Func = function()
        teleportCFrame = CFrame.new(-40, 65, -926)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Uphill',
    Func = function()
        teleportCFrame = CFrame.new(481, 48, -602)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Breaking Bad',
    Func = function()
        teleportCFrame = CFrame.new(598, 28, -214)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Church',
    Func = function()
        teleportCFrame = CFrame.new(205, 21, -124)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'Police Station',
    Func = function()
        teleportCFrame = CFrame.new(-264, 21, -93)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = LeftGroupBox:AddButton({
    Text = 'School',
    Func = function()
        teleportCFrame = CFrame.new(-594, 21, 173)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

RightGroupBox = Tabs.Movement:AddRightGroupbox('Player Animations')

    Players = game:GetService("Players")  -- Store the Players service in a variable
    player = Players.LocalPlayer  -- Store the LocalPlayer in a variable

    -- Base URL for the animation assets
    animationBaseUrl = "http://www.roblox.com/asset/?id="

    -- Table of animations with optimized base URL usage
    animations = {
    R15 = {
        idle = animationBaseUrl .. "2510196951",
        walk = animationBaseUrl .. "2510202577",
        run = animationBaseUrl .. "2510198475",
        jump = animationBaseUrl .. "2510197830",
        climb = animationBaseUrl .. "2510192778",
        fall = animationBaseUrl .. "2510195892",
    },
    Loser = {
        idle = animationBaseUrl .. "782841498",
        walk = animationBaseUrl .. "616168032",
        run = animationBaseUrl .. "616163682",
        jump = animationBaseUrl .. "1083218792",
        climb = animationBaseUrl .. "1083439238",
        fall = animationBaseUrl .. "707829716",
    },
    Astronaut = {
        idle = animationBaseUrl .. "891621366",
        jump = animationBaseUrl .. "891627522",
        fall = animationBaseUrl .. "891617961",
        walk = animationBaseUrl .. "891667138",
        run = animationBaseUrl .. "891636393",
        climb = animationBaseUrl .. "891609353",
    },
    Bubbly = {
        idle = animationBaseUrl .. "910004836",
        jump = animationBaseUrl .. "910016857",
        fall = animationBaseUrl .. "910001910",
        walk = animationBaseUrl .. "910034870",
        run = animationBaseUrl .. "910025107",
        climb = animationBaseUrl .. "940996062",
    },
    Cartoony = {
        idle = animationBaseUrl .. "742637544",
        jump = animationBaseUrl .. "742637942",
        fall = animationBaseUrl .. "742637151",
        walk = animationBaseUrl .. "742640026",
        run = animationBaseUrl .. "742638842",
        climb = animationBaseUrl .. "742636889",
    },
    Confident = {
        idle = animationBaseUrl .. "1069977950",
        jump = animationBaseUrl .. "1069984524",
        fall = animationBaseUrl .. "1069973677",
        walk = animationBaseUrl .. "1070017263",
        run = animationBaseUrl .. "1070001516",
        climb = animationBaseUrl .. "1069946257",
    },
    Cowboy = {
        idle = animationBaseUrl .. "1014390418",
        jump = animationBaseUrl .. "1014394726",
        fall = animationBaseUrl .. "1014384571",
        walk = animationBaseUrl .. "1014421541",
        run = animationBaseUrl .. "1014401683",
        climb = animationBaseUrl .. "1014380606",
    },
    Elder = {
        idle = animationBaseUrl .. "845397899",
        jump = animationBaseUrl .. "845398858",
        fall = animationBaseUrl .. "845396048",
        walk = animationBaseUrl .. "845403856",
        run = animationBaseUrl .. "845386501",
        climb = animationBaseUrl .. "845392038",
    },
    Knight = {
        idle = animationBaseUrl .. "657595757",
        jump = animationBaseUrl .. "658409194",
        fall = animationBaseUrl .. "657600338",
        walk = animationBaseUrl .. "657552124",
        run = animationBaseUrl .. "657564596",
        climb = animationBaseUrl .. "658360781",
    },
    Levitation = {
        idle = animationBaseUrl .. "616006778",
        jump = animationBaseUrl .. "616008936",
        fall = animationBaseUrl .. "616005863",
        walk = animationBaseUrl .. "616013216",
        run = animationBaseUrl .. "616010382",
        climb = animationBaseUrl .. "616003713",
    },
    Mage = {
        idle = animationBaseUrl .. "707742142",
        jump = animationBaseUrl .. "707853694",
        fall = animationBaseUrl .. "707829716",
        walk = animationBaseUrl .. "707897309",
        run = animationBaseUrl .. "707861613",
        climb = animationBaseUrl .. "707826056",
    },
    Ninja = {
        idle = animationBaseUrl .. "656117400",
        jump = animationBaseUrl .. "656117878",
        fall = animationBaseUrl .. "656115606",
        walk = animationBaseUrl .. "656121766",
        run = animationBaseUrl .. "656118852",
        climb = animationBaseUrl .. "656114359",
    },
    Patrol = {
        idle = animationBaseUrl .. "1149612882",
        jump = animationBaseUrl .. "1148811837",
        fall = animationBaseUrl .. "1148863382",
        walk = animationBaseUrl .. "1151231493",
        run = animationBaseUrl .. "1150967949",
        climb = animationBaseUrl .. "1148811837",
    },
    Pirate = {
        idle = animationBaseUrl .. "750781874",
        jump = animationBaseUrl .. "750782230",
        fall = animationBaseUrl .. "750780242",
        walk = animationBaseUrl .. "750785693",
        run = animationBaseUrl .. "750783738",
        climb = animationBaseUrl .. "750779899",
    },
    Popstar = {
        idle = animationBaseUrl .. "1212900985",
        jump = animationBaseUrl .. "1212954642",
        fall = animationBaseUrl .. "1212900995",
        walk = animationBaseUrl .. "1212980338",
        run = animationBaseUrl .. "1212980348",
        climb = animationBaseUrl .. "1213044953",
    },
    Princess = {
        idle = animationBaseUrl .. "941003647",
        jump = animationBaseUrl .. "941008832",
        fall = animationBaseUrl .. "941000007",
        walk = animationBaseUrl .. "941028902",
        run = animationBaseUrl .. "941015281",
        climb = animationBaseUrl .. "940996062",
    },
    Robot = {
        idle = animationBaseUrl .. "616088211",
        jump = animationBaseUrl .. "616090535",
        fall = animationBaseUrl .. "616087089",
        walk = animationBaseUrl .. "616095330",
        run = animationBaseUrl .. "616091570",
        climb = animationBaseUrl .. "616086039",
    },
    Sneaky = {
        idle = animationBaseUrl .. "1132473842",
        jump = animationBaseUrl .. "1132489853",
        fall = animationBaseUrl .. "1132469004",
        walk = animationBaseUrl .. "1132510133",
        run = animationBaseUrl .. "1132494274",
        climb = animationBaseUrl .. "1132461372",
    },
    Stylish = {
        idle = animationBaseUrl .. "616136790",
        jump = animationBaseUrl .. "616139451",
        fall = animationBaseUrl .. "616134815",
        walk = animationBaseUrl .. "616146177",
        run = animationBaseUrl .. "616140816",
        climb = animationBaseUrl .. "616133594",
    },
    Superhero = {
        idle = animationBaseUrl .. "616111295",
        jump = animationBaseUrl .. "616115533",
        fall = animationBaseUrl .. "616108001",
        walk = animationBaseUrl .. "616122287",
        run = animationBaseUrl .. "616117076",
        climb = animationBaseUrl .. "616104706",
    },
    Toy = {
        idle = animationBaseUrl .. "782841498",
        jump = animationBaseUrl .. "782847020",
        fall = animationBaseUrl .. "782846423",
        walk = animationBaseUrl .. "782843345",
        run = animationBaseUrl .. "782842708",
        climb = animationBaseUrl .. "782843869",
    },
    Vampire = {
        idle = animationBaseUrl .. "1083445855",
        jump = animationBaseUrl .. "1083455352",
        fall = animationBaseUrl .. "1083443587",
        walk = animationBaseUrl .. "1083473930",
        run = animationBaseUrl .. "1083462077",
        climb = animationBaseUrl .. "1083439238",
    },
    Werewolf = {
        idle = animationBaseUrl .. "1083195517",
        jump = animationBaseUrl .. "1083218792",
        fall = animationBaseUrl .. "1083189019",
        walk = animationBaseUrl .. "1083178339",
        run = animationBaseUrl .. "1083216690",
        climb = animationBaseUrl .. "1083182000",
    },
    Zombie = {
        idle = animationBaseUrl .. "616158929",
        jump = animationBaseUrl .. "616161997",
        fall = animationBaseUrl .. "616157476",
        walk = animationBaseUrl .. "616168032",
        run = animationBaseUrl .. "616163682",
        climb = animationBaseUrl .. "616156119",
    },
    RealisticZombie = {
        idle = animationBaseUrl .. "3489171152",
        jump = animationBaseUrl .. "616161997",
        fall = animationBaseUrl .. "616157476",
        walk = animationBaseUrl .. "3489174223",
        run = animationBaseUrl .. "3489173414",
        climb = animationBaseUrl .. "616156119", 
    },
    }

    -- Function to apply animations based on the selected preset
    local function applyAnimations(animate, preset)
    -- Ensure the animation IDs are applied correctly
    if animate and preset then
        if animate.idle and animate.idle:FindFirstChild("Animation1") then
            animate.idle.Animation1.AnimationId = preset.idle
        else
            warn("Idle animation or Animation1 not found")
        end
        
        if animate.walk and animate.walk:FindFirstChild("WalkAnim") then
            animate.walk.WalkAnim.AnimationId = preset.walk
        else
            warn("Walk animation or WalkAnim not found")
        end

        if animate.run and animate.run:FindFirstChild("RunAnim") then
            animate.run.RunAnim.AnimationId = preset.run
        else
            warn("Run animation or RunAnim not found")
        end

        if animate.jump and animate.jump:FindFirstChild("JumpAnim") then
            animate.jump.JumpAnim.AnimationId = preset.jump
        else
            warn("Jump animation or JumpAnim not found")
        end

        if animate.climb and animate.climb:FindFirstChild("ClimbAnim") then
            animate.climb.ClimbAnim.AnimationId = preset.climb
        else
            warn("Climb animation or ClimbAnim not found")
        end

        if animate.fall and animate.fall:FindFirstChild("FallAnim") then
            animate.fall.FallAnim.AnimationId = preset.fall
        else
            warn("Fall animation or FallAnim not found")
        end
    end
    end

    -- Function to apply the selected animation preset to the player's character
    local function applySelectedAnimations(character)
    -- Ensure the character has the Animate object
    local animate = character:FindFirstChild("Animate")
    if animate then
        local selectedPreset = animations[currentAnimationPreset]  -- Use the preset based on the dropdown
        applyAnimations(animate, selectedPreset)
    end
    end

    -- Set up the dropdown to choose which animation preset to apply
    RightGroupBox:AddDropdown('AnimationSelector', {
    Values = {'R15', 'Loser', 'Astronaut', 'Bubbly', 'Cartoony', 'Confident', 'Cowboy', 'Elder', 'Knight', 'Levitation', 'Mage', 'Ninja', 'Patrol', 'Pirate', 'Popstar', 'Princess', 'Robot', 'Sneaky', 'Stylish', 'Superhero', 'Toy', 'Vampire', 'Werewolf', 'Zombie', 'RealisticZombie'}, -- Add new presets here if needed
    Default = 1, -- Default option (R15)
    Multi = false, -- Allow single selection only

    Text = 'Select Animation',
    Tooltip = 'Choose the animation you want to apply',

    Callback = function(Value)
        currentAnimationPreset = Value  -- Update the preset based on the dropdown selection
    end
    })

    -- Connect to Heartbeat and apply the animation every frame
    game:GetService("RunService").Heartbeat:Connect(function()
    if player.Character then
        applySelectedAnimations(player.Character)  -- Apply the selected animation
    end
    end)

watermarkVisible = true  -- Boolean to track watermark visibility
Library:SetWatermarkVisibility(watermarkVisible)  -- Set initial visibility to true

function toggleWatermarkVisibility(Value)
    watermarkVisible = Value  -- Update the visibility state
    Library:SetWatermarkVisibility(watermarkVisible)  -- Apply the new visibility
end

FrameTimer = tick()
FrameCounter = 0
FPS = 60

-- Corrected FPS and Ping update inside RenderStepped
WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    if not watermarkVisible then return end  -- Skip updating if watermark is hidden

    FrameCounter += 1

    -- Update FPS every second
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end

    -- Update watermark with FPS and Ping
    local ping = math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    Library:SetWatermark(('Vilant v1.8 | %s fps | %s ms'):format(
        math.floor(FPS),
        ping
    ))
end)
